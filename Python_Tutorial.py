##########################################################################################################
#VSCODE_SHORTCUT
##########################################################################################################
#ctrl + x           cut
#ctrl + c           copy
#ctrl + ?           comment & uncomment
#ctrl + v           paste
#ctrl + z           undo
#ctrl + y           redo
#ctrl + s           save
#ctrl + shift + s   saves all documents and projects
#ctrl + a           select all
#ctrl + b           side bar (hide/show)
#ctrl + p           search bar
#                   recent opened files
#ctrl + `           terminal
#ctrl + g           search bar with : command
#ctrl + f           find
#ctrl + end         moves the cursor to the end of the document
#ctrl + home        moves the cursor to the start of the document
#ctrl + up          screen up
#ctrl + down        screen down
#ctrl + k           waiting for next command
#ctrl + o           open file
#ctrl + shift + n   open new project
#ctrl + shift + x   extensions from side bar
#ctrl + shift + e   explorer from side bar
#ctrl + shift + g   git from side bar
#ctrl + shift + k
#ctrl + shift + [   fold
#ctrl + shift + ]   unfold

#ctrl + alt         select multiple lines as selector
#shift + end        go to end of all selected lines
#shift + home       go to end of all selected lines

#shift + alt + down copy line (duplicate line)
#shift + alt + up   copy line (duplicate line)


#ctrl + shift + p   command pallet
#                   > 
#                   > reload window
#                   > open keyboard shortcuts
#                   > open user settings
#                   > open user settings (JSON)

"""
"window.newWindowDimensions" : "inherit",
"editor.multiCursorModifier" : "ctrlCmd",
"files.trimTrailingWhitespace" : true,
"editor.snippetSuggestions" : "top",
"editor.copyWithSyntaxHighlighting" : false,
"editor.detectIndentation" : false,
"files.insertFinalNewline" : true,
"files.trimFinalNewlines" : true,
"editor.emptySelectionClipboard" : false,

"editor.minimap.enabled" : false,
"window.menuBarVisibility" : "compact",
"workbench.statusBar.visible" : false,
"workbench.editor.showTabs" : "none",
"workbench.sideBar.location" : "right",
"window.commandCenter" : false,
"workbench.layoutControl.enabled" : false,

"workbench.colorTheme" : "Electron"
"editor.fontFamily" : "'Fira Code'"
"editor.fontLigatures" : true,
"editor.fontSize" : 19,
"editor.lineHeight" : 2.2,
"editor.fontWeight" : "500",
"terminal.integrated.fontFamily" : "'Fira Code'",
"terminal.integrated.fontSize" : .8,
"terminal.integrated.fontWeight" : "600",
"terminal.integrated.lineHeight" : 1.5,
"workbench.iconTheme" : "material-icon-theme",
"window.zoomLevel" : 1,

"windows.title" : "${dirt}${activeEditorMedium}${separator}${rootName}" 


"files.exclude" : {                             # will never search in this topic 
    "**node_modules" : true
}


"""



 
#shift + alt + right
#shift + down       select one line
#shift + up
#ctrl + ?           make comment multiline after select them with shift + down 
#shift + end        select from current cursor place to end in one line
#shift + home       select from current cursor place to start in one line


def sads():
    print("sadasdasd")
    print("sadasd")



#save your custom configs in vscode account
#from side bar => accounts

#Toggle 
#switch between difference configs
#search from extensions and download and install

#File Utils
#do something about project file and folders like copy, duplicate
#and add a shortcuts key to keyboard shortcuts

#join line
# join two lines in fastest way (join all downside lines to this line)
#add manually in keyboard shortcuts (ctrl + j)

#open a project from cmd
#>>cd <project-directory>
#>>code <project-folder-name>

#switch window
#in keyboard shortcuts 
#switch window => ctrl + '

#snipped
#ctrl + shift + p => snipped

##########################################################################################################
#4K problems
##########################################################################################################
# win + r ---> registry ---> "regedit" ---> HKEY_LOCAL_MACHINE ---> software ---> microsoft ---> windows
# CurrentVersion ---> side by side ---> right click - new qword(64) ---> PreferExternalManifest
# value 0 - decimal 



##########################################################################################################
#HISTORY
##########################################################################################################
#
#The implementation of Python was started in December 1989 by Guido Van Rossum at CWI in Netherland.
#In February 1991, Guido Van Rossum published the code (labeled version 0.9.0) to alt.sources.
#In 1994, Python 1.0 was released with new features like lambda, map, filter, and reduce.
#
#in python standard is 4 space


#PEP (Python Enhancement Proposals)
#https://peps.python.org/pep-0000/#


#Convert Python2 to Python3
#download file: 2to3.py
#>>2to3 -w mycode.py

#many line of codes in one line:
#with ;
import sys; x='oo'; sys.stdout.write(x)



##########################################################################################################
#TABLE_OF_CONTENTS
##########################################################################################################
#VSCODE_SHORTCUT
#HISTORY
#KEYWORDS
#TERMINAL
#PACKAGES
#BUILT-IN_MODULES
#PIP
#MARKDOWN
#COMMENT
#PRINT
#VARIABLES
#DATA_TYPES
#TYPE_CASTING
#OPERATORS
#OPERATOR_MODULE
#STATEMENTS
#LOOP
#ITERATOR
#ITERTOOLS_MODULE
#STRING
#STRING_METHODS
#REGEX
#ARRAYS
#LIST
#LIST_METHODS
#TUPLE
#SET
#DICTIONARY
#ORDERED_DICTIONARY
#COLLECTIONS
#ARRAYS_MODULE
#FUNCTION
#FUNCTION_DECORATOR
#FUNCTOOLS_MODULE
#FUNCTION_GENERATOR
#BUILT-IN_FUNCTIONS
#MODULE
#VENV
#MATH_MODULE
#CMATH
#STATISTICS_MODULE
#RANDOM_MODULE
#UUID
#SEARCHING
#SORTING
#STACK_&_QUEUE
#DATE_&_TIME
#CLASS
#DUNDER_METHODS
#GETTER_&_SETTER
#ENUM
#META_CLASS
#CLASS_DECORATOR
#DATA_CLASS
#ATEXIT_MODULE
#PLATFORM_MODULE
#OS
#SUBPROCESS_MODULE
#MULTI_THREADING
#GLOB_MODULE
#FILE_HANDLING
#FILE_METHODS
#STUB_FILES
#CSV_FILE
#EXCEL_FILE
#PDF_FILE
#RAR_FILE
#NETWORK
#REQUESTS_MODULE
#URLLIB_MODULE
#JSON
#XML
#YAML
#EMAIL
#GMAIL_API
#WIKIPEDIA_MODULE
#CACHETOOLS_MODULE
#HASHLIB
#CURL
#NUMPY
#PYLAB
#SCIPY
#PANDAS
#OPENCV
#DATABASE
#SQLITE
#MYSQL
#POSTGRESQL
#MONGODB
#INFLUXDB
#MATPLOTLIB
#MACHINE_LEARNING
#PYSPARK
#GUI
#TKINTER
#QT
#DESKTOP_NOTIFIER
#TURTLE
#PYGAME
#EMOJI_MODULE
#AUDIO
#WEB_SCRAPING
#IMDBPY
#CHATBOT
#GRAMMAR_&_SPELL_CHECKER
#TELEGRAM_BOT
#PYROGRAM
#INSTAGRAM_BOT
#NLP
#LINTER
#PYLINT
#FLAKE
#ERROR_HANDLING
#TRACEBACK_MODULE
#TEST
#LOGGING
#TIME_COMPLEXITY
#GOOGLE
#DOCKER
#KUBERNETES
#GIT
#SOLID
#DESIGN_PATTERN
#DEVOPS
#STANDARD_CODE




##########################################################################################################
#KEYWORDS
##########################################################################################################

from msilib.schema import File


print("The list of keywords is : ") 
print(keyword.kwlist)      #--->  will print above list

#False	    await	    else    	import  	pass
#None	    break	    except	    in      	raise
#True	    class	    finally	    is	        return
#and	    continue	for	        lambda	    try
#as	        def	        from	    nonlocal	while
#assert	    del	        global	    not	        with
#async	    elif	    if	        or	        yield


#By calling help(), you can retrieve a list of currently offered keywords:
help("keywords")  


##########################################################################################################
#TERMINAL
##########################################################################################################
# >>python3                 enter to python shell
# >>python3 filename        execute your file
# >>ipython3                another type but better
# >>pylint                  standard docs
# >>pylint filename         check your file about standards
# >>pycodestyle             standard code style
# >>ctrl+l                  move the cuurent line to first line of terminal 
# exit()
# --version                 version of installed python on your system
# >>> 2 + 2                 4

# >>python3 pcode.txt           execute the code
# sudo apt install pName    install program on linux ubuntu
# sudo apt install pylint pycodestyle 

#Ctrl + l                   clear

#SHEBANG
#if you want to write your code in text file you should add this to first line of text
#this is not an address for python runner this is a contract between Operation Systems
#! /usr/bin/python3          shebang of python (for linux and windows)
#usr --->  unix system resource

#Linux Commands
"""
.                                dot
-                                dash
$                                normal user (you should be in this mode)
pwd                              print work directory
#                                root user
touch <filename>                 create a new file
> <filename>                     create a new file   
cd                               goto root
cd ~/Documents/                  goto this address
./                               current place
~                                Home Address
ls                               list of files which are in this directory
ls pcode.txt                     if return the filename it say that you have a file with this name in this directory
ls -alh                          return all things about this directory   
ls -l                            long detail in list view of directory
tree                             will show tree of directories   
rm                               remove
rm pcode.txt                     remove pcode.txt file
mv                               rename & move
mv --help                        will display help for mv command
mv pcode.txt ~/Documents/        move pcode.txt file to Documents directory
mkdir danesh                     make new directory with name danesh        (make directory also use for make packages)
file pcode.txt                   return type of file
echo $PATH                       default path for linux to search your command or file
echo hi fellas > hello.py        write "hi fellas" in hello.py
chmod                            change mod
chmod u+x Documents/pcode.txt    change mod of file to user can Execute it   
chmod u-x Documents/pcode.txt    change mod of file to user cannot Execute it  
then ./pcode.txt                 run by GNO
q                                exit from readline mod
tree venv                        display tree hierarchy of venv directory
which python3                    display python path (/usr/bin/python3)
cat                              reads data from the file and gives its content as output
less                             just read data
nano                             read and edit text file
head                             just read data
more                             just read data   
tail                             just read data
nl                               just read data with number line
xdg-open <filename>.py           open .py file in text editor 
ctrl + l                         clear terminal
htop                             task manager of linux
sudo nmcli network off           reset network   
sudo nmcli network on
sudo su -                        be root and access to linux as root
"""

#Windows Commands:
"""
dir                     like ls in linux
cd ..                   like cd in linux
cd C:\Users\Mehrdad\    like cd in linux
CHDIR                   change directory
Help
assoc
bitsadmin
call
cmd                     start a new cmd
comp                    compare
compact
Cipher
clip
Chkdsk                  check disk
chkntfs
CLS                     clear screen
cmdkey
COLOR                   change color of cmd
Copy
diskcomp                disk compare
diskcopy
Diskpart                disk partition
Doskey
Date
dir
echo
eventcreate
Erase
del 
Exit
exec
Expand
FC
Find
Format
gpfixup
gpupdate                group policy update
hostname
label
Logoff
MKDIR                   make directory
MOVE
mode
msiexec
openfiles 
PRINT
pause
pushd
popd
RD
rdpsign 
recover
RENAME
REPLACE
RMDIR                       remove directory
schtasks
secedit
SHUTDOWN
Systeminfo
takeown 
TASKKILL
TASKLIST
time
title 
tree 
typeperf 
tzutil                      windows time zone
VER                         windows version
winrs                       Windows Remote Management
PING
IPCONFIG
TRACERT
GETMAC
NSLOOKUP
NETSTAT
NETSH                       Network Shell
pathping




"""


#Rename a file (Windows)
#C:\Python311>ren hello.py hi.py     #rename from hello to hi

#Rename a file (Linux)
#>>mv index.html web_page.html              #just rename
#>>mv example.txt ~/Documents/file.txt      #rename and move
#>>mv example.txt ~/Documents/              #just move            



#Argument List (Windows)
import sys
print ('argument list', sys.argv)
name = sys.argv[1]
print ("Hello {}. How are you?".format(name))
#   C:\Python311>python hello.py Rajan
#   argument list ['hello.py', 'Rajan']
#   Hello Rajan. How are you?

import sys
print ('argument list', sys.argv)
first = int(sys.argv[1])
second = int(sys.argv[2])
print ("sum = {}".format(first+second))
#   C:\Python311>python hello.py 10 20
#   argument list ['hello.py', '10', '20']
#   sum = 30


#New Python File with Vim
#>> vim dstruct.py              #will make new file if there is not else open the last save of file 

#vim youcompleteme
#if you want to enable auto complete code in vim 
#>>vim-addons install youcompleteme   

#see all methods for your object
#>> myList. + TAB + TAB

#>>>import this
'''
اصول 19 گانه طراحی بهتر برنامه های پایتون
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
'''

#>>man python   #--->  General Commands Manual
                #      it contain synopsis
                #      for example :
                #      python [ -B ] [ -b ] [ -d ] [ -E ] [ -h ] [ -i ] [ -I ] [ -m module name] , ... 
                
                
#>>python3 -m http.server



#log files
#in linux
#>>cd /var/log/

#----------------------------
#vmware error
#VMware Workstation and Device/Credential Guard are not compatible. 
#VMware Workstation can be run after disabling Device/Credential Guard. Please visit http://www.vmware.com/go/turnoff_CG_DG for more details.
#for solve in cmd :
#bcdedit /set hypervisorlaunchtype off
#and reset system

#bcdedit /set hypervisorlaunchtype auto
#for change it back 




#about linux
'''
os (Operation System)
سیستم عامل یک مجموعه نرم افزاری است که متشکل از کرنل و هرچیزی که با کرنل کار میکند
 کرنل بخشی از سیستم عامل است که وظیفه ارتباط با سخت افزار و دادن منابع رو برعهده دارد

UNIX    -> 
GNU         -> LINUX        -> UBUNTU
MICROSOFT   -> NT           -> Windows
APPLE       -> BSD          -> Mac os
APPLE       -> Darwin       -> Mac os
APPLE       -> XNU          -> ios
Commodore   -> Amiga Exec   -> Amiga os  
--------------------------------
(os)        -> (KERNEL)     -> (DIST)


GNU/LINUX (1993)

GNU (History: 1983) (GNU ~ G Not Unix) (Mind Based: OpenSource SOftware) (micro kernel + services)
LINUX (KERNEL 1992)


in Debian:
main resource:
https://deb.debian.org/debian/

apt list python3                        will show you python3 is installed or not
apt list --installed                    will show you list of all installed programs
apt list --installed | wc -l            count of they
aptitude why zst                        why zst is installed?
apt-file show zst                       will show files of zst package
apt show zst                            will show data of zst package
apt search v2ray                    
sudo apt install python-is-python3  
sudo apt install network-manager    
man v2ray                               manual guide for v2ray
sudo systemctl status v2ray.service     will show description about tis service
sudo systemctl start v2ray.service  
sudo systemctl stop v2ray.service  
sudo systemctl restart v2ray.service  
sudo systemctl disable v2ray.service
sudo systemctl enable v2ray.service
sudo systemctl
ls -l                            long detail in list view of directory as follow:
    rw mode     user    group   size    access_date     filename   
    10    =     3-      3-
    rw mode = ----------
                     r--            - ~ other ones cant w & x
                  r--               w ~ group can write 
                  rwx               - ~ group cant execute      (>>chmod g+x calc.py    (change mod for group))
               rw-                  - ~ user cant execute or see contains
               rwx                  x ~ execution       (>>chmod u+x calc.py    (change mod to executability))  
              d                     d ~ directory   
              l                     l ~ link      
                                                        (>>chmod a+x calc.py    (change all mods to x)) 
chmod 764     ---> (0 111 110 100) ~ (- rwx rw- r--)    
chmod 754 *.py  --->  change mod of all .py files to 754  
chmod 754 calc.py dict.py                                                    
sudo usermod ali --append --groups danialbehzadi    


command vs program
----------------------------------------------------------------
bash            way to connect with os (puste)  bash script (p language of bash )
cd              Change Directory (is a bash command)
ls              a program which is active
help cd         for command we use help to see guide
man ls          for program we use man  to see guide

man mkdir

cd              go to home
cd .            go to here (right there)
cd ..           go to back directory (parent directory)
cd /            go to root in file system
pwd             show my current path address    

root            root of file system
root            
            
in unix system every thing is file
hidden files ---> files which their names start with dot(.)
ls --all        for ignore hiding when use ls  
ls *.py         list all which is ending with ".py"
ls d*           list all which is starting with 'd'
ls *p*          list all which has 'p' in middle
ls *            list all    (in ls * we will see files and directories dedicated)
ls              list all

--------------------------------------------------------------
1    2       3                      (2,3) are argument for 1
--------------------------------------------------------------
cp calc.py myfolder                 will copy "calc.py" file to "myfolder" directory    
mv calc.py myfolder                 will move "calc.py" file to "myfolder" directory
mv calc.py myfolder/newcalc.py      will move and rename "calc.py" file to "myfolder" directory   
mv calc.py newcalc.py               will rename "calc.py" file to "newcalc.py" file             



1       Standard Output (default of std output)
2       Standard Error
             
>>cat *.py 1>result 2>err           read and write std_output in "result" file and std_error in "err" file      
>>cat *.py 1>result 2>&1            read and write std_output in "result" file and std_error in std_output file                                     
>>cat *.py 2>/dev/null              /dev/null is a place like trash or recycle bin or black hole - clear it contains
>>cat /dev/zero                     always produce 0 without end
>>cat /dev/random                   always produce randoms without end

sudo apt install hollywood          its a cinematic view like hackers

'''


#install vm tools linux:
#>>sudo apt-get update
#>>sudo apt-get install open-vm-tools-desktop
#>>sudo reboot




##########################################################################################################
#PACKAGES
##########################################################################################################
#a set of modules called package
#a folder which contain many module.py files and one __init__.py file
#   *that can be empty 
#   *may contain the package list

#Define Package List:
#from .areafunctions import circle
#from .mathsfunctions import sum, power

#import package:
#import <package folder name>

#import a method from a module in a package:
#from mypkg.adv import jaz

#import a method from a module inside of package folder in other method there:
#from .calc import jaz      (. mean from directory of this file )
#from . import calc

#import with * :
#from b.second import *     (this will import all classes Except classes which their name start with _)
#from b.second import _F    (we must add these type pf classes manually)

#import from older versions of python:
try:
    from hashlib import md5         #python 3
except ImportError:
    from hashlib import new as md5  #python 2    

#__future__ :
print(8/3)  #--->  in python v2 => 2
print(8/3)  #--->  in python v3 => 2.666666
#if we have a python 2 and we want to behave like python 3
#inside of python 2 code
#from __future__ import division #we say to python 2 that use python 3
print(8/3)  #--->  2.66666


#Package Installation:
#First of all, save the following script in the parent folder, at the level of package folder.
#setup.py
from setuptools import setup
setup( name='mypackage',
version='0.1',
description='Package setup script',
url='#',
author='anonymous',
author_email='test@gmail.com',
license='MIT',
packages=['mypackage'],
zip_safe=False )


#creat a package
#In Python, module is a Python script with .py extension
#and contains objects such as classes, functions etc.
#Package is a folder containing one or more module files;
#additionally a special file "__init__.py" file which may be empty but may contain the package list.

#------------------------------------
#step-1) make required files and folders

#pakcage is a folder 
#file structure is like this:
'''
testpackage.py
example.py
setup.py
mypackage
        --->
            __init__.py
            areafunctions.py
            mathfunctions.py
'''

#------------------------------------
#step-2) write codes inside of thems
 
#save the following two Python modules in mypackage folder.
# mathfunctions.py
def sum(x,y):
   val = x+y
   return val
   
def average(x,y):
   val = (x+y)/2
   return val

def power(x,y):
   val = x**y
   return val



# areafunctions.py
def rectangle(w,h):
   area = w*h
   return area
   
def circle(r):
   import math
   area = math.pi*math.pow(r,2)
   return area


#now test the myexample package with the help of a Python script
#example.py
from mypackage.areafunctions import rectangle
print ("Area :", rectangle(10,20))

from mypackage.mathsfunctions import average
print ("average:", average(10,20))


#put the following code in the "__init__.py" file.
from .areafunctions import circle
from .mathsfunctions import sum, power

#save the following script as testpackage.py,
#testpackage.py
from mypackage import power, circle

print ("Area of circle:", circle(5))
print ("10 raised to 2:", power(10,2))

#------------------------------------
#step-3) use or install package on pc
 
#we are able to access the package resources from a script just above the package folder.
#now you can run example.py file from cmd or terminal >>python example.py

#To be able to use the package anywhere in the file system, you need to install it 
#and setup.py file should have needed codes as in up  

#how to install package :
#   internet connection must be enable - you must be online because of pip3
#   in windows first go to inside of package folder where setup.py is in with "cd" command
#   for example : cd C:\Users\Mehrdad\package_test
#   then run this : pip install .
#   it will find setup.py file automaticly and will run it

##########################################################################################################
#BUILT-IN_MODULES
##########################################################################################################
#   IMPORT Statement
import keyword     #--->  list of keywords 
import sys         #--->  System                    (getsize)
import os          #--->  provides a unified interface to a number of operating system functions.
import random      #--->  random numbers
import re          #--->  regex module - This module provides a set of powerful regular expression facilities. Regular expression (RegEx), allows powerful string search and matching for a pattern in a string
import array       #--->  array
import io
import datetime    #--->  functions to deal with dates and the time within a day. It wraps the C runtime library.
import time        #--->  This is required to include time module.
import math        #--->  mathematical operations
import cmath       #--->  mathematical operations for complex numbers.
import string      #--->  number of functions for string processing 
import gc          #--->  an interface to the built-in garbage collector
import asyncio     #--->  defines functionality required for asynchronous processing
#import Collections #--->  provides advanced Container datatypes.
#import Functools   #--->  Higher-order functions and operations on callable objects. Useful in functional programming
import operator    #--->  Functions corresponding to the standard operators.
import pickle      #--->  Convert Python objects to streams of bytes and back.
import socket      #--->  Low-level networking interface.
import sqlite3     #--->  A DB-API 2.0 implementation using SQLite 3.x.
import statistics  #--->  Mathematical statistics functions
import typing      #--->  Support for type hints
import venv        #--->  Creation of virtual environments.
import json        #--->  Encode and decode the json format.
import wsgiref     #--->  WSGI Utilities and Reference Implementation.
import unittest    #--->  Unit testing framework for Python.
import random      #--->  Generate pseudo-random numbers
import requests    #--->  Network
import pprint      #--->  pretty print 


import platform

x = platform.system()
print(x)    #--->  ???

#   Importing and also Renaming
import math as mt

#   import a special module from package
from datetime import date             #--->  for using date module in datetime package
from datetime import time             #--->  for using time module in datetime package   
from datetime import datetime         #--->  for using datetime module in datetime package    
from datetime import timedelta        #--->  for calculate duration between two dates or two time objects.  
from tkinter.tix import INTEGER       #--->  stringio


#   import some modules from package
from math     import ceil, pi
from datetime import datetime, date, time, timezone

#   see what is inside of package
dir(random)     #--->  ???
help(random)    #---> will print these content:

'''
        Help on module random:

        NAME
            random - Random variable generators.

        MODULE REFERENCE
            https://docs.python.org/3.10/library/random.html
    
            The following documentation is automatically generated from the Python
            source files.  It may be incomplete, incorrect or include features that
            are considered implementation detail and may vary between Python
            implementations.  When in doubt, consult the module reference at the
            location listed above.

        DESCRIPTION
                bytes
                -----
                    uniform bytes (values between 0 and 255)
    
                integers
                --------
                    uniform within range
    
                sequences
                ---------
                    pick random element
                    pick random sample
                    pick weighted random sample
                    generate random permutation
        :
'''
##########################################################################################################
#PIP
##########################################################################################################
#PIP is a package manager for Python packages, or modules 
#not recommended to use instead of linux pacakge manager
#A package contains all the files you need for a module.
#Modules are Python code libraries you can include in your project.


#Install PIP
#If you do not have PIP installed, you can download and install it from this page:
#  https://pypi.org/project/pip/


#Download a Package
#Navigate your command line to the location of Python's script directory, and type the following:
#in windows:
#>>C:\Users\Your Name\AppData\Local\Programs\Python\Python36-32\Scripts>pip install <packagename>
#wil give you answer from this path:
#   C:\Users\Mehrdad\AppData\Local\Programs\Python\Python312\Lib\site-packages\pip
#you can also do it from default path of cmd :
#C:\windows\system32> 
#in linux:
#>>???


#Path Of Installed Packs
#all the packages which are installed from windows saved in this path:
#C:\Users\Mehrdad\AppData\Local\Programs\Python\Python312\Lib\site-packages


#Check PIP version:
#in windows:
#C:\Users\Mehrdad\AppData\Local\Programs\Python\Python312\Scripts>pip --version
#you can also do it from default path of cmd :
#C:\windows\system32>  


#Using a Package
#Once the package is installed, it is ready to use.
#Import the "camelcase" package into your project.
#it will work because i installed it before 
import camelcase
c = camelcase.CamelCase()
txt = "hello world"
print(c.hump(txt))  #--->  Lorem Ipsum Dolor Sit Amet


#Remove a Package
#Use the uninstall command to remove a package:
#in windows:
#>pip uninstall <packagename>


#List Packages
#Use the list command to list all the packages installed on your system:
#C:\Users\Your Name\AppData\Local\Programs\Python\Python36-32\Scripts>pip list
#result is like this:
'''
Package         Version
-----------------------
camelcase       0.2
mysql-connector 2.1.6
pip             18.1
pymongo         3.6.1
setuptools      39.0.1
distlib      0.3.7
filelock     3.13.1
mypackage    0.1
platformdirs 3.11.0
virtualenv   20.24.6
'''





##########################################################################################################
#MARKDOWN
##########################################################################################################
#.md file automa

#https://www.mongard.ir/one_part/42/markdown/
#https://www.mongard.ir/one_part/145/python-markdown/
#???

##########################################################################################################
#COMMENT
##########################################################################################################
#the most common uses for comments:

    #Readability of the Code
    #Restrict code execution
    #Provide an overview of the program or project metadata
    #To add resources to the code

#1-Single-Line Comments

    #dfsdffesawad 51516 wadad4

#2-Multi-Line Comments

    #Python does not provide the facility for multi-line comments.
    #However, there are indeed many ways to create multi-line comments.

"""
This is a comment
written in
more than just one line
cannot place with space from start of line
"""



#3-Using String Literals

'it is a comment extending to single lines'  
'but it should be in col:01 of line in start of line'
'could not had a space in start'
'       but you can do this instead of start from first column'

"This function adds the values of x and y" 
#""This function adds the values of x and y""        two quotation had error 
"""This function adds the values of x and y"""  

'''''
dsadsad
sadsadasdsadsa
sadasdsasdasadsadsad
asdsadsa
adsdsasda
'''''


##########################################################################################################
#PRINT
##########################################################################################################
print("Hello, world!")      # in python3,2
print()   #--->  print(\n)
#print "Hello, world!"       # in python2 (syntaxerror)

myNumber = 3
print(myNumber)
myNumber2 = 4.5
print(myNumber2) 


x = "Python "
y = "is "
z = "awesome"
print(x, y, z)     #--->  Python  is  awesome
print(x + y + z)   #--->  Python is awesome
#print x            #--->  syntax error
print(x, end="###")  #--->  Python ###

x = 5
y = 10
print(x + y)   #--->  15

x = 5
y = "John"
print(x + y)   #--->  TypeError: unsupported operand type(s) for +: 'int' and 'str'

x = 5
y = "John"
print(x, y)   #--->  5 John

#----------------------------------------------
#INPUT
#Python always read the user input as a string.
name = input()
name = input("Enter your name: ")   
print("hello", name)

#name = raw_input("Eneter your name - ")      this function was available in Python 2.7

#Numeric Input
w = input("Enter width : ")
width = int(w)

amount = float(input("Enter Amount : "))

# input numbers in static list
l =[]     
n = int(input("Enter the number of elements in the list:"))   #--->  size of list  
for i in range(0,n):        
    l.append(input("Enter the item:"))                        #--->  add values to list

# input numbers in dynamic list
#way-1
L1 = []
print("Enter a compilation of numbers:")
while True :
    x = input(" " , end = ' ')
    if x == ' ' :
        break
    else :
        L1.append(int(x))

#way-2
input_string = input('Enter elements of a list separated by space \n')
user_list = input_string.split()
print('string list: ', user_list)   #--->  ['5', '10', '15', '20', '25', '30']
for i in range(len(user_list)):
    user_list[i] = int(user_list[i])
print('User list: ', user_list)     #--->  [5, 10, 15, 20, 25, 30]

#way-3
list = input("Enter elements: ").split()
print("List: ", list)

#way-4
try: 
    list = []
    print("Enter elements: ")
    while True:
        x = int(input())
        list.append(x)
except:
    print("List: ", list)

#way-5
usernum = raw_input("Enter number:")
print(usernum)

# input multiple values
nums = input("enter two numbers: ")
num1 , num2 = nums.split()
#or
num1 , num2 = input("enter two numbers: ").split()


inputprice   = input(f"enter #{inputcounter} laptop price:   " , end = ' ' ) #TypeError: input() takes no keyword arguments





#------------------------------------------------
#GETPASS
#Prtable Password Input

import getpass

print(getpass.getuser())    #this func check environment variables : logname - user - lname - username
                            #check in order and get first which is non empty
#--->  mehrdad (from wos local variables)

#get input from terminal
username = input("Enter username: ")
password = getpass.getpass("Enter password:")   #password will be hidden when you entering

getpass.GetPassWarning()

#way-2 (better)
#after install stdiomask
import stdiomask
x = stdiomask.getpass(prompt = "insert password...")
print(x)

#------------------------------------------------


var1='Welcome to "Python Tutorial" from TutorialsPoint'
print (var1)
var2="Welcome to 'Python Tutorial' from TutorialsPoint"
print (var2)


city="Hyderabad"
state="Telangana"
country="India"
print(city, state, country)            #--->  Hyderabad Telangana India
print(city, state, country, sep=',')   #--->  Hyderabad,Telangana,India

city="Hyderabad"
state="Telangana"
country="India"
print("City:", city, end=" ")      
print("State:", state)             #--->  City: Hyderabad State: Telangana 

#The print() function issues a newline character ('\n') at the end, by default.
city="Hyderabad"
state="Telangana"
print("City:", city)
print("State:", state)

#--->  City: Hyderabad
#--->  State: Telangana


for i in range(1,11):
   for j in range(1,11):
      k=i*j
      print ("{:3d}".format(k), end=' ')   #--->    1   2   3   4   5   6   7   8   9  10   2   4   6   8  10  12  14  16  18  20   3   6   9  12  15  18  21  24  27  30   4   8  12  16  20  24  28  32  36  40   5  10  15  20  25  30  35  40  45  50   6  12  18  24  30  36  42  48  54  60   7  14  21  28  35  42  49  56  63  70   8  16  24  32  40  48  56  64  72  80   9  18  27  36  45  54  63  72  81  90  10  20  30  40  50  60  70  80  90 100 


count=0
while count<5:
   count+=1
   print ("Iteration no. {}".format(count))   #--->  Iteration no. 1
                                              #      Iteration no. 2
                                              #      Iteration no. 3
                                              #      Iteration no. 4
                                              #      Iteration no. 5

a = {1 , 2 , 3}
print(a)   #--->  1
           #      2
           #      3
print(a,end=' ')            #--->  1 2 3
print(a,sep='*',end=' ')    #--->  1*2*3
print(a,sep='*',end=' ',flush=False)    #--->  if you want to print real time



#comprehension
colors = ["red", "blue", "white"]
print(f"colors are : {[color for color in colors]}")



#PPRINT
#pretty print (pprint) 
#pprint vs print
import requests 
def geocode(address): 
    url = "https://maps.googleapis.com/maps/api/geocode/json"
    resp = requests.get(url, params = {'address': address}) 
    return resp.json() 
data = geocode('India gate') 
print(data) 
'''
{'status': 'OK', 'results': [{'address_components': [{'long_name': 'Rajpath', 'types': ['route'], 
'short_name': 'Rajpath'}, {'long_name': 'India Gate', 'types': ['political', 'sublocality', 
'sublocality_level_1'], 'short_name': 'India Gate'}, {'long_name': 'New Delhi', 'types': 
['locality', 'political'], 'short_name': 'New Delhi'}, {'long_name': 
'India', 'types': ['country', 'political'], 'short_name': 'IN'}, {'long_name': '110001', 'types': 
['postal_code'], 'short_name': '110001'}], 'geometry': {'location': {'lng': 77.2295097, 'lat': 28.612912}, 
'viewport': {'northeast': {'lng': 77.2308586802915, 'lat': 28.6142609802915}, 'southwest': {'lng': 
77.22816071970848, 'lat': 28.6115630197085}}, 'location_type': 'APPROXIMATE'}, 'types': 
['establishment', 'point_of_interest'], 'formatted_address': 'Rajpath, India Gate, New Delhi, Delhi 110001, 
India', 'place_id': 'ChIJC03rqdriDDkRXT6SJRGXFwc'}]}
'''

pprint(data)
'''
{'results': [{'address_components': [{'long_name': 'Rajpath',
                                      'short_name': 'Rajpath',
                                      'types': ['route']},
                                     {'long_name': 'India Gate',
                                      'short_name': 'India Gate',
                                      'types': ['political',
                                                'sublocality',
                                                'sublocality_level_1']},
                                     {'long_name': 'India',
                                      'short_name': 'IN',
                                      'types': ['country', 'political']},
                                     {'long_name': '110001',
                                      'short_name': '110001',
                                      'types': ['postal_code']}],
              'formatted_address': 'Rajpath, India Gate, New Delhi, Delhi '
                                   '110001, India',
              'geometry': {'location': {'lat': 28.612912, 'lng': 77.2295097},
                           'location_type': 'APPROXIMATE',
                           'viewport': {'northeast': {'lat': 28.6142609802915,
                                                      'lng': 77.2308586802915},
                                        'southwest': {'lat': 28.6115630197085,
                                                      'lng': 77.22816071970848}}},
              'place_id': 'ChIJC03rqdriDDkRXT6SJRGXFwc',
              'types': ['establishment', 'point_of_interest']}],
 'status': 'OK'}
'''



##########################################################################################################
#VARIABLES
##########################################################################################################
#Every object created in Python has a unique identifier.
a = 50  
b = a  
print(id(a))     #--->  140734982691168  
print(id(b))     #--->  140734982691168  

a = 500  
print(id(a))     #--->  2822056960944  
del a            #--->  Deleting a variable

#Dynamic Typing
#The compiler-based languages C/C++, Java, etc. are statically typed
#In a statically typed language, each variable and its data type must be declared before assigning it a value
'''
#in java it is an error
int var;
var="Hello";        error: incompatible types: String cannot be converted to int
'''
#but is python no problem
var = "Hello"
var = 25.50
var = (10,20,30)
#A variable in Python is only a label, or reference to the object stored in the memory, and not a named memory
#location. Hence, the prior declaration of type is not needed. Because it's just a label, it can be put on another
#object, which may be of any type.
#just will be stored with a different id()




# multiple assign
x=y=z=50                                    # One Value to Multiple Variables
x, y, z = "Orange", "Banana", "Cherry"      # Many Values to Multiple Variables

fruits = ["apple", "banana", "cherry"]
x, y, z = fruits                            # Unpack a Collection

x, y, z = 1, 2.5, "john"

var='0'
if var.isnumeric()==True:           #---> control type of data
    print ("Your input", var)   



#Local vs Nonlocal
x = 300
def myfunc():
    x = 200
    print(x)
myfunc()   #--->  200 
print(x)   #--->  300


def the_outer_function():  
    var = 10  
    def the_inner_function():  
        nonlocal var  
        var = 14  
        print("The value inside the inner function: ", var)     #--->  The value inside the inner function:  14
    the_inner_function()  
    print("The value inside the outer function: ", var)     #--->  The value inside the outer function:  14  
  
the_outer_function()  


#Scope
#A variable is only available from inside the region it is created. This is called scope.


def the_outer_function():  
    var = 10  
    def the_inner_function():  
        var = 14  
        print("Value inside the inner function: ", var)     #--->  Value inside the inner function:  14   
    the_inner_function()  
    print("Value inside the outer function: ", var)     #--->  Value inside the outer function:  10  
  
the_outer_function()  



# Variable Names

a = 5
Adddsf = 8
_asdad = 6
__dsadsad = 9
___ewre = 8
__dsada__sadad = 9
_Afdsfsd = 0
dfsefe_ = 7
ARF____ = 99
my_var = 99
my___root = 89
myvar2 = 90
# 09dsda = 5           Error-cannot start with Numbers(0-9)
# $fdsdf = 9           Error-cannot start with any symbol



# Multi Words Variable Names

# 1- Camel Case
myVariableName = "John"

# 2- Pascal Case
MyVariableName = "John"

# 3- Snake Case
my_variable_name = "John"




#Global Variables
x = "awesome"
def myfunc():
  x = "fantastic"
  print("Python is " + x)   #--->  Python is fantastic
myfunc()
print("Python is " + x)     #--->  Python is awesome

print(globals())   #--->  {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x7f6af5f22dc0>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, '__file__': 'main.py', '__cached__': None, 'x': 'awesome', 'myfunc': <function myfunc at 0x7f6af5e51d30>}
print(locals())    #--->  {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x7f6af5f22dc0>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, '__file__': 'main.py', '__cached__': None, 'x': 'awesome', 'myfunc': <function myfunc at 0x7f6af5e51d30>}

#If you use the global keyword, the variable belongs to the global scope:
def myfunc():
  global x
  x = "fantastic"
myfunc()
print("Python is " + x)   #--->  Python is fantastic

#Also, use the global keyword if you want to change a global variable inside a function.
x = "awesome"
def myfunc():
  global x
  x = "fantastic"
myfunc()
print("Python is " + x)   #--->  Python is fantastic


#we use ' ' in case of characters & keywerds  ('h' or 'city' )
#we use " " in case of Strings                ("Mehrdad Abdi")

##########################################################################################################
#DATA_TYPES
##########################################################################################################
#Python has the following data types built-in by default, in these categories:

# Text Type:	    str
# Numeric Types:	int, float, complex
# Sequence Types:	list, tuple, range
# Mapping Type:	    dict (Dictionary)
# Set Types:	    set, frozenset
# Boolean Type:	    bool (Boolean)
# Binary Types:	    bytes, bytearray, memoryview
# None Type:	    NoneType



#auto detect
name = "Devansh"                                #String  
age = 20                                        #Int
marks = 80.50                                   #Float
cmplx = 1+3j                                    #Complex
x = True	                                    #bool
x = ["apple", "banana", "cherry"]	            #list
x = ("apple", "banana", "cherry")	            #tuple
x = range(6)	                                #range
x = {"name" : "John", "age" : 36}	            #dict
x = {"apple", "banana", "cherry"}	            #set
x = frozenset({"apple", "banana", "cherry"})	#frozenset
x = b"Hello"                                	#bytes
x = bytearray(5)	                            #bytearray
x = memoryview(bytes(5))	                    #memoryview
x = None	                                    #NoneType

#manual detect
x = str("Hello World")	                        #str
x = int(20)	                                    #int
x = float(20.5)	                                #float
x = complex(1j)	                                #complex
x = bool(5)	                                    #bool
x = list(("apple", "banana", "cherry"))	        #list
x = tuple(("apple", "banana", "cherry"))	    #tuple
x = range(6)	                                #range
x = dict(name="John", age=36)	                #dict	
x = set(("apple", "banana", "cherry"))	        #set
x = frozenset(("apple", "banana", "cherry"))	#frozenset
x = bytes(5)	                                #bytes
x = bytearray(5)	                            #bytearray
x = memoryview(bytes(5))	                    #memoryview


print(type(name))     #--->  <type 'int'>  
print(type(age))      #--->  <type 'str'>
print(type(marks))    #--->  <type 'float'>
print(type(cmplx))    #--->  <type 'complex'>


#isinstance()
isinstance(5, int)            #--->  True
isinstance(2, str)            #--->  False
isinstance(True,int)          #--->  True
isinstance(1,bool)            #--->  False
isinstance(2.6,int)           #--->  False
isinstance([1,2],list)        #--->  True
isinstance([1,2],(int,list))  #--->  True
print(" cmplx is a complex number", isinstance(1+3j,complex))     #--->  c is complex number: True  



v = 'hello'             #String Literal in single quotes
v = "hello"             #String Literal in double quotes
v = '''hello'''         #String Literal in triple quotes
v = """hello"""         #String Literal in triple quotes
x = 2+3j                #Complex Literal
y = 2.5+4.6j            #Complex Literal
x = 0b10100             #Binary Literals  
y = 100                 #Decimal Literal   
z = 0o215               #Octal Literal
x = 0O34                #Octal Literal  
u = 0x12d               #Hexadecimal Literal  




# Unicode System

var = "\u00BE"
print (var)   #--->  3/4

var = "\u0031\u0030"
print (var)   #--->  10

string = "Hello"
tobytes = string.encode('utf-8')
print (tobytes)             #--->  b'Hello'

string = tobytes.decode('utf-8')
print (string)              #--->  Hello


#encode & decode
string = "\u20B9"
print (string)      #--->  ₹

tobytes = string.encode('utf-8')
print (tobytes)     #--->  b'\xe2\x82\xb9'

string = tobytes.decode('utf-8')
print (string)      #--->  ₹









##########################################################################################################
#TYPE_CASTING
##########################################################################################################

# float to int
a = int(10.5)   #--->  10

# boolean to int
a=int(True)   #--->  1

# binary, octal and hexa-decimal string to int
a = int("110011", 2)   #--->  52                     2 is base
a = int("20", 8)       #--->  16  (0*8**0 + 2*8**1)  8 is base
a = int("2A9", 16)     #--->  681

# binary String to Integer
a = int("110011", 2)   #--->  51

# octal String to Integer
a = int("20", 8)   #--->  16

# hexa-Decimal String to Integer
a = int("2A9", 16)   #--->  681
 
# string to int
c = int("3")            #--->  3
a = int("10"+"01")      #--->  1001 
a = int("10.5")         #--->  Error-invalid literal for int() with base 10
a = int("Hello World")  #--->  Error-invalid literal for int() with base 10:
#strtoint("Hello World")



# int to float
a = float(100)   #--->  100.0

# scientific notation to float 
a = float("1.00E4")   #--->  10000.0
a = float("1.00E-4")  #--->  0.0001

# string to float
c = float("3.3") # c will be 3.3
a = float("1,234.50")   #--->  Error-could not convert string to float

# bool to float
a = float(False)   #--->  0.0
b = float(True)    #--->  1.0




# int to complex:
c = complex(x)

# bool to complex
a = float(False)   #--->  (1+0j)



# int to binary
a = bin(6)      #--->  0b110
# int to hex
a = hex(6)
# int to oct
a = oct(6)


# int to string
a = str(10)   #--->  "10"
# int to char
a = chr(10)  #--->  will print character of this ascii code


# float to string
a = str(11.10)   #--->  "11.10"
a = str(2/5)    #--->  '0.4'

# scientific notations to string
a = str(10E4)   #--->  '100000.0'
a=str(1.23e-4)  #--->  '0.000123'

# list/tuple to string
a=str('True')   #--->  'True'
a=str([1,2,3])  #--->  '[1, 2, 3]'
a=str((1,2,3))  #--->  '(1, 2, 3)'
a=str({1:100, 2:200, 3:300})  #--->  '{1: 100, 2: 200, 3: 300}'
listedVal = ['a','s','d','a','s','d','a','d','a','s','d']
s1 = "".join(listedVal)     #--->  "asdasdadasd"  

# ascii to string
a = chr(105)


# string to list
c="Hello" 
obj=list(c)   #--->  ['H', 'e', 'l', 'l', 'o']

# tuple to list
b=(1,2,3,4,5)
obj=list(b)   #--->  [1, 2, 3, 4, 5]





# string to tuple
c="Hello" 
obj=tuple(c)   #--->  ('H', 'e', 'l', 'l', 'o')

# list to tuple
a=[1,2,3,4,5]
obj=tuple(a)   #--->  (1, 2, 3, 4, 5)




# list to set
L1 = ["Rohan", "Physics", 21, 69.75]
s1 = set(L1)        #--->  {'Rohan', 69.75, 21, 'Physics'}

# tuple to set
T1 = (1, 2, 3, 4, 5)
s2 = set(T1)        #--->  {1, 2, 3, 4, 5}

# string to set
string = "TutorialsPoint"
s3 = set(string)    #--->  {'u', 'a', 'o', 'n', 'r', 's', 'T', 'P', 'i', 't', 'l'}

# string to frozenset
s4 = frozenset(s)

#Data Type Conversion Functions
'''''
int(x [,base])          Converts x to an integer. base specifies the base if x is a string.
long(x [,base] )        Converts x to a long integer. base specifies the base if x is a string.
float(x)                Converts x to a floating-point number.
complex(real [,imag])   Creates a complex number.	
str(x)                  Converts object x to a string representation.	
repr(x)                 Converts object x to an expression string.	
eval(str)               Evaluates a string and returns an object.	
tuple(s)                Converts s to a tuple.
list(s)                 Converts s to a list.	
set(s)                  Converts s to a set.	
dict(d)                 Creates a dictionary. d must be a sequence of (key,value) tuples.
frozenset(s)            Converts s to a frozen set.
chr(x)                  Converts an integer to a character.
unichr(x)               Converts an integer to a Unicode character.
ord(x)                  Converts a single character to its integer value.
hex(x)                  Converts an integer to a hexadecimal string.	
oct(x)                  Converts an integer to an octal string.
'''''


##########################################################################################################
#OPERATORS
##########################################################################################################
#1-Logical
True or False     #--->  True
True and False    #--->  False
not False         #--->  True

a = 5 

#       and         ( a < 5 ) and ( a == 5 )   False 	 
#       or	        ( a < 5 ) or  ( a == 5 )   True
#       not         not ( a ==5 )              False

#Equals:                    a == b
#Not Equals:                a != b
#Less than:                 a < b
#Less than or equal to:     a <= b
#Greater than:              a > b
#Greater than or equal to:  a >= b

print( 4 == 4 )         #--->  True
print( 6 > 9 )          #--->  False
print( 9 <= 28 )        #--->  True
print( 6 > 9 )          #--->  False

print( True == 0 )             #--->  False
print( True == 1 )             #--->  True     
print( True == 2 )             #--->  False
print( True == 3 )             #--->  False
print( True + 10 )             #--->  11
print( False == 0 )            #--->  True
print( False == 1 )            #--->  False
print( False == 2 )            #--->  False
print( False == 3 )            #--->  False
print( False + 10 )            #--->  10
print( True and False )        #--->  False
print( True + True + True)     #--->  3  


print( None == 0 )         #--->  False
print( None == " " )       #--->  False
print( None == False )     #--->  False
A = None   
B = None  
print( A == B )            #--->  True

a = True
print(not a)   #--->  False


print( [] == [] )         #--->  True
print( [] is [] )         #--->  False
print( {} == {} )         #--->  True
print( {} is {} )         #--->  False
print( '' == '' )         #--->  True
print( '' is '' )         #--->  True

print(bool(None))       #--->  False
print(bool(""))         #--->  False
print(bool(()))         #--->  False
print(bool([]))         #--->  False
print(bool({}))         #--->  False
print(bool("abc"))      #--->  True
print(bool(123))        #--->  True
print(bool(["apple", "cherry", "banana"]))      #--->  True

 
 
 
 
#2-Arithmetic Operators

#       + (Addition)
#       - (Subtraction)
#       * (Multiplication)
#       % (reminder)(Modulus)    returns the reminder after dividing
#       ** (Exponent)            power
#       / (divide)               32 / 6  ==  5.333333333333333
#       // (Floor division)      32 // 6 ==  5  (for both float and integer numbers)



#3-Comparison operator

#       ==       equal
#       !=       not equal
#       <=       smaller or equal
#       >=       greater or equal
#       >        greater
#       <        smaller


#4-Assignment Operators

#       =       a = 5
#       +=      a += b  ( a = a + b )
#       -=      a -= b  ( a = a - b )
#       *=      a *= b  ( a = a * b )
#       %=      a %= b  ( a = a % b )
#       **=     a **= b ( a = a ** b )
#       //=     a //= b ( a = a // b )
#       &=	    a &= 5	( a = a & 5 )
#       |=	    a |= 5	( a = a | 5 )
#       ^=	    a ^= 5	( a = a ^ 5 )  (a = a XOR 5)
#       >>=	    a >>= 5	( a = a >> 5 )
#       <<=	    a <<= 5	( a = a << 5 )


#5-Bitwise Operators

#       & (binary and)      a & b = 0110        
#       | (binary or)       a | b = 0111
#       ^ (binary xor)      a ^ b = 0100   
#       ~ (negation)        ~ a = 1000
#       << (left shift)     
#       >> (right shift)    

print(bin(a<<2))    #--->  0b11100
print(bin(a>>2))    #--->  0b1

a = 7       #   binary (a) = 0111      
b = 6       #   binary (b) = 0110    
c = 5       #   Binary of c = 0101 
       
#       0 & 0 is 0                  0 | 0 is 0                  0 ^ 0 is 0
#       1 & 0 is 0                  0 | 1 is 1                  0 ^ 1 is 1
#       0 & 1 is 0                  1 | 0 is 1                  1 ^ 0 is 1
#       1 & 1 is 1                  1 | 1 is 1                  1 ^ 1 is 0
   

a=60
b=13
print ("a:",a, "b:",b, "a&b:",a&b)   #--->  a: 60 b: 13 a&b: 12 
print ("a:", bin(a))   #--->  a: 0b111100
print ("b:", bin(b))   #--->  b: 0b1101

#   0011 1100                   0011 1100                   0011 1100
#   &                           |                           ^
#   0000 1101                   0000 1101                   0000 1101
#   -------------               -------------               -------------
#   0000 1100                   0011 1101                   0011 0001

a=60
print ("a:",a, "~a:", ~a)       #--->  a: 60 ~a: -61

#       0011 1100   <<  2               0011 1100   >>  2 
#       -------------                   -------------
#       1111 0000                       0000 1111


   
   
    







    






#6-Membership Operators
#used in this data types(list, tuple, or dictionary).

#in	        If the first operand found in the second operand, it is evaluated to be true 
#not in

x = ["Rose", "Lotus"]  
print(' Is value Present?', "Rose" in x)            #--->  True
print(' Is value not Present?', "Riya" not in x)    #--->  True



var = "TutorialsPoint"
a = "P"
b = "tor"
c = "in"
d = "To"

print (a in var)          #--->  True
print (b not in var)      #--->  False
print (c in var)          #--->  True
print (d not in var)      #--->  True



var = [10,20,30,40]
a = 20
b = 10
c = a-b
d = a/2
print (a in var)             #--->  True
print (b not in var)         #--->  False
print (c in var)             #--->  True
print (d not in var)         #--->  False
print (0x14 in var)          #--->  True            
print (int(0x14))            #--->  20



v1 = (10,20,30,40)
a = 10
b = 20
print ((a,b) in var)        #--->  False

var = ((10,20),30,40)
a = 10
b = 20
print ((a,b) in var)        #--->  True



var = {1:10, 2:20, 3:30}
a = 2
b = 20
print (a in var)    #--->  True
print (b in var)    #--->  False         var = {[1:10) , [2:20) , [3:30)}







#7-Identity Operators

#is	            If the references on both sides point to the same object, it is determined to be true.
#is not

a = ["Rose", "Lotus"]  
b = ["Rose", "Lotus"]  
c = a  

print(a is c)           #--->  True
print(a is not c)       #--->  False
print(a is b)           #--->  False
print(a is not b)       #--->  True
print(a == b)           #--->  True
print(a != b)           #--->  False


a="TutorialsPoint"
b=a
print (id(a), id(b))        #--->  2739311598832 2739311598832
print (a is b)              #--->  True
print (b is not a)          #--->  False


a=[1,2,3]
b=[1,2,3]
print (id(a), id(b))        #--->  1552612704640 1552567805568
print (a is b)              #--->  False
print (b is not a)          #--->  True


#8-Systematic Operators
mylist = [1,2,3,4,5,6,7,8,9,10]
sys.getsizeof(mylist)       #--->  5000 Byte (5KB) in Memory (RAM)
sys.getsizeof(range(11))    #--->    48 Byte  



#8-Mathematical Operators

#AND, ∧
#OR, ∨
#NOT, ¬
#CONTAINS, ∈
#IDENTITY


x = 10
y = 20
z = 0
print("x and y:",x and y)   #--->  20
print("x or y:",x or y)     #--->  10
print("z or x:",z or x)     #--->  10
print("y or z:", y or z)    #--->  20

a="Hello"
b=tuple()
print("a and b:",a and b)   #--->  ()
print("b or a:",b or a)     #--->  hello

x=[1,2,3]
y=[10,20,30]
print("x and y:",x and y)   #--->  [10, 20, 30]
print("x or y:",x or y)     #--->  [1, 2, 3]

#random number
import random
print(random.randrange(1, 10))   #--->  will produce random integers between 1 and 9
x = random.randint(0, 100)       #--->  will produce random integers between 0 and 99
print(random.random())           #--->  will produce random float    between 0 and 1   

#round
round(99.22)        #--->  99       It returns x rounded to n digits from the decimal point.
round(10.8)         #--->  11  
round(6.6)          #--->  7

#abs()      returns the absolute value of x, i.e. the positive distance between x and zero. (قدرمطلق)
abs(99.22)           #--->  99.22
abs(-99.22)          #--->  99.22

#power 
#computes the square root of a number It is equivalent to x**y.
pow(100, 0.5)   #--->  10       

#max()      returns the largest of its arguments or largest number from the iterable (list or tuple).
max(2,3,4)      #--->  4

#min()      returns the smallest of its arguments 
min(2,3,4)      #--->  2 
 
#sum()      returns the sum of all numeric items in any iterable (list or tuple).
sum(2,3,4)      #--->  9

#divmod()   is used to get remainder and quotient of two numbers.
result = divmod(10,2)  
print(result)  #--->  (5, 0)




#9-Operators Precedence (olaviyat bandi)

#1	  (),[], {}                   Parentheses and braces
#2	  [index], [index:index]      Subscription, slicing,
#3	  await x                     Await expression
#4	  **                          Exponentiation
#5	  +x, -x, ~x                  Positive, negative, bitwise NOT
#6	  *, @, /, //, %              Multiplication, matrix multiplication, division, floor division, remainder
#7	  +, -                        Addition and subtraction
#8	  <<, >>                      Left Shifts, Right Shifts
#9	  &                           Bitwise AND
#10	  ^                           Bitwise XOR
#11   |                           Bitwise OR
#12   in, not in, is, is not, <, <=, >, >=, !=, ==         Comparisons, including membership tests and identity tests
#13   not x                       Boolean NOT
#14   and                         Boolean AND
#15   or                          Boolean OR
#16   if – else                   Conditional expression
#17   lambda                      Lambda expression
#18   :=                          Walrus operator


#10-WALRUS
#walrus ( := ) (assign + return)
    
print(name := "amir")   #--->  amir

if (walrus := (len(name))) > 4:
    print("Error")


#example-1
#way-1
inputs = list()
current = input("Write something: ")
while current != "quit":
    inputs.append(current)
    current = input("Write something: ")


#way-2
inputs = list()
while (current := input("Enter a number: ")) != 'quit':
    inputs.append(current)




##########################################################################################################
#OPERATOR_MODULE
##########################################################################################################

import operator 
from functools import reduce

nums = [4, 6, 7, 2, 8, 9]

print(reduce(operator.add, nums))
























##########################################################################################################
#STATEMENTS
##########################################################################################################
# If 
num = 4
if num % 2 == 0 :       
    print("The Given number is an even number")

if a > b and c > a:
    print("Both conditions are True")
      
if a > b or a > c:
    print("At least one of the conditions is True")

if not a > b:
    print("a is NOT greater than b")
      
# If - else 
age = 17
if age >= 18 :      
    print("You are eligible to vote !!");    
else:    
    print("Sorry! you have to wait !!");    
    
#comprehension    
a = 2
b = 330   
print("A") if a > b else print("B")     #--->  B 
a = 330
b = 330
print("A") if a > b else print("==") if a == b else print("B")   #--->  ==


# elif
number = 11
if number==10:    
    print("The given number is equals to 10")    
elif number==50:  
    print("The given number is equal to 50");    
elif number==100:    
    print("The given number is equal to 100");    
else:    
    print("The given number is not equal to 10, 50 or 100");    


# Nested if
a = 10
if a > 5:
    if a < 21:
        if a+1 == 10:
            print("this is nine")


amount = 2500
print('Amount = ',amount)
if amount > 10000:
   discount = amount * 20 / 100
else:
   if amount > 5000:
      discount = amount * 10 / 100
   else:
      if amount > 1000:
         discount = amount * 5 / 100
      else:
         discount = 0


num=8
print ("num = ",num)
if num%2==0:
   if num%3==0:
      print ("Divisible by 3 and 2")
   else:
      print ("divisible by 2 not divisible by 3")
else:
   if num%3==0:
      print ("divisible by 3 not divisible by 2")
   else:
      print ("not Divisible by 2 not divisible by 3")            



# match case
#switch #switchcase #switch case
#example 1
def checkVowel(n):
   match n:
      case 'a': return "Vowel alphabet"
      case 'e': return "Vowel alphabet"
      case 'i': return "Vowel alphabet"
      case 'o': return "Vowel alphabet"
      case 'u': return "Vowel alphabet"
      case _: return "Simple alphabet"
print (checkVowel('a'))         #--->  Vowel alphabet
print (checkVowel('m'))         #--->  Simple alphabet
print (checkVowel('o'))         #--->  Vowel alphabet

#example 2
def weekday(n):
   match n:
      case 0: return "Monday"
      case 1: return "Tuesday"
      case 2: return "Wednesday"
      case 3: return "Thursday"
      case 4: return "Friday"
      case 5: return "Saturday"
      case 6: return "Sunday"
      case _: return "Invalid day number"
print (weekday(3))      #--->  Thursday
print (weekday(6))      #--->  Sunday
print (weekday(7))      #--->  Invalid day number

#example 3
def access(user):
   match user:
      case "admin" | "manager": return "Full access"
      case "Guest":             return "Limited access"
      case _:                    return "No access"
print (access("manager"))      #--->  Full access
print (access("Guest"))        #--->  Limited access
print (access("Ravi"))         #--->  No access

#example 4
def greeting(details):
   match details:
      case [time, name]:
         return f'Good {time} {name}!'
      case [time, *names]:
         msg=''
         for name in names:
            msg+=f'Good {time} {name}!\n'
         return msg

print (greeting(["Morning", "Ravi"]))                       #--->  Good Morning Ravi!
print (greeting(["Afternoon","Guest"]))                     #--->  Good Afternoon Guest!

print (greeting(["Evening", "Kajal", "Praveen", "Lata"]))   #--->  Good Evening Kajal!
                                                            #--->  Good Evening Praveen!
                                                            #--->  Good Evening Lata!



#example 5
def intr(details):
   match details:
      case [amt, duration] if amt<10000:
         return amt*10*duration/100
      case [amt, duration] if amt>=10000:
         return amt*15*duration/100
print ("Interest = ", intr([5000,5]))           #--->  Interest = 2500.0
print ("Interest = ", intr([15000,3]))          #--->  Interest = 6750.0




##########################################################################################################
#LOOP
##########################################################################################################
#simple for
#for(int i = 0 , i< 10 , i++) in c++
#                             in python with range
for i in range(10) :
    print(i)


# for used to string
string1 = "Python Loop"  
for s in string1:   
    if s == "o":  
        print("$")  
    else:  
        print(s)  
    #--->  Pyth$n L$$p

# for used to array
words = ["one", "two", "three"]
for x in words:
  print(x)          #--->  one two three


# for used to list
list1 = [1, 2, 3, 4, 5]  
for num in list1:  
    print(num)  
    if num == 4:  
       break  

list = [22 , "ali is coming!" , 45 , 0 , 'negah']
for iter in list :
    if type(iter) is int:
        print(iter)

colors = ["red","blue","yellow","orange","brown"]
for color in colors :
    if color not in ["red","blue"] : 
        print(color)

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  
sq_num = [num ** 2 for num in numbers if num % 2 == 0]  
print(sq_num)   #--->  [4, 16, 36, 64, 100]  


# for used to tuple
tuple_ = (3, 4, 6, 8, 9, 2, 3, 8, 9, 7)  
for value in tuple_:  
    if value % 2 != 0:  
        print(value)   
    else:  
        print("odd!")  
    #--->  3 odd! odd! odd! 9 odd! 3 odd! 9 7


# for used to dictionary
numbers = {10:"Ten", 20:"Twenty", 30:"Thirty",40:"Forty"}
for x in numbers:
   print (x)              #--->  10 20 30 40
   print (numbers[x])     #--->  Ten Twenty Thirty Forty 

for x in numbers.items():
   print (x)              #--->  (10, 'Ten')
                          #      (20, 'Twenty')
                          #      (30, 'Thirty')
                          #      (40, 'Forty')

for x,y in numbers.items():
   print (x, y)         #--->  10 Ten
                        #      20 Twenty
                        #      30 Thirty
                        #      40 Forty

for x in numbers.keys():
   print (x, ":", numbers[x])   #--->  10 : Ten
                                #      20 : Twenty
                                #      30 : Thirty
                                #      40 : Forty
   

# for with continue
#continue takes the control back to the start of the loop.
#continue cause to go to next iteration of the loop
for iterator in range(10, 21):  
    # If iterator is equals to 15, loop will continue to the next iteration  
    if iterator == 15:  
        continue  
    # otherwise printing the value of iterator  
    print( iterator )  
    #--->  10 11 12 13 14 16 17 18 19 20



#for with break
for i in range(10): 
    print(i, end=" ")     #--->  0 1 2 3 4 5 6   
    if i == 6:    # break the loop as soon it sees 6 
        break

for string in "Python Loops":  
    if string == 'L':  
         break  
    print('Current Letter: ', string)  
    #--->  Current Letter:  P
    #      Current Letter:  y
    #      Current Letter:  t
    #      Current Letter:  h
    #      Current Letter:  o
    #      Current Letter:  n
    #      Current Letter:   


list = [22 , "ali is coming!" , 45 , 0 , 'negah', 2.6]
for iter in list :
    if isinstance(iter, int) :    
        print(iter , end = ' ')   #--->  22 45 0

for iter in list :
    if type(iter) is int :   #if type(iter) == int :    #in ham javab mide vali az lahaze mantegi ghalat hast 
        print(iter)               #--->  22 45 0
 

for iter in range(10) :
    for jiter in range(99) :
        if jiter == 55 :
            break       #break from last for loop
        
        
        
# for with pass
#The pass keyword is used when a phrase is necessary syntactically to be placed but not to be executed.
#Pass statements are used to create empty loops. Pass statement is also employed for classes, functions,
#and empty control statements.
#a placeholder to running the program without problem ... implemention some code in the future
#use after if statement if you want to just check a thing and skip
for a in "Python Loops" :  
    pass  
print( 'Last Letter:', a)   #--->  Last Letter: s


for letter in 'Python':
   if letter == 'h':
      pass
      print ('This is pass block')
   print ('Current Letter :', letter)
   #--->  P
   #--->  y
   #--->  t
   #--->  This is pass block
   #--->  h
   #--->  o
   #--->  n

# for else
for iter in range(10) :
    print(iter)
else :
    print("range is finished")   #--->   0 1 2 3 4 5 6 7 8 9 range is finished

for iter in range(10) :
    if iter == 6 :
        break
    print(iter)
else :
    print("range is finished")   #--->   0 1 2 3 4 5 

for iter in range(10) :
    if iter == 6 :
        break
    print(iter)
print("range is finished")   #--->   0 1 2 3 4 5 range is finished



# for to ... of a string
zen = '''
Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
'''
for char in zen:
   if char not in 'aeiou':
      print (char, end='')      #--->  Btfl s bttr thn gly.
                                #      Explct s bttr thn mplct.
                                #      Smpl s bttr thn cmplx.
                                #      Cmplx s bttr thn cmplctd.








# while
step = 0
while(step < 5): 
    print(step)        #--->  0 1 2 3 4 5  
    step = step+1


# while else
while (counter < 10):      
    counter = counter + 3  
    print("Python Loops") 
else:  
    print("Code block inside the else statement")  

# Single statement while
counter = 0  
while (counter < 3): print("Python Loops")  
counter +=1


# while with continue
i = 0 # initial condition  
while i < 15:  
        
    # When i has value 9, loop will jump to next iteration using continue. It will not print  
    if i == 9:  
        i += 3  
        continue  
    else:  
        # when i is not equal to 9, adding 2 and printing the value  
        print( i + 2, end = " ")     #--->  2 3 4 5 6 7 8 9 10 14 15 16   
            
    i += 1  

# while with break
var = 10                    # Second Example
while var > 0:              
   print ('Current variable value :', var)
   var = var -1
   if var == 5:
      break
   #--->  10 9 8 7 6

# while with continue
var = 10
while var > 0:
   var = var -1
   if var == 5:
      continue
   print ('Current variable value :', var)   
   #--->  9 8 7 6 4 3 2 1 0

# Infinite while
var = 1
while var == 1 : # This constructs an infinite loop
   print("do something...")





# while with multiple conditions
num1 = 17  
num2 = -12  
while num1 > 5 and num2 < -5 : 
    num1 -= 2  
    num2 += 3  
    print( (num1, num2) )  

# while with grouping multiple conditions
num1 = 9   
num = 14   
maximum_value = 4  
counter = 0   
while (counter < num1 or counter < num2) and not counter >= maximum_value: # grouping multiple conditions  
    print(f"Number of iterations: {counter}")   #fstring
    counter += 1  



#--------------------------------------
#RANGE
# range
#The range() function has the following syntax:
#range(start, stop, step)

#Parameters:
#Start - Starting value of the range. Optional. Default is 0
#Stop - The range goes upto stop-1
#Step - Integers in the range increment by the step value. Option, default is 1.


print(range(15))                  #--->  range(0, 15)
'''
start is 0 by default,
step  is 1 by default,
range generated from 0 to 14
'''
print(list(range(15)))            #--->  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
print(list(range(4, 9)))          #--->  [4, 5, 6, 7, 8]
print(list(range(5, 25, 4)))      #--->  [5, 9, 13, 17, 21]
print(list(range(-5, -25, 4)))    #--->  []
print(list(range(-5, -25, -4)))   #--->  [-5, -9, -13, -17, -21]
print(list(range(5, -25, -4)))    #--->  [5, 1, -3, -7, -11, -15, -19, -23]
print(list(range(5, -25, 4)))     #--->  []
print(list(range(-5, 25, 4)))     #--->  [-5, -1, 3, 7, 11, 15, 19, 23]
print(list(range(-5, 25, -4)))    #--->  []

for i in reversed(range(21,31)):  
    print(i,end=" ")  #--->  30 29 28 27 26 25 24 23 22 21

for i in range(10): 
    print(i, end=" ")    #--->  0 1 2 3 4 5 6 7 8 9 



tuple_ = ("Python", "Loops", "Sequence", "Condition", "Range")  

for iter1 in range(len(tuple_)):  
        print(tuple_[iter1].upper())  
        #--->  PYTHON loops SEQUENCE CONDITION RANGE

for iter1 in len(tuple_):                  #--->  Error  'int' object is not iterable
        print(tuple_[iter1].upper())  

print(len(tuple_))   #--->  5


#example 1
#Factorial of a Number

fact=1
N = 5
for x in range(1, N+1):
   fact = fact*x
print ("factorial of {} is {}".format(N, fact))     #--->  factorial of 5 is 120


#--------------------------------------
#XRANGE
#???




##########################################################################################################
#ITERATOR
##########################################################################################################
#Iterator in Python is an object representing a stream of data. It follows iterator protocol which requires it to support __iter__() and __next__() methods.
#Python uses iterators are implicitly while working with collection data types such as list, tuple or string. That's why these data types are called iterables.

print (iter("aa"))      #--->  <str_ascii_iterator object at 0x000001BB03FFAB60>
print (iter([1,2,3]))   #--->  <list_iterator object at 0x000001BB03FFAB60>
print (iter((1,2,3)))   #--->  <tuple_iterator object at 0x000001BB03FFAB60>
print (iter({}))        #--->  <dict_keyiterator object at 0x000001BB04181670>
print (iter(100))       #--->  TypeError: 'int' object is not iterable

#example-1
it = iter([1,2,3])      
print (next(it))        #---> 1
print (it.__next__())   #---> 2
print (it.__next__())   #---> 3
print (next(it))        #---> Error - StopIteration

#example-2
it = iter([1,2,3, 4, 5])
print (next(it))    #--->  ???
while True:
    try:
        no = next(it)
        print (no)      #--->  ???
    except StopIteration:
        break




mystr = "banana"
myit = iter(mystr)

print(next(myit))
print(next(myit))
print(next(myit))
print(next(myit))
print(next(myit))
print(next(myit))




##########################################################################################################
#ITERTOOLS_MODULE
##########################################################################################################

#------------------
#Product
#------------------
#it is only useful for finite inputs
from itertools import product

print(list(product(A, repeat=4)))        #--->  A, A, A, A
print(list(product(range(2), repeat=3))) #--->  000, 001, 010, 100, 011, 101, 110, 111
print(list(product(AB,X)))               #--->  AX, BX

for i in product(range(2), repeat=3):
    print(i)    #--->  ???

#------------------
#islice
#------------------
from itertools import islice
#iterable, start, end, step
islice('ABCDEFG', 2)        #--->  A B
islice('ABCDEFG', 2,4)      #--->  C D
islice('ABCDEFG', 2,None)   #--->  C D E F G
islice('ABCDEFG', 0,None,2) #--->  A C E G

print(list(islice('ABCDEFG', 0,None,2)))    #--->  A C E G

for i in islice('ABCDEFG', 0,None,2):
    print(i)    #--->  ???

#------------------
#compress
#------------------
from itertools import compress

#compress(date, selector)
compress("ABCDEF", [1,0,1,1,0,1])   #--->  A C D F

names = ["Ali", "Amir", "Yashar"]
selectors = [True, False, True]

for result in compress(names, selectors)
    print(result)



#------------------
#chain
#------------------
#will get some iterable objects and produce a single one

odds = [1, 3, 5, 7, 9]
events = [2, 4, 6, 8]

result = chain(odds, events)
print(list(result))

#from_iterable
#change from one to multiple
name = "mongard"
result = chain.from_iterable(name)
print(list(result()))
name2 = ["amir","kevin"]
result = chain.from_iterable(name2)
print(list(result()))


#------------------
#accumulate
#------------------
from itertools import accumulate
import operator
nums = [3,4,6,2,1,9,0,7,5,8]
print(list(accumulate(nums))) #---> [3,7,13,15,16,25,25,32,37] => nums[0],nums[0]+num[1],...
print(list(accumulate(nums, initial = 100))) #---> 100,103,107,113,...
print(list(accumulate(nums, func = operator.sub))) #---> [3,-1,-7,...] => 3-4-6 = -7

def subtract (a,b): # Must give two arguments
    return a-b

print(list(accumulate(nums, func = subtract))) #---> [3,-1,-7,...] => 3-4-6 = -7

#------------------
#repeat
#------------------
#infinite itarator
#is lazy (work with yield)
from itertools import repeat
name = "amir"
print(repeat(name))

name = "amir"
x = repeat(name, 5)
print(next(x))  #--->  amir
print(next(x))  #--->  amir
print(next(x))  #--->  amir

#------------------
#count
#------------------
#infinite itarator
from itertools import count
count(start, step)
count(10) #--->  10 11 12 13 14 ...
count(2.5, 0.5) #--->  2.5 3.0 3.5 ...  

n = count(start=0, step=2)
print(next(n))
print(next(n))
print(next(n))

for i in count(0,1):
    print(i)
    
names = ["amir","kevin", "jack", "mark"]
for i in zip(count(1,1), name):
    print(i)    #--->  (1, "amir")
                #      (2, "amir")
                #      (3, "kevin")
                #      (4, "jack")
                #      (5, "mark")
                
n = map(lambda x:x**2, count(0,1))
for i in n:
    if i >100:
        break
    print(i)                


#example
from itertools import count
a = count()
print(a)        #--->  count(0)
b = iter(a)
print(b)        #--->  count(0)
print(next(b))  #--->  0
print(next(b))  #--->  1
print(next(b))  #--->  2
print(next(b))  #--->  3
print(next(b))  #--->  4
print(next(b))  #--->  5










#------------------
#cycle
#------------------
#infinite iterator
# go around items
from itertools import cycle
n = cycle("mon")
print(next(n))#--->  m
print(next(n))#--->  o
print(next(n))#--->  n
print(next(n))#--->  m
print(next(n))#--->  o

for i in n:
    print(i)




##########################################################################################################
#STRING
##########################################################################################################
name = "sepehr"
len(name)   #--->  6
name[0]         #--->  s
name[1]         #--->  e
name[2]         #--->  p
name[3]         #--->  e
name[4]         #--->  h
name[5]         #--->  r

name[-1]        #--->  r
name[-2]        #--->  h
name[-3]        #--->  e
name[-4]        #--->  p
name[-5]        #--->  e
name[-6]        #--->  s

#string data type does not support manual character changing
#name[1] = 'f'      #--->  Error-'str' object does not support item assignment 


print(name.upper())             #--->  SEPEHR
print(name.lower())             #--->  sepehr
print(name.strip())             #--->  sepehr
print(name.replace("H", "J"))   #--->  sepehr
print(name.split(","))          #--->  ['sepehr']







str1 = 'string using single quotes'
str2 = "string using double quotes" 
str3 = '''string using three single quotes'''
str4 = """string using four single quotes"""

print(str1)   #--->  string using single quotes   
print(str2)   #--->  string using double quotes
print(str3)   #--->  string using three single quotes   
print(str4)   #--->  string using four single quotes    





print ("var:", var)

var = """Welcome to TutorialsPoint"""
print ("var:", var)

s = '''sdaasd
sdasd
sad
'''

s = '''''A multiline 
string sample for who want to learn python recent
it is free!
'''  
print(s)       #--->  A multiline
               #      string    

a = """Lorem ipsum dolor sit amet,
consectetur adipiscing elit,
sed do eiusmod tempor incididunt
ut labore et dolore magna aliqua."""


print(r'C://python37')   #--->  C://python37  


str1 = 'hello javatpoint'    
str2 = ' how are you' 

#slice
print (str1[0:2])     #--->  he                           [0-2)    
print (str1[1:4])     #--->  ell                          [1-4) or [1-3]     
print (str1[1:])      #--->  ello javatpoint              [1-final]
print (str1[:5])      #--->  hello
print (str1[1:14:2])  #--->  el aapi
print (str1[-9:-4])   #--->  avatp                        [-9,-4)
print (str1[-4:-9])   #--->  Error-empty answer will produce 
print (str1[-4:])     #--->  oint
print (str1[::-1])    #--->  tnioptavaj olleh             reverse
print (str1[1:6:-1])  #--->  Error-empty answer will produce
print (str1[6:1:-1])  #--->  j oll                        [6-1)

#4th character of the string   
print (str1[4])       #--->  o

#printing the string multiple  
print (str1*2)        #--->  hello javatpointhello javatpoint

str3="World"
str4=str3*3
print (str4)   #--->  WorldWorldWorld


#delete
str1 = "JAVATPOINT" 
del str[1]            #--->  Error-'str' object doesn't support item deletion 
del str1  
print(str1)           #--->  NameError: name 'str1' is not defined


#concatenation of str1 and str2 
print (str1 + str2)           #--->  hello javatpoint how are you
print ("sepehr" + "bazyar")   #--->  sepehrbazyar
str3 = str1 + str2
print (str3)                  #---> sepehrbazyar
print (str3 + " test")        #---> sepehrbazyar test

age = 36
txt = "My name is John, I am " + age
print(txt)   #--->  TypeError: can only concatenate str (not "int") to str

#Format Method
#combine strings and numbers by using the format() method
age = 36
txt = "My name is John, and I am {}"
print(txt.format(age))   #--->  My name is John, and I am 36

quantity = 3
itemno = 567
price = 49.95
myorder = "I want {} pieces of item {} for {} dollars."
print(myorder.format(quantity, itemno, price))   #--->  I want 3 pieces of item 567 for 49.95 dollars.

myorder = "I want to pay {2} dollars for {0} pieces of item {1}."
print(myorder.format(quantity, itemno, price))   #--->  I want to pay 49.95 dollars for 3 pieces of item 567.

quantity = 3
itemno = 567
price = 49
myorder = "I want {0} pieces of item number {1} for {2:.2f} dollars."
print(myorder.format(quantity, itemno, price))  #--->  I want 3 pieces of item number 567 for 49.00 dollars.

txt = "The price is {:.2f} dollars"
print(txt.format(price))    #--->  The price is 49.00 dollars

print("{a},{b},{c}".format(a = "James", b = "Peter", c = "Ricky"))  

myorder = "I have a {carname}, it is a {model}."
print(myorder.format(carname = "Ford", model = "Mustang"))  #--->  I have a Ford, it is a Mustang.




#empty string
s1=''

#chr() Function
num = 97
print("ASCII Value of 97 is: ", chr(num))   #--->  ASCII Value of 97 is:  a
print(type(chr(num)) is str)    #--->  True
print(chr(11111111))            #--->  ValueError: chr() arg not in range(0x110000) 

#modify a string using array
#To modify a string, construct an array object. Python standard library includes array module. We can have 
#an array of Unicode type from a string variable.
myStr = "Hello, How are you?"
arr = array.array('u',myStr)
arr[0] = 'm'        # Modifying the array
arr.insert(3,"L")
print(arr)      #--->  array('u', 'melLlo, How are you?')
myStr = arr.tounicode()  # convert an array to a unicode string using tounicode
print(myStr)    #--->  melLlo, How are you?




#   Using regex module
import re
address = '211B Baker Street'
new_address = re.sub('Street', 'St.', address)
print(new_address)  #--->  211B Baker St.

sen = "Ali has four book and two balls"
re.findall(r'\w{4}s\b' , sen)   #--->  ["books" , "balls"]


#modify a string Using the StringIO Class
s1="WORD"
sio=io.StringIO(s1)
sio.seek(3)       #--->  skip first 3 character
sio.write("LD")   #--->  write this to after 3th character
s1=sio.getvalue() #--->  build string
print (s1)   #--->  WORLD

#change a character of string
#   with Using slicing method
str = 'favtutor'
index = 0
new_character = 'F'
str = str[:index] + new_character + str[index+1:]
print(str)
#   with convert to list
#you should go on step by step:
# string -> list -> change the character -> list -> string
programming_language = "Python"
programming_language_list = list(programming_language)   #--->  ['P', 'y', 't', 'h', 'o', 'n']
programming_language_list.replace(" ", "")
programming_language = str(programming_language_list)
#   with Replace multiple characters with the same character
str = 'Python' 
indexes = [2, 4, 5] 
new_character = 'a' 
result = '' 
for i in indexes:
    str = str[:i] + new_character + str[i+1:] 
print(str)      #--->  Pyahaa
#   with Replace multiple characters with different characters
str = 'Python'
indexes = {2: 'a',
           4: 'b',
           5: 'c'}
result = ''
for index, replacement in indexes.items():
    str = str[:index] + indexes[index] + str[index + 1:]
print(str)      #--->  Pyahbc



#Looping through the a String
for x in "banana":
  print(x)

#Check
txt = "The best things in life are free!"
print("free" in txt)   #--->  True

txt = "The best things in life are free!"
print("expensive" not in txt)   #--->  True

txt = "The best things in life are free!"
if "free" in txt:
  print("Yes")      #--->  Yes

txt = "The best things in life are free!"
if "expensive" not in txt:
  print("is NOT present.")  #--->  is NOT present.



#add list to string
list1 = ['W', 'O', 'R', 'L', 'D']
s1=''.join(list1)





#   \'   --->  Single Quote	
#   \"   --->  Double Quote	
#   \\   --->  Backslash	
#   \n   --->  New Line	
#   \    --->  ignore new line
#   \r   --->  Carriage Return	
#   \t   --->  Tab	
#   \v   --->  Vertical Tab
#   \b   --->  Backspace	
#   \b	 --->  ASCII Backspace(BS)
#   \f   --->  Form Feed	
#   \a	 --->  ASCII Bell

#   \ooo   --->  Octal value	
#   \xhh   --->  Hex value
#   %      --->  It makes use of the format specifiers used in C programming like %d or %f to map their values in python.


#Escape Character
#txt = "We are the so-called "Vikings" from the north."      #--->  Error-you should use \" 
txt = "We are the so-called \"Vikings\" from the north."     #--->  We are the so-called "Vikings" from the north.
txt = '''We are the so-called "Vikings" from the north.'''   #--->  We are the so-called "Vikings" from the north.
txt = 'We are the so-called "Vikings" from the north.'       #--->  We are the so-called "Vikings" from the north.


#backslash
print("C:\\Users\\DEVANSH SHARMA\\Python32\\Lib")    #--->  C:\Users\DEVANSH SHARMA\Python32\Lib  

#We can ignore the escape sequence from the given string by using the raw string.
print(r"C:\\Users\\DEVANSH SHARMA\\Python32")   #--->  C:\\Users\\DEVANSH SHARMA\\Python32  

#ignore new line
print("Python1 \
Python2 \
Python3")   #--->  Python1 Python2 Python3

#backspace
print("Hello \b World")   #--->  Hello World

#form feed
s= "hello\fworld"
print (s)   #--->  helloworld

#ASCII Bell character
#A bell character (sometimes bell code) is a device control code originally sent to ring a small electromechanical bell on tickers and other teleprinters and teletypewriters to alert operators at the other end of the line, often of an incoming message.
s='Hello\a'
print (s)   #--->  Hello   (make a short bell sound)


#Character with octal value
print("\110\145\154\154\157")   #--->  Hello

#Character with hex value.
print("\x48\x65\x6c\x6c\x6f")   #--->  Hello
print("This is \x48\x45\x58 representation")   #--->  This is HEX representation

#format specifiers
str = "Hello"     
print("The string str : %s"%(str))   #--->  The string str : Hello    

In = 10;    
Fl = 1.290    
St = "Devansh"    
print("Hi I am Integer ... My value is %d\nHi I am float ... My value is %f\nHi I am string ... My value is %s"%(In,Fl,St)) 





#convert a string with binary digits to integer.
mystr = '10101'

def strtoint(mystr):
   for x in mystr:
      if x not in '01': return "Error. String with non-binary characters"
   num = int(mystr, 2)
   return num
print ("binary:{} integer: {}".format(mystr,strtoint(mystr)))   #--->  binary:10101 integer: 21


#drop all digits from a string.
digits = [str(x) for x in range(10)]
mystr = 'He12llo, Py00th55on!'
chars = []
for x in mystr:
   if x not in digits:
      chars.append(x)
newstr = ''.join(chars)
print (newstr)   #--->  Hello, Python!

##########################################################################################################
#STRING_MODULE
##########################################################################################################
#package of string to import to your project and use it


import string
print(string.digits)    #--->  0123456789
print(string.ascii_letters)     #--->  abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ



#example
#create random powerful password
import string, random

while True :
    length = int(input('please enter your preferred password length : '))
    chars = string.ascii_letters + string.digits + '!@#$%^&*()_+=-'
 
    password = ''.join([random.choice(chars) for i in range(length)])
 
    print ('your password : {}'.format(password))
 
    while True:
 
        answer = input('do you want to chose another password(Y/n) : ').lower()
 
        if answer == 'n' or answer == 'y':
            break
    
    if answer == 'n':
        break




import string

# string module constants
print(string.ascii_letters)
print(string.ascii_lowercase)
print(string.ascii_uppercase)
print(string.digits)
print(string.hexdigits)
print(string.whitespace)  # ' \t\n\r\x0b\x0c'
print(string.punctuation)



##########################################################################################################
#STRING_METHODS
##########################################################################################################
#   capitalize()    --->	 Converts the first character to upper case
var="hello python"
var4=var.capitalize()
print ("capitalized:",var4)   #--->  Hello python
var4=str.capitalize(var)
print ("capitalized:",var4)   #--->  Hello python
var = "hello python".capitalize()
print(var)

#   casefold()	    --->	 Converts string into lower case
var = "THIS IS STR EXAMPLE....WOW!!!"
var1 = var.casefold()
print ("casefolded:", var1)   #--->  this is str example....wow!!!
var = "Straße"
var1 = var.casefold()         #The German character ß is converted to "ss".
print ("casefolded:", var1)   #--->  strasse
var5=str.casefold(var)
print ("casefolded:", var5)   #--->  this is stringexample....wow!!!


#   center()	    --->	 Returns a centered string
#   center(width,fillchar)   --->  It returns a space padded string with the original string centred with equal number of left and right spaces.
var = "This Is String Example....WOW!!!"
var1 = var.center(40, '*')         #--->  40 is length of string 
print ("Centered string:", var1)   #--->  ****This Is String Example....WOW!!!****
var = "Hello python"
var1 = str.center(var, 40)
print ("centered:", var1)          #--->                 Hello python              


#   count()	        --->	 Returns the number of times a specified value occurs in a string
#   count(string,begin,end)  --->  It counts the number of occurrences of a substring in a String between begin and end index. 
var = "Explicit is better than implicit."
count1 = var.count('cit')
print ("Count of 'cit':", count1)   #--->  2
count2 = var.count('i', 0, 10)
print ("Count of 'i' in first 10 characters:", count2)  #--->  3


#   endswith()	    --->	 Returns true if the string ends with the specified value
#   endswith(suffix ,begin=0,end=len(string))   --->  It returns a Boolean value if the string terminates with given suffix between begin and end.
var = "Explicit is better than implicit."
var1 = var.endswith('t.')
print ("ends with t.:", var1)         #--->  True
var2 = var.endswith('be', 0, 14)
print ("left substring upto index 14 ends with be :", var2)   #--->  True  


#   expandtabs()    --->	 Sets the tab size of the string
#   expandtabs(tabsize = 8)  --->  It defines tabs in string to multiple spaces. The default space value is 8. 
var = "this is\tstring example....wow!!!"
var1 = var.expandtabs()
print ("string with default expanded tab:", var1)   #--->  this is string example....wow!!!
var2 = var.expandtabs(16)
print ("string with double expanded tab:", var2)    #--->  this is         string example....wow!!!
var="Hello\tPython"
var4=str.expandtabs(var, 16)
print ("capitalized:",var4)                         #--->   Hello           Python
txt = "H\te\tl\tl\to"
print(txt)                  #--->  H       e       l       l       o
print(txt.expandtabs())     #--->  H       e       l       l       o
print(txt.expandtabs(2))    #--->  H e l l o
print(txt.expandtabs(4))    #--->  H   e   l   l   o
print(txt.expandtabs(10))   #--->  H         e         l         l         o



#   find()	        --->	 Searches the string for a specified value and returns the position of where it was found
#   find(substring ,beginIndex, endIndex)   --->  It returns the index value of the string where substring is found between begin index and end index.
var = "Explicit is better than implicit."
count1 = var.find('is') 
print ("'is' found at:", count1)   #---> 9 
count2=var.find('a', 0, 10)
print ("'a' found at:", count2)    #---> -1    Since "a" is not found, it returns -1.
txt = "Hello, welcome to my world."
print(txt.find("q"))               #--->  -1
print(txt.index("q"))              #--->  ValueError: substring not found
#   rfind(str,beg=0,end=len(str))	        --->  It is similar to find but it traverses the string in backward direction.
#   rfind()	        --->	 Searches the string for a specified value and returns the last position of where it was found
var = "Explicit is better than implicit."
var1 = var.rfind('i')
print ("Last index of 'i':", var1)   #--->  30   index of rightest 'i' 
var2 = var.rfind('x', 10, -1)
print ("Last index of 'x':", var2)   #--->  -1   Since the letter x is not present from 10th index onwards, it returns "-1".
#Where in the text is the last occurrence of the letter "e" when you only search between position 5 and 10?
txt = "Hello, welcome to my world."
x = txt.rfind("e", 5, 17)
print(x)                             #--->  13
txt = "Hello, welcome to my world."
print(txt.rfind("q"))                #--->  -1
print(txt.rindex("q"))               #--->  ValueError: substring not found



#   format()	    --->	 Formats specified values in a string
#   format(value)	--->     It returns a formatted version of S, using the passed value.
#   formats the specified value(s) and insert them inside the string's placeholder.
#   The placeholder is defined using curly brackets: {}
#   The placeholders can be identified using named indexes {price}, numbered indexes {0}, or even empty placeholders {}.
txt1 = "My name is {fname}, I'm {age}".format(fname = "John", age = 36)
txt2 = "My name is {0}, I'm {1}".format("John",36)
txt3 = "My name is {}, I'm {}".format("John",36)
print(txt1)   #--->  My name is John, I'm 36
print(txt2)   #--->  My name is John, I'm 36
print(txt3)   #--->  My name is John, I'm 36
#Inside the placeholders you can add a formatting type to format the result:
txt = "For only {price:.2f} dollars!"
print(txt.format(price = 49))   #--->  For only 49.00 dollars!
txt = "We have {:<8} chickens."
print(txt.format(49))           #--->  We have 49       chickens.
txt = "We have {:>8} chickens."
print(txt.format(49))           #--->  We have       49 chickens.
txt = "We have {:^8} chickens."
print(txt.format(49))           #--->  We have    49    chickens.
txt = "The temperature is {:=8} degrees celsius."                               #Use "=" to place the plus/minus sign at the left most position
print(txt.format(-5))           #--->  The temperature is -      5 degrees.
txt = "The temperature is between {:+} and {:+} degrees celsius."
print(txt.format(-3, 7))        #--->  The temperature is between -3 and +7 degrees celsius.
txt = "The temperature is between {:-} and {:-} degrees celsius."
print(txt.format(-3, 7))        #--->  The temperature is between -3 and 7 degrees celsius.
txt = "The temperature is between {: } and {: } degrees celsius."               #Use " " (a space) to insert a space before positive numbers and a minus sign before negative numbers
print(txt.format(-3, 7))        #--->  The temperature is between -3 and  7 degrees celsius.
txt = "The universe is {:,} years old."
print(txt.format(13800000000))  #--->  The universe is 13,800,000,000 years old.
txt = "The universe is {:_} years old."
print(txt.format(13800000000))  #--->  The universe is 13_800_000_000 years old.
txt = "The binary version of {0} is {0:b}"
print(txt.format(5))            #--->  The binary version of 5 is 101
txt = "We have {:d} chickens."
print(txt.format(0b101))        #--->  We have 5 chickens.
txt = "We have {:e} chickens."
print(txt.format(5))            #--->  We have 5.000000e+00 chickens.
txt = "We have {:E} chickens."
print(txt.format(5))            #--->  We have 5.000000E+00.
txt = "The price is {:.2f} dollars."
print(txt.format(45))           #--->  The price is 45.00 dollars.
txt = "The price is {:f} dollars."
print(txt.format(45))           #--->  The price is 45.000000 dollars.
#Use "F" to convert a number into a fixed point number, but display inf and nan as INF and NAN:
x = float('inf')
txt = "The price is {:F} dollars."
print(txt.format(x))            #--->  The price is INF dollars.
#same example, but with a lower case f:
txt = "The price is {:f} dollars."
print(txt.format(x))            #--->  The price is inf dollars.
txt = "The octal version of {0} is {0:o}"
print(txt.format(10))           #--->  The octal version of 10 is 12
txt = "The Hexadecimal version of {0} is {0:x}"
print(txt.format(255))          #--->  The Hexadecimal version of 255 is ff
txt = "The Hexadecimal version of {0} is {0:X}"
print(txt.format(255))          #--->  The Hexadecimal version of 255 is FF
txt = "You scored {:%}"
print(txt.format(0.25))         #--->  You scored 25.000000%
txt = "You scored {:.0%}"
print(txt.format(0.25))         #--->  You scored 25%
#   format_map()    --->	 Formats specified values in a string
#to return a dictionary key’s value. It is almost like the format() method but the difference is that the 
#format() method creates a new dictionary whereas the format_map() doesn't.
a = {'x':'Jerry', 'y':'Stark'} 
print("{x}'s last name is {y}".format_map(a))   #--->  Jerry's last name is Stark      

profession = { 'name':['Barry', 'Bruce'], 'profession':['Flash', 'Batman'] }   
print('{name[0]} is the {profession[0]}. '.format_map(profession))  #--->  Barry is the Flash. 
print('{name[1]} is the {profession[1]}. '.format_map(profession))  #--->  Bruce is the Batman.


#   fstring (fprint)
#fstring is simpler than format()
name = "Ali"
print(f"my name is {name}")     #--->  my name is Ali
num = 23.9000876
print(f"num is {num:.3f}")       #--->  ???
print(f"num is {num:.03f}")      #--->  ???

#   oldest way
print("%5.3f." % math.pi)        #--->  3.152    (5 character - 3 after .    - f float)

#   index()	        --->	 Searches the string for a specified value and returns the position of where it was found
#   index(substring, beginIndex, endIndex)   --->  It throws an exception if string is not found. It works same as find() method.
var = "Explicit is better than implicit."
var1 = var.index('i')
print ("index of 'i':", var1)   #--->  4
var2 = var.index('z')
print ("index of 'z':", var2)   #--->  ValueError: substring not found
#   rindex(str,beg=0,end=len(str))	        --->  It is same as index but it traverses the string in backward direction.
#   rindex()	    --->	 Searches the string for a specified value and returns the last position of where it was found
var = "Explicit is better than implicit."
var1 = var.rindex('i')          
print ("index of 'i':", var1)   #--->  30   index of rightest 'i' 
var2 = var.rindex('x', 10, -1)
print ("index of 'x':", var2)   #--->  ValueError: substring not found
#Where in the text is the last occurrence of the letter "e" when you only search between position 5 and 10?
txt = "Hello, welcome to my world."
x = txt.rindex("e", 5, 17)
print(x)                        #--->  13
txt = "Hello, welcome to my world."
print(txt.rfind("q"))           #--->  -1
print(txt.rindex("q"))          #--->  ValueError: substring not found



#   isalnum()	    --->	 Returns True if all characters in the string are alphanumeric
#checks whether the string consists of alphanumeric characters.
#If it contains any non-alphanumeric characters (apart from alphabets and digits), it returns False.
#Example of characters that are not alphanumeric: (space)!#%&? etc.
var = "Explicit is better than implicit."
var1 = var.isalnum()
print ("Is it alphanumeric?:", var1)   #--->  False      because of dot (.) at the end of string
var = "TutorialsPoint"
var2 = var.isalnum()
print ("Is it alphanumeric?:", var2)   #--->  True
var = "123.45"
var3 = var.isalnum()
print ("Is it alphanumeric?:", var3)   #--->  False      because of dot (.) at the center of string


#   isalpha()	    --->	 Returns True if all characters in the string are in the alphabet letters (a-z).
var = "Explicit is better than implicit."
var1 = var.isalpha()
print ("Is it alphabets only?:", var1)   #--->  False
var = "TutorialsPoint"
var2 = var.isalpha()
print ("Is it alphabets only?:", var2)   #--->  True
var = "www.tutorialspoint.com"
var3 = var.isalpha()
print ("Is it alphabet only?:", var3)    #--->  False


#   isascii()	    --->	 Returns True if all characters in the string are ascii characters
var = "Hello Python"
var1 = var.isascii()
print ("is ASCII only?:", var1)   #--->  True
var = "ABC!@#"
var2 = var.isascii()
print ("is ASCII only?:", var2)   #--->  True
var = "\u20B9100"
var3 = var.isascii()
print ("is ASCII only?:", var3)   #--->  False


#   isdecimal()	    --->	 Returns True if all characters in the string are decimals (0-9)
var = "123"
var1 = var.isdecimal()
print ("is decimal only?:", var1)   #--->  True
var = "\u0031\u0032\u0033"
var2 = var.isdecimal()
print ("is decimal only?:", var2)   #--->  True
var = "123.34"
var3 = var.isdecimal()
print ("is decimal only?:", var3)   #--->  False
a = "\u0030" #unicode for 0
b = "\u0047" #unicode for G
print(a.isdecimal())                #--->  True
print(b.isdecimal())                #--->  False


#   isdigit()	    --->	 Returns True if all characters in the string are digits
var = "500081"
var1 = var.isdigit()
print ("Is it digits only?:", var1)   #--->  True
var = "TutorialsPoint"
var2 = var.isdigit()
print ("Is it digits only?:", var2)   #--->  False
var = "123.34"
var3 = var.isdigit()
print ("Is it digits only?:", var3)   #--->  False
a = "\u0030" #unicode for 0
b = "\u00B2" #unicode for ²
print(a.isdigit())                    #--->  True  
print(b.isdigit())                    #--->  True


#   isidentifier()	--->	 Returns True if the string is an identifier
#returns True if the string is a valid identifier, otherwise False.
#A string is considered a valid identifier if it only contains alphanumeric letters (a-z) and (0-9), 
#or underscores (_)
#A valid identifier cannot start with a number, or contain any spaces.
a = "MyFolder"
b = "Demo002"
c = "2bring"
d = "my demo"
print(a.isidentifier())     #--->  True
print(b.isidentifier())     #--->  True
print(c.isidentifier())     #--->  False
print(d.isidentifier())     #--->  False


#   isnumeric()	    --->	 Returns True if all characters in the string are numeric
#"-1" and "1.5" are NOT considered numeric values, because all the characters in the string must be numeric,
#and the - and the . are not.
#Exponents, like ² and ¾ are also considered to be numeric values.
var = "\u0031\u0030"
var1 = var.isnumeric()
print ("Is it numerics only?:", var1)   #--->  True
var = "3/4"
var2 = var.isnumeric()
print ("Is it numerics only?:", var2)   #--->  True
var = "\u0024100"
var3 = var.isnumeric()
print ("Is it numerics only?:", var3)   #--->  False
b = "\u00B2" #unicode for ²
print(b.isnumeric())                    #--->  True


#   isprintable()	--->	 Returns True if all characters in the string are printable
#                            Example of none printable character can be carriage return and line feed.
var = "Hello Python"
var1 = var.isprintable()
print ("is a valid identifier?:", var1)   #--->  True
var = "Hello\tPython"
var2 = var.isprintable()
print ("is a valid identifier?:", var2)   #--->  False
var = "Hello\bPython"
var3 = var.isidentifier()
print ("is a valid identifier?:", var3)   #--->  False
txt = "Hello!\nAre you #1?"
x = txt.isprintable()
print(x)                                  #--->  False



#   isspace()	    --->	 checks whether the string consists of whitespace.
var = ""
var1 = var.isspace()
print ("contains whitespace only?:", var1)   #--->  False
var = " "
var2 = var.isspace()
print ("contains whitespace only?:", var2)   #--->  True
var = "Hello Python"
var3 = var[5].isspace()
print ("contains whitespace only?:", var3)   #--->  True
txt = "   s   "
x = txt.isspace()
print(x)                                     #--->  False



#   join()	        --->	 Joins the elements of an iterable to the end of the string
#                            takes all items in an iterable and joins them into one string.
#   Join all items in a tuple into a string, using a hash character ('#') as separator:
#   join(seq)       --->     It merges the strings representation of the given sequence
myTuple = ("John", "Peter", "Vicky")
x = "#".join(myTuple)
print(x)            #--->  John#Peter#Vicky
#   Join all items in a dictionary into a string, using the word "TSST" as separator:
myDict = {"name": "John", "country": "Norway"}
mySeparator = "TSST"
x = mySeparator.join(myDict)
print(x)            #--->  nameTSSTcountry



#   ljust()	        --->	 Returns a left justified version of the string
#   ljust(width[,fillchar])	 --->  It returns the space padded strings with the original string left justified to the given width.
#   rjust(width,[,fillchar]) --->  Returns a space padded string having original string right justified to the number of characters specified.
#   rjust()	        --->	 Returns a right justified version of the string
var = "This Is String Example....WOW!!!"
var1 = var.ljust(40, '*')
print ("Left justified string:", var1)   #--->  This Is String Example....WOW!!!********
var2 = var.rjust(40, '*')
print ("Right justified string:", var2)  #--->  ********This Is String Example....WOW!!!
var="Hello python"
var2=str.ljust(var, 40, '*')   #--->  Hello python****************************
var3=str.rjust(var, 40, '*')   #--->  ****************************Hello python
txt = "banana"
x = txt.ljust(20)
print(x, "is my favorite fruit.")   #--->  banana              is my favorite fruit.



#   translate()	    --->	 Returns a translated string
#   translate(table,deletechars = '')	 --->  It translates the string according to the translation table passed in the function .
#   maketrans()	    --->	 Returns a translation table to be used in translations
var = 'Explicit is better than implicit.'
table = var.maketrans({'i':'I'})
print ("translation table:", table)   #--->  {105: 'I'}          105 is ascii code of i 
var1 = var.translate(table)
print ("Translated string", var1)     #--->  Translated string ExplIcIt Is better than ImplIcIt.
table2 = var.maketrans("than", "then")
print ("translation table:", table2)  #--->  {116: 116, 104: 104, 97: 101, 110: 110}
var2 = var.translate(table2)
print ("Translated string", var2)     #--->  Explicit is better then implicit.
table3 = var.maketrans("is","as", "s")
print ("translation table:", table3)  #--->  {105: 97, 115: None}  
var3=var.translate(table3)
print ("Translated string", var3)     #--->  Explacat a better than amplacat.
#The translate() method returns a string where some specified characters are replaced with the character
#described in a dictionary, or in a mapping table.
#Use the maketrans() method to create a mapping table.
#If you use a dictionary, you must use ascii codes instead of characters.
#use a dictionary with ascii codes to replace 83 (S) with 80 (P):
txt = "Hello Sam!"
mydict = {83:  80}
print(txt.translate(mydict))          #--->  Hello Pam!
txt = "Hello Sam!"
mytable = str.maketrans("S", "P")
print(txt.translate(mytable))         #--->  Hello Pam!
#maketrans use unicode
txt = "Hi Sam!"
x = "mSa"
y = "eJo"
mytable = str.maketrans(x, y)
print(txt.translate(mytable))         #--->  Hi Joe!
txt = "Good night Sam!"
x = "mSa"
y = "eJo"
z = "odnght"
mytable = str.maketrans(x, y, z)
print(txt.translate(mytable))         #--->  G i Joe!
txt = "Good night Sam!"
mydict = {109: 101, 83: 74, 97: 111, 111: None, 100: None, 110: None, 103: None, 104: None, 116: None}
print(txt.translate(mydict))          #--->  G i Joe!



#   partition()	    --->	 Returns a tuple where the string is parted into three parts
#   splits the string at the first occurrence of the separator, and returns a tuple of three strings
#   part of the string before the separator, the separator itself, and the part after it.
#   If the separator is not present, two empty strings are appended to the tuple.
#   If the separator is an empty string, Python raises error.
var = 'Explicit is better than implicit'
var1 = var.partition('better')
print ("partitions:", var1)             #--->  ('Explicit is ', 'better', ' than implicit')
var = "Explicit is better than implicit"
var2 = var.partition('Ex')
print ("partitions:", var2)             #--->  ('', 'Ex', 'plicit is better than implicit')
var = 'Explicit is better than implicit'
var3 = var.partition("IS")
print ("partitions:", var3)             #--->  ('Explicit is better than implicit', '', '')
#   rpartition()    --->	 Returns a tuple where the string is parted into three parts
var = 'Explicit is better than implicit'
var1 = var.rpartition('ci')
print ("partitions:", var1)             #--->  ('Explicit is better than impli', 'ci', 't')
var = "Explicit is better than implicit"
var2 = var.rpartition('IS')
print ("partitions:", var2)             #--->  ('', '', 'Explicit is better than implicit')
var = 'Explicit is better than implicit'
var3 = var.rpartition("")
print ("partitions:", var3)             #--->  ValueError: empty separator
txt = "I could eat bananas all day, bananas are my favorite fruit"
x = txt.rpartition("bananas")
print(x)                                #--->  ('I could eat bananas all day, ', 'bananas', ' are my favorite fruit')



#   replace()	    --->	 Returns a string where a specified value is replaced with a specified value
#   replace(old,new[,count]) --->  It replaces the old sequence of characters with the new sequence. The max characters are replaced if max is given.
var = "Explicit is better than implicit."
var1 = var.replace('i', 'u')
print ("string after replacement:", var1)   #--->  Explucut us better than umplucut.
#Replace the two first occurrence of the word "one":
txt = "one one was a race horse, two two was one too."
x = txt.replace("one", "three", 2)
print(x)                                    #--->  three three was a race horse, two two was one too."



#   strip()	        --->	 Returns a trimmed version of the string
#   strip([chars])	--->     It is used to perform lstrip() and rstrip() on the string.
#returns a copy of the string in which all chars have been stripped from the beginning and the end of the string
var = " Hello Python "
var1 = var.strip()
print ("stripped string:", var1)   #--->  Hello Python
var = "0001234000"
var2 = var.rstrip('0')
print ("stripped string:", var2)   #--->  0001234
var = 'this is string example....wow!!!'
var3 = var.strip('!')
print ("stripped:", var3)          #--->  this is string example....wow
txt = ",,,,,rrttgg.....banana....rrr"
x = txt.strip(",.grt")             #--->  banana
print(x)
#   rstrip()	    --->	 Returns a right trim version of the string
#   rstrip()	    --->     It removes all trailing whitespace of a string and can also be used to remove particular character from trailing.
var = " Hello Python "
var1 = var.rstrip()
print ("rstripped string:", var1)   #--->  Hello Python
var = "0001234000"
var2 = var.rstrip('0')
print ("rstripped string:", var2)   #--->  0001234
var = 'this is string example....wow!!!'
var3 = var.rstrip('!')
print ("rstripped:", var3)          #--->  this is string example....wow
txt = "banana,,,,,ssqqqww....."
x = txt.rstrip(",.qsw")
print(x)                            #--->  banana
#   lstrip()	    --->  Returns a left trim version of the string
var = " Hello Python "
var1 = var.lstrip()
print ("lstripped string:", var1)   #--->  Hello Python 
var = "0001234000"
var2 = var.lstrip('0')
print ("lstripped string:", var2)   #--->  1234000
var = '''
Welcome To
TutorialsPoint
'''
var3 = var.lstrip()
print ("lstripped:", var3)          #--->  Welcome To
                                    #      TutorialsPoint
txt = "     banana     "
x = txt.lstrip()
print("of all fruits", x, "is my favorite")   #--->  of all fruits banana     is my favorite
txt = ",,,,,ssaaww.....banana"
x = txt.lstrip(",.asw")
print(x)                                      #--->  banana



#   split()	        --->	 Splits the string at the specified separator, and returns a list
#   split(str,num=string.count(str))	Splits the string according to the delimiter str. The string splits according to the space if the delimiter is not provided. It returns the list of substring concatenated with the delimiter.
#   returns a list of all the words in the string, using sep as the separator (splits on all whitespace if left
#   unspecified), optionally limiting the number of splits to num.
var = 'Explicit is better than implicit'
var1 = var.split()
print ("list off split strings:", var1)   #--->  ['Explicit', 'is', 'better', 'than', 'implicit']
var = "911-7342-058"
var2 = var.split('-')
print ("list of split strings:", var2)    #--->  ['911', '7342', '058']
var2 = var.split('-')[1]
print(var2)                               #--->  ['7342']
txt = "apple#banana#cherry#orange"
# setting the maxsplit parameter to 1, will return a list with 2 elements!
x = txt.split("#", 1)
print(x)                                  #--->  ['apple', 'banana#cherry#orange']
x = txt.split("#", 1)[0]
print(x)                                  #--->  ['apple']
var = 'Explicit is better than implicit'
var3 = var.split(' ',2)
print ("list of split strings:", var3)    #--->  ['Explicit', 'is', 'better than implicit'] 
#   rsplit()	    --->	 Splits the string at the specified separator, and returns a list
#   rsplit(sep=None, maxsplit = -1)	  --->  It is same as split() but it processes the string from the backward direction. It returns the list of words in the string. If Separator is not specified then the string splits according to the white-space.
#   This method returns a list of strings.
var = 'Explicit is better than implicit'
var1 = var.rsplit()
print ("result of rsplit :", var1)   #--->  ['Explicit', 'is', 'better', 'than', 'implicit']
var = "911-7342-058"
var2 = var.rsplit('-')
print ("result of rsplit :", var2)   #--->  ['911', '7342', '058']
txt = "apple, banana, cherry"
# setting the maxsplit parameter to 1, will return a list with 2 elements!
x = txt.rsplit(", ", 1)
print(x)
var = 'Explicit is better than implicit'
var3 = var.rsplit(' ',2)
print ("result of rsplit :", var3)   #--->  ['Explicit is better', 'than', 'implicit']  



#   splitlines()    --->	 Splits the string at line breaks and returns a list
#   splitlines(num=string.count('\n'))	  --->  It returns the list of strings at each line with newline removed.
#   This method returns a list of lines in the string
#   splits the sting at line boundaries. It returns a list of lines in the string. 
#   The line boundary marks are not included by default.
#   The symbols such as \n, \r, \r\n, \f are treated as line boundaries.
var = '''Explicit
is
better than
implicit'''
var1 = var.splitlines()
print ("list of lines:", var1)   #--->  ['Explicit', 'is', 'better than', 'implicit']
var = "Hello\nPython"
var2 = var.splitlines(True)
print ("list of lines:", var2)   #--->  ['Hello\n', 'Python']
var = '''Explicit
is
better than
implicit'''
var3 = var.splitlines(True)
print ("list of lines:", var3)   #--->  ['Explicit\n', 'is\n', 'better than\n', 'implicit']


#   startswith()	--->	 Returns true if the string starts with the specified value
#   startswith(str,beg=0,end=len(str))	  --->  It returns a Boolean value if the string starts with given str between begin and end.
var = "Explicit is better than implicit."
var1 = var.startswith('Ex')
print ("Starts with Ex:", var1)     #--->  True
var2 = var.startswith('b', 10, -1)
print ("Substring from index 10 starts with b:", var2)   #--->  False
var3 = var.startswith('b', 10, 1)
print ("Substring from index 10 starts with b:", var3)   #--->  False
var4 = var.startswith('b', 1, 10)
print ("Substring from index 10 starts with b:", var4)   #--->  False



#   swapcase()	    --->	 Swaps cases, lower case becomes upper case and vice versa
var = "This Is String Example....WOW!!!"
var1 = var.swapcase()
print ("Case Swapped:", var1)   #--->  tHIS iS sTRING eXAMPLE....wow!!!
var="Hello python"
var6=var.swapcase()
print ("case swapped:", var6)   #--->  hELLO PYTHON 
var6=str.swapcase(var)
print ("case swapped:", var6)   #--->  hELLO PYTHON


#   title()	        --->	 Converts the first character of each word to upper case
#   title()         --->     returns a copy of the string in which first characters of all the words are capitalized.
var = "this is string example....wow!!!"
var1 = var.title()
print ("Title case:", var1)   #--->  This Is String Example....Wow!!!
var3=str.title(var)
print ("title case:", var3)   #--->  This Is String Example....Wow!!!
txt = "Welcome to my 2nd world"
x = txt.title()
print(x)                      #--->  Welcome To My 2Nd World
txt = "hello b2b2b2 and 3g3g3g"
x = txt.title()
print(x)                      #--->  Hello B2B2B2 And 3G3G3G
#   istitle()	    --->	 Returns True if the string follows the rules of a title
#returns True if all words in a text start with a upper case letter, AND the rest of the word are lower case letters, otherwise False.
var = "Hello Python"
var1 = var.istitle()
print ("is title cased?:", var1)   #--->  True
var = "HelloPython"
var2 = var.istitle()
print ("is title cased?:", var2)   #--->  False
var = "Welcome To TutorialsPoint"
var3 = var.istitle()
print ("is title cased?:", var3)   #--->  False
txt = "Hello, And Welcome To My World!"
x = txt.istitle()
print(x)                           #--->  True
c = "22 Names"
print(c.istitle())                 #--->  True
d = "This Is %'!?"
print(d.istitle())                 #--->  True


#   upper()	        --->	 Converts a string into upper case
var = "this is str example....wow!!!"
var1 = var.upper()
print ("Upper case:", var1)   #--->  THIS IS STR EXAMPLE....WOW!!!
var="Hello python"
var1=str.upper(var)
print ("upper case:", var1)   #--->  HELLO PYTHON
#   isupper()       --->     It returns false if characters of a string are in Upper case, otherwise False.
#   isupper()	    --->	 Returns True if all characters in the string are upper case
#                            Numbers, symbols and spaces are not checked, only alphabet characters.
var = "Hello Python"
var1 = var.upper().isupper()
print ("is uppercased?:", var1)   #--->  True
var = "UPPER Case"
var2 = var.isupper()
print ("is uppercased?:", var2)   #--->  False
var = "HYDERABAD 500081"
var3 = var.isupper()
print ("is uppercased?:", var3)   #--->  True


#   lower()	        --->	 Converts a string into lower case but Symbols and Numbers are ignored.
var = "THIS IS STR EXAMPLE....WOW!!!"
var1 = var.lower()
print ("Lowercase:", var1)   #--->  this is str example....wow!!!
var="Hello python"
var2=str.lower(var)
print ("lowercase: ", var2)  #--->  hello python
#   islower()	    --->	 Returns True if all characters in the string are lower case
var = "explicit is better than implicit."
var1 = var.islower()
print ("Is it lowercase only?:", var1)   #--->  True
var = "are you ok?"
var2 = var.islower()
print ("Is it lowercase only?:", var2)   #--->  True
var = "αβθ"
var3 = var.islower()
print ("Is it lowercase only?:", var3)   #--->  True
b = "hello 123"
print(b.islower())                       #--->  True


#   zfill()	        --->	 Fills the string with a specified number of 0 values at the beginning
var = "this is string example....wow!!!"
var1 = var.zfill(40)                    #--->  40 is total length of string
print ("string padded with 0:", var1)   #--->  00000000this is string example....wow!!!
b = "welcome to the jungle"
print(b.zfill(10))                      #--->  welcome to the jungle
c = "10.000"
print(c.zfill(10))                      #--->  000010.000
var=-1234.50
var5=str(var).zfill(10)
print ("zfilled:", var5)                #--->  -0001234.5
var=-1234.50
var5=str.zfill(str(var), 10)
print ("zfilled:", var5)                #--->  -0001234.5


#   removeprefix()  #--->  has been introduced in Python 3.9 version.
                    #It removes the substring if it is found in the beginning, and returns the remaining string.
                    #returns a string after removing the prefix string.
var = 'Explicit is better than implicit'
var1 = var.removeprefix('Ex')
print ("prefix removed:", var1)         #--->  plicit is better than implicit
var = "Explicit is better than implicit"
var2 = var.removeprefix('Explicit is ')
print ("prefix removed:", var2)         #--->  better than implicit
var = 'Explicit is better than implicit'
var3 = var.removeprefix("")
print ("prefix removed:", var3)         #--->  Explicit is better than implicit
var = 'Explicit is better than Explicit'
var3 = var.removeprefix("Ex")
print ("prefix removed:", var3)         #--->  plicit is better than Explicit


#   removesuffix()  #--->  It removes the substring if it is found in the end, and returns the remaining string.
                    #returns a string after removing the suffix string.
var = 'Explicit is better than implicit.'
var1 = var.removesuffix('.')
print ("suffix removed:", var1)         #--->  Explicit is better than implicit
var = "Explicit is better than implicit."
var2 = var.removesuffix(' implicit.')
print ("suffix removed:", var2)         #--->  Explicit is better than 
var = 'Explicit is better than implicit.'
var3 = var.removesuffix("")
print ("suffix removed:", var3)         #--->  Explicit is better than implicit. 
var = 'Explicit is better than implicit.'
var3 = var.removesuffix("cit")
print ("suffix removed:", var3)         #--->  Explicit is better than implicit.


#   encode()	    --->	 Returns an encoded version of the string
#   Encode S using the codec registered for encoding. Default encoding is 'utf-8'.
txt = "My name is Ståle"
x = txt.encode()
print(x)            #--->  b'My name is St\xc3\xe5le'
txt = "My name is Ståle"
#- uses a backslash instead of the character that could not be encoded
print(txt.encode(encoding="ascii",errors="backslashreplace"))  #--->  b'My name is St\\xe5le'
#- ignores the characters that cannot be encoded
print(txt.encode(encoding="ascii",errors="ignore"))            #--->  b'My name is Stle'
#- replaces the character with a text explaining the character
print(txt.encode(encoding="ascii",errors="namereplace"))       #--->  b'My name is St\\N{LATIN SMALL LETTER A WITH RING ABOVE}le'
#- replaces the character with a questionmark
print(txt.encode(encoding="ascii",errors="replace"))           #--->  b'My name is St?le'
#- replaces the character with an xml character
print(txt.encode(encoding="ascii",errors="xmlcharrefreplace")) #--->  b'My name is Ståle'



#   decode(encoding = 'UTF8', errors = 'strict')   --->  Decodes the string using codec registered for encoding.
str= "Hello! Welcome to Tutorialspoint."
str_encoded= str.encode('utf_16','strict')
print(str_encoded)      #--->  b'\xff\xfeH\x00e\x00l\x00l\x00o\x00!\x00 \x00W\x00e\x00l\x00c\x00o\x00m\x00e\x00 \x00t\x00o\x00 \x00T\x00u\x00t\x00o\x00r\x00i\x00a\x00l\x00s\x00p\x00o\x00i\x00n\x00t\x00.\x00'
str_decoded=str_encoded.decode('utf_16', 'strict')
print(str_decoded)      #--->  Hello! Welcome to Tutorialspoint.

str_encoded= str.encode('utf_32','replace')
print(str_encoded)      #--->  b'\xff\xfe\x00\x00H\x00\x00\x00e\x00\x00\x00l\x00\x00\x00l\x00\x00\x00o\x00\x00\x00!\x00\x00\x00 \x00\x00\x00W\x00\x00\x00e\x00\x00\x00l\x00\x00\x00c\x00\x00\x00o\x00\x00\x00m\x00\x00\x00e\x00\x00\x00 \x00\x00\x00t\x00\x00\x00o\x00\x00\x00 \x00\x00\x00T\x00\x00\x00u\x00\x00\x00t\x00\x00\x00o\x00\x00\x00r\x00\x00\x00i\x00\x00\x00a\x00\x00\x00l\x00\x00\x00s\x00\x00\x00p\x00\x00\x00o\x00\x00\x00i\x00\x00\x00n\x00\x00\x00t\x00\x00\x00.\x00\x00\x00'
str_decoded=str_encoded.decode('utf_32', 'replace')
print(str_decoded)      #--->  Hello! Welcome to Tutorialspoint.

str_encoded= str.encode('utf_16_be','backslashreplace')
print(str_encoded)      #--->  b'\x00H\x00e\x00l\x00l\x00o\x00!\x00 \x00W\x00e\x00l\x00c\x00o\x00m\x00e\x00 \x00t\x00o\x00 \x00T\x00u\x00t\x00o\x00r\x00i\x00a\x00l\x00s\x00p\x00o\x00i\x00n\x00t\x00.'
str_decoded=str_encoded.decode('utf_16_be', 'backslashreplace')
print(str_decoded)      #--->  Hello! Welcome to Tutorialspoint.

str_encoded= str.encode()
print(str_encoded)      #--->  b'Hello! Welcome to Tutorialspoint.'
str_decoded=str_encoded.decode()
print(str_decoded)      #--->  Hello! Welcome to Tutorialspoint.



#--------------------------------------
#CAMEL_CASE
# camelcase is a module for pyhton





##########################################################################################################
#REGEX
##########################################################################################################
import re

#Metacharacters or Special Characters
#   .	Dot             - It matches any characters except the newline character.
#   ^	Caret           - It is used to match the pattern from the start of the string. (Starts With)
#   $	Dollar          - It matches the end of the string before the new line character. (Ends with)
#   *	Asterisk        - It matches zero or more occurrences of a pattern.
#   +	Plus            - It is used when we want a pattern to match at least one.
#   ?	Question mark   - It matches zero or one occurrence of a pattern.
#   {}	Curly Braces    - It matches the exactly specified number of occurrences of a pattern
#   []	Bracket         - It defines the set of characters
#   ()  Capture and group
#   |	Pipe            - It matches any of two defined patterns.
#   \	Signals a special sequence (can also be used to escape special characters)	"\d"

#Special Sequences
#   \d	    It matches any digit and is equivalent to [0-9].
#   \D	    It matches any non-digit character and is equivalent to [^0-9].
#   \s	    It matches any white space character and is equivalent to [\t\n\r\f\v]
#   \S	    It matches any character except the white space character and is equivalent to [^\t\n\r\f\v]
#   \w	    It matches any alphanumeric character and is equivalent to [a-zA-Z0-9]
#   \W	    It matches any characters except the alphanumeric character and is equivalent to [^a-zA-Z0-9]
#   \A	    It matches the defined pattern at the start of the string.
#   \b	    r"\bxt"     - It matches the pattern at the beginning of a word in a string.
#           r"xt\b"     - It matches the pattern at the end of a word in a string.
#   \B	    This is the opposite of \b.
#   \Z	    It returns a match object when the pattern is at the end of the string.

#Sets
#A set is a set of characters inside a pair of square brackets [] with a special meaning:
#   [arn]	    Returns a match where one of the specified characters (a, r, or n) is present	
#   [a-n]	    Returns a match for any lower case character, alphabetically between a and n	
#   [^arn]	    Returns a match for any character EXCEPT a, r, and n	
#   [0123]	    Returns a match where any of the specified digits (0, 1, 2, or 3) are present	
#   [0-9]	    Returns a match for any digit between 0 and 9	
#   [0-5][0-9]	Returns a match for any two-digit numbers from 00 and 59	
#   [a-zA-Z]	Returns a match for any character alphabetically between a and z, lower case OR upper case	
#   [+]	        In sets, +, *, ., |, (), $,{} has no special meaning, so [+] means: return a match for any + character in the string

#RegEx Functions:
#   compile     - It is used to turn a regular pattern into an object of a regular expression that may be used in a number of ways for matching patterns in a string.
#   search      - It is used to find the first occurrence of a regex pattern in a given string.
#   match       - It starts matching the pattern at the beginning of the string.
#   fullmatch   - It is used to match the whole string with a regex pattern.
#   split       - It is used to split the pattern based on the regex pattern.
#   findall     - It is used to find all non-overlapping patterns in a string. It returns a list of matched patterns.
#   finditer    - It returns an iterator that yields match objects.
#   sub         - It returns a string after substituting the first occurrence of the pattern by the replacement.
#   subn        - It works the same as 'sub'. It returns a tuple (new_string, num_of_substitution).
#   escape      - It is used to escape special characters in a pattern.
#   purge       - It is used to clear the regex expression cache.


#1. re.compile(pattern, flags=0)
#It is used to create a regular expression object that can be used to match patterns in a string.
import re  
pattern = "amazing" 
text = "This tutorial is amazing!"   

regex_object = re.compile(pattern)          # Createing a regEx object   
match_object = regex_object.search(text)    # Searching for the pattern in the string 
#this two lines is equal to this code:     result = re.search(pattern, string)

print("Match Object:", match_object)    #--->  ???




#2. re.match(pattern, string, flags=0)
#It starts matching the pattern from the beginning of the string.
#Returns a match object if any match is found with information like start, end, span, etc.
#Returns a NONE value in the case no match is found.
import re  
pattern = "hello"    
match = re.match(pattern, "hello world")    # Returns a match object if found else Null  
  
print(match)                    # Printing the match object      --->  ???  
print("Span:", match.span())    # Return the tuple (start, end)  --->  (0, 5)
print("Start:", match.start())  # Return the starting index      --->  0
print("End:", match.end())      # Returns the ending index       --->  5


#example2
import re    
line = "Learn Python through tutorials on javatpoint"    
match_object = re.match( r'.w* (.w?) (.w*?)', line, re.M|re.I)    
    
if match_object:    
    print ("match object group : "  , match_object.group() )    
    print ("match object 1 group : ", match_object.group(1))    
    print ("match object 2 group : ", match_object.group(2))    
else:    
    print ( "There isn't any match!!" )     #--->  ???



#3. re.search(pattern, string, flags=0)
#The re.search() function will look for the first occurrence of a regular expression sequence and deliver it.
import re  
  
line = "Learn Python through tutorials on javatpoint";  
  
search_object = re.search( r' .*t? (.*t?) (.*t?)', line)  
if search_object:  
    print("search object group : "  , search_object.group() )   #--->  Python through tutorials on javatpoint  
    print("search object group 1 : ", search_object.group(1))   #--->  on  
    print("search object group 2 : ", search_object.group(2))   #--->  javatpoint
else:  
    print("Nothing found!!")  
  

#4. re.sub(pattern, repl, string, count=0, flags=0)
#It substitutes the matching pattern with the 'repl' in the string
#Pattern - is simply a regex pattern to be matched
#repl - repl stands for "replacement" which replaces the pattern in string.
#Count - This parameter is used to control the number of substitutions
import re  
pattern = "like"   
repl = "love"  
text = "I like Javatpoint!" 
  
new_text = re.sub(pattern, repl, text)  
  
print("Original text:", text)           #--->  I like Javatpoint!
print("Substituted text: ", new_text)   #--->  I love Javatpoint!

#example2
import re  
pattern = "l"  
repl = "L" 
text = "I like Javatpoint! I also like tutorials!" 
  
new_text = re.sub(pattern, repl, text, 3)  
  
print("Original text:", text)           #--->  I like Javatpoint! I also like tutorials! 
print("Substituted text:", new_text)    #--->  I Like Javatpoint! I aLso Like tutorials!


#5. re.subn(pattern, repl, string, count=0, flags=0)
#Working of subn if same as sub-function
#It returns a tuple (new_string, num_of_substitutions)
import re   
pattern = "l"
repl = "L"  
text = "I like Javatpoint! I also like tutorials!"  
  
new_text = re.subn(pattern, repl, text, 3)  
  
print("Original text:", text)           #--->  I like Javatpoint! I also like tutorials!
print("Substituted text:", new_text)    #--->  ('I Like Javatpoint! I aLso Like tutorials!', 3)


#6. re.fullmatch(pattern, string, flags=0)
#It matches the whole string with the pattern.
#Returns a corresponding match object.
#Returns None in case no match is found.
#On the other hand, the search() function will only search the first occurrence that matches the pattern.
import re   
  
line = "Hello world";    
  
print(re.fullmatch("Hello", line))          #--->  ???
print(re.fullmatch("Hello world", line))    #--->  ???


#7. re.finditer(pattern, string, flags=0)
#Returns an iterator that yields all non-overlapping matches of pattern in a string.
import re   
line = "Hello world. I am Here!";   
pattern = r'[aeiou]'   
iter_ = re.finditer(pattern, line)  
 
for i in iter_:  
    print(i)        #--->  ???

#8. re.split(pattern, string, maxsplit=0, flags=0)
#It splits the pattern by the occurrences of patterns.
#If maxsplit is zero, then the maximum number of splits occurs.
#If maxsplit is one, then it splits the string by the first occurrence of the pattern and returns the remaining string as a final result.    
import re    
pattern = ' '    
line = "Learn Python through tutorials on javatpoint"    
  
# Using split function to split the string after ' '  
result = re.split( pattern, line)   
print("When maxsplit = 0, result:", result)  #--->  ['Learn', 'Python', 'through', 'tutorials', 'on', 'javatpoint']
  
result = re.split(pattern, line, maxsplit=1)  
print("When maxsplit = 1, result =", result) #--->  ['Learn', 'Python through tutorials on javatpoint']


#9. re.escape(pattern)
#It escapes the special character in the pattern.
#The esacpe function become more important when the string contains regular expression metacharacters in it.
import re    
pattern = 'https://www.javatpoint.com/'  
result = re.escape( pattern)   
print("Result:", result)    #--->  Result: https://www\.javatpoint\.com/

#10. re.purge()
#The purge function does not take any argument that simply clears the regular expression cache.
import re  
# Define some regular expressions  
pattern1 = r'\d+'  
pattern2 = r'[a-z]+'  
# Use the regular expressions  
print(re.search(pattern1, '123abc'))  #--->  ???
print(re.search(pattern2, '123abc'))  #--->  ???  
# Clear the regular expression cache  
re.purge()  
# Use the regular expressions again  
print(re.search(pattern1, '456def'))  #--->  ???  
print(re.search(pattern2, '456def'))  #--->  ???  



#----------------------------------------------------------------------------------
#11. re.findall()
#----------------------------------------------------------------------------------
import re
txt = "The rain in Spain"
#----------------------------------------------------------------------------------
x = re.findall("\AThe", txt) #Check if the string starts with "The":
print(x)    #--->  ['The']
if x:
    print("Yes, there is a match!") #--->  Yes, there is a match!
else:
    print("No match")
#-----------------------------------------------------------------------------------
x = re.findall(r"\bain", txt) #Check if "ain" is present at the beginning of a WORD:
print(x)    #--->  []
if x:
  print("Yes, there is at least one match!")
else:
  print("No match") #--->  No match
#-----------------------------------------------------------------------------------
x = re.findall(r"\Bain", txt) #Check if "ain" is present, but NOT at the beginning of a word:
print(x)#--->  ['ain', 'ain']
if x:
  print("Yes, there is at least one match!")    #--->  Yes, there is at least one match!
else:
  print("No match")
#-----------------------------------------------------------------------------------
x = re.findall(r"ain\B", txt) #Check if "ain" is present, but NOT at the end of a word:
print(x)    #--->  []        
if x:
    print("Yes, there is at least one match!")
else:
    print("No match")   #--->  No match
#-----------------------------------------------------------------------------------
x = re.findall("\d", txt)   #Check if the string contains any digits (numbers from 0-9):
print(x)    #--->  []
if x:
    print("Yes, there is at least one match!")
else:
    print("No match")    #--->  No match
#-----------------------------------------------------------------------------------
x = re.findall("\D", txt)
print(x)    #--->  ['T', 'h', 'e', ' ', 'r', 'a', 'i', 'n', ' ', 'i', 'n', ' ', 'S', 'p', 'a', 'i', 'n']
if x:
    print("Yes, there is at least one match!")    #--->  Yes, there is at least one match!
else:
    print("No match")
#-----------------------------------------------------------------------------------
x = re.findall("\s", txt) #Return a match at every white-space character:
print(x)    #--->  [' ', ' ', ' ']
if x:
    print("Yes, there is at least one match!")    #--->  Yes, there is at least one match!
else:
    print("No match")
#-----------------------------------------------------------------------------------
x = re.findall("\S", txt)   #Return a match at every NON white-space character:
print(x)    #--->  ['T', 'h', 'e', 'r', 'a', 'i', 'n', 'i', 'n', 'S', 'p', 'a', 'i', 'n']
if x:
    print("Yes, there is at least one match!")    #--->  Yes, there is at least one match! 
else:
    print("No match")
#-----------------------------------------------------------------------------------
x = re.findall("\w", txt) #Return a match at every word character (characters from a to Z, digits from 0-9, and the underscore _ character):
print(x)  #--->  ['T', 'h', 'e', 'r', 'a', 'i', 'n', 'i', 'n', 'S', 'p', 'a', 'i', 'n']
if x:
    print("Yes, there is at least one match!")  #--->  Yes, there is at least one match! 
else:
    print("No match")
#-----------------------------------------------------------------------------------
x = re.findall("\W", txt)   #Return a match at every NON word character (characters NOT between a and Z. 
                            #Like "!", "?" white-space etc.):
print(x)    #--->  [' ', ' ', ' ']
if x:
    print("Yes, there is at least one match!")    #--->  Yes, there is at least one match!  
else:
    print("No match")
#-----------------------------------------------------------------------------------
x = re.findall("Spain\Z", txt) #Check if the string ends with "Spain":
print(x)    #--->  ['Spain']
if x:
    print("Yes, there is a match!")   #--->  Yes, there is a match!
else:
    print("No match")
#----------------------------------------------------------------------------------
x = re.findall("[arn]", txt)    #Check if the string has any a, r, or n characters:
print(x)    #--->  ['r', 'a', 'n', 'n', 'a', 'n']
if x:
    print("Yes, there is at least one match!")    #--->  Yes, there is at least one match!
else:
    print("No match")
#-----------------------------------------------------------------------------------
x = re.findall("[a-n]", txt)    ##Check if the string has any characters between a and n:
print(x)    #--->  ['h', 'e', 'a', 'i', 'n', 'i', 'n', 'a', 'i', 'n']
if x:
    print("Yes, there is at least one match!")  #--->  Yes, there is at least one match! 
else:
    print("No match")
#----------------------------------------------------------------------------------
x = re.findall("[^arn]", txt) #Check if the string has other characters than a, r, or n:
print(x)    #--->  ['T', 'h', 'e', ' ', 'i', ' ', 'i', ' ', 'S', 'p', 'i']
if x:
    print("Yes, there is at least one match!")    #--->  Yes, there is at least one match!
else:
    print("No match")
#----------------------------------------------------------------------------------
x = re.findall("[0123]", txt) #Check if the string has any 0, 1, 2, or 3 digits:
print(x)    #--->  []
if x:
    print("Yes, there is at least one match!")
else:
    print("No match") #--->  No match  
#----------------------------------------------------------------------------------
txt = "8 times before 11:45 AM"
x = re.findall("[0-9]", txt) #Check if the string has any digits:
print(x)    #--->  ['8', '1', '1', '4', '5']
if x:
    print("Yes, there is at least one match!")    #--->  Yes, there is at least one match!  
else:
    print("No match")
#----------------------------------------------------------------------------------
txt = "8 times before 11:45 AM"
x = re.findall("[0-5][0-9]", txt) #Check if the string has any two-digit numbers, from 00 to 59:
print(x)    #--->  ['11', '45']
if x:
    print("Yes, there is at least one match!")    #--->  Yes, there is at least one match! 
else:
    print("No match")
#----------------------------------------------------------------------------------
txt = "8 times before 11:45 AM"
x = re.findall("[a-zA-Z]", txt) #Check if the string has any characters from a to z lower case, and A to Z upper case:
print(x)    #--->  ['t', 'i', 'm', 'e', 's', 'b', 'e', 'f', 'o', 'r', 'e', 'A', 'M']
if x:
    print("Yes, there is at least one match!")    #--->  Yes, there is at least one match!
else:
    print("No match")
#----------------------------------------------------------------------------------
txt = "8 times before 11:45 AM"
x = re.findall("[+]", txt) #Check if the string has any + characters:
print(x)    #--->  []
if x:
    print("Yes, there is at least one match!")
else:
    print("No match") #--->  No match
#----------------------------------------------------------------------------------





#Match Object
#A Match Object is an object containing information about the search and the result.

#The Match object has properties and methods used to retrieve information about the search, and the result:
#   .span()     returns a tuple containing the start-, and end positions of the match.
#   .string     returns the string passed into the function
#   .group()    returns the part of the string where there was a match

import re
#The search() function returns a Match object:
txt = "The rain in Spain"
x = re.search("ai", txt)
print(x)    #--->  <_sre.SRE_Match object; span=(5, 7), match='ai'>


x = re.search(r"\bS\w+", txt) #Search for an upper case "S" character in the beginning of a word, and print its position:
print(x.span()) #--->  (12, 17)

 
x = re.search(r"\bS\w+", txt)   #The string property returns the search string:
print(x.string) #--->  The rain in Spain


x = re.search(r"\bS\w+", txt) #Search for an upper case "S" character in the beginning of a word, and print the word:
print(x.group())    #--->  Spain




#------------------------------------------------------
#Matching Versus Searching - re.match() vs. re.search()
#The match function looks for a match only where the string starts, whereas the search function looks for a match everywhere in the string.
import re    
line = "Learn Python through tutorials on javatpoint"    
  
# Using match function to match 'through'  
match_object = re.match( r'through', line, re.M|re.I)    
if match_object:    
    print("match object group : ", match_object)    
else:    
    print( "There isn't any match!!")    
  
# using search function to search  
search_object = re.search( r'through', line, re.M|re.I)    
if search_object:    
    print("Search object group : ", search_object)    
else:    
    print("Nothing found!!")  

#--->  ???


#--------------------------------------
#CAMELCASE in regex
from re import sub  
  
# creating a function which will convert string to camelcase  
def convert_to_camelCase(my_string):  
    my_string = sub(r"(_|-)+", " ", my_string).title().replace(" ", "")  
    return my_string[0].lower() + my_string[1:]  
  
# taking example strings   
s1 = "Python javatpoint"  
s2 = "Python,javatpoint"  
s3 = "Python_javatpoint"  
s4 = "python_javatpoint.tutorial-camelcase"  

print("camelCase of s1: ", convert_to_camelCase(s1))  #--->  pythonJavatpoint
print("camelCase of s2: ", convert_to_camelCase(s2))  #--->  python,Javatpoint
print("camelCase of s3: ", convert_to_camelCase(s3))  #--->  pythonJavatpoint
print("camelCase of s3: ", convert_to_camelCase(s4))  #--->  pythonJavatpoint.TutorialCamelcase







##########################################################################################################
#ARRAYS
##########################################################################################################
#There are four collection data types in the Python programming language:
'''
List         is a collection which is ordered and changeable. Allows duplicate members.
Tuple        is a collection which is ordered and unchangeable. Allows duplicate members.
Set          is a collection which is unordered,  unchangeable*, and unindexed. No duplicate members.
Dictionary   is a collection which is ordered** and changeable. No duplicate members.


*Set items are unchangeable, but you can remove and/or add items whenever you like.
**As of Python version 3.7, dictionaries are ordered. In Python 3.6 and earlier, dictionaries are unordered.
'''

##########################################################################################################
#LIST
##########################################################################################################
#empty list
list0=[]

list1  = [1, "hi", "Python", 2]     #--->  index: [0,1,2,3]  
list1[0]    #--->  1
list1[1]    #--->  "hi"
list1[2]    #--->  "Python"
list1[3]    #--->  2

#negative index
list1[-1]   #--->  2 
list1[-2]   #--->  "Python"
list1[-3]   #--->  "hi"
list1[-4]   #--->  1

list1[2][1] #--->  y

#length
print(len(list1))   #--->  4
#list can have data with any type
list1 = ["Rohan", "Physics", 21, 69.75]
list2 = [1, 2, 3, 4, 5]
list3 = ["a", "b", "c", "d"]
list4 = [25.50, True, -55, 1+2j]
List5 = [1,"Ravi",75.50, True]   # list contain from different types of variables (int,string,float,boolean)

#Maximum & Minimum
list1 = [103.23, 675.99, 321.75, 782,782.005, 200.04]  
print(min(list1))       #--->  103.23
print(max(list1))       #--->  782.005
list1 = ["Rohan", "Physics", 21, 69.75]
print(max(list1))       #--->  TypeError: '>' not supported between instances of 'int' and 'str'

#manual change
# single change
list[0] = 2
print (list1)   #--->  [2 , "hi" , "Python" , 2] 
# multi change
list1 = ["a", "b", "c", "d"]
list2 = ['Y', 'Z']
list1[1:3] = list2
print(list1)             #--->  ['a', 'Y', 'Z', 'd']
# multi change with size increase
list1 = ["a", "b", "c", "d"]
list2 = ['X','Y', 'Z']
list1[1:3] = list2
print (list1)            #--->  ['a', 'X', 'Y', 'Z', 'd']
# multi change with size decrease
list1 = ["a", "b", "c", "d"]
list2 = ['Z']
list1[1:3] = list2
print (list1)            #--->  ['a', 'Z', 'd']

# delete 
list1 = ["a", "b", "c", "d"]
del list1[2]
print (list1)       #--->  ['a', 'b', 'd']
list2 = [10,20,30,40,50,60]
del list2[:2]       
print (list2)       #--->  [30,40,50,60]
del list2[1:3]  
print (list2)       #--->  [10,40,50,60]  
del list2[:]
print (list2)       #--->  []

list1  = [1, "hi", "Python", 2]

#Checking type of given list  
print(type(list1))       #--->  <class 'list'> 

#Printing the list1  
print (list1)            #--->  [1, 'hi', 'Python', 2]
  
# slicing  
print (list1[:])         #--->  [1, 'hi', 'Python', 2]
print (list1[0:])        #--->  [1, 'hi', 'Python', 2]   
print (list1[3:])        #--->  [2]
print (list1[:2])        #--->  [2,"hi"]            [0-2)  
print (list1[0:2])       #--->  [1, 'hi']           [0-2)
print (list1[2:-1])      #--->  ['Python']
list2 = [1, 2, 3, 4, 5]
print (list1[2:-1])      #--->  [3, 4]
print(list[-3:])         #--->  [3, 4, 5]
print(list[:-1])         #--->  [1, 2, 3, 4]
print(list[-3:-1])       #--->  [3, 4]
list3 = [1,2,3,4,5,6,7]   
print(list3[1:6:2])      #--->  [2, 4, 6]   



# multi assign
a, b, c, d = [1,2,3,4]
print(a)    #--->  1
print(b)    #--->  2
print(c)    #--->  3        
print(d)    #--->  4
a, b, *c = [1,2,3,4,5]
print(a)    #--->  1
print(b)    #--->  2
print(c)    #--->  [3,4,5] 
a, *b, c = [1,2,3,4,5]
print(a)    #--->  1
print(b)    #--->  [2,3,4]
print(c)    #--->  5

# Concatenation using + operator  
print (list1 + list1)    #--->  [1, 'hi', 'Python', 2, 1, 'hi', 'Python', 2]

# add
L1 = [10,20,30,40]
L2 = ['one', 'two', 'three', 'four']
L3 = L1+L2
print (L3)      #--->  [10, 20, 30, 40, 'one', 'two', 'three', 'four'] <- L3
L1+=L2
print (L1)      #--->  [10, 20, 30, 40, 'one', 'two', 'three', 'four'] <- L1


# repeatation using * operator  
print (list1 * 3)        #--->  [1, 'hi', 'Python', 2, 1, 'hi', 'Python', 2, 1, 'hi', 'Python', 2]

# membership
print (75.50 in L1)      #--->  False
print (20 in L1)         #--->  False

# dedicate sounds alphabet
chars=[]
for ch in 'TutorialsPoint':
   if ch not in 'aeiou':
      chars.append(ch)
print (chars)            #--->  ['T', 't', 'r', 'l', 's', 'P', 'n', 't']


# comprehension
nums = [num for num in range(10) if num % 2 ==0]
print(nums)
chars = [ char for char in 'TutorialsPoint' if char not in 'aeiou']
print (chars)            #--->  ['T', 't', 'r', 'l', 's', 'P', 'n', 't']
squares = [x*x for x in range(1,11)]
print (squares)          #--->  [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
L1 = [10,20,30,40]
L2 = ['one', 'two', 'three', 'four']
L3 = [y for x in [L1, L2] for y in x]
print ("Joined list:", L3)      #--->  [10, 20, 30, 40, 'one', 'two', 'three', 'four']
thislist = ["apple", "banana", "cherry"]
[print(x,end=' ') for x in thislist]    #--->  apple banana cherry 
fruits = ["apple", "banana", "cherry", "kiwi", "mango"]
newlist = [x for x in fruits if "a" in x]
print(newlist)                  #--->  ['apple', 'banana', 'mango']
newlist = [x for x in range(10)]
print(newlist)                  #--->  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
fruits = ["apple", "banana", "cherry", "kiwi", "mango"]
newlist = ['hello' for x in fruits]
print(newlist)                  #--->  ['hello', 'hello', 'hello', 'hello', 'hello']
fruits = ["apple", "banana", "cherry", "kiwi", "mango"]
newlist = [x if x != "banana" else "orange" for x in fruits]
print(newlist)                  #--->  ['apple', 'orange', 'cherry', 'kiwi', 'mango']

Person = ["Piyali", "Hiya", "Rudrashish", "Badsha", "Lipi"]  
newlist = [x for x in Person if "i" in x]  
print(newlist)   #--->  ['Piyali', 'Hiya', 'Rudrashish', 'Lipi']

letters = [ alpha for alpha in 'javatpoint' ]  
print( letters)  #--->  ['j', 'a', 'v', 'a', 't', 'p', 'o', 'i', 'n', 't']

number_list = [ num for num in range(30) if num % 2 != 0]  
print(number_list)  #--->  [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29]
#list comprehension is 3x faster than for loop



#Nested List
list3 = [1,2,[3,4,[5,6,[7,8]]]]
print(list3[0])     #--->  1
print(list3[1])     #--->  2
print(list3[2])     #--->  [3,4,[5,6,[7,8]]]
print(list3[2][0])  #--->  3
print(list3[2][2])   #--->  [5,6,[7,8]]
print(list3[2][2][2])   #--->  [7,8]
print(list3[2][2][2][1])#--->  8

#2D list
list4 = [ 
            [11, 22, 33, 44],
            [55, 66, 77, 88]
        ]
print(list4[1][3])  #--->  88
list5 = [
    [11, 12, 13],
    [14, 15, 16],
    [17, 18, 19]    
]
print(list5[2][2])  #--->  19


#3D list
list6 = [
    [ [1,2], [3,4] ],
    [ [5,6], [7,8] ],
    [ [9,1], [0,1] ]
]
print(list6[2][0][0])   #--->  9
#3D list in Graphic
list7 = [
    [10, [ 100, [90] ]],    #point-1
    [11, [ 100, [90] ]],    #point-2
    [12, [ 100, [90] ]],    #point-3
]
#Coordinates of point-3 ()
print(list6[2][0]   )   #--->  12 (x)
print(list6[2][1][0])   #--->  100 (y)
print(list6[2][1][1])   #--->  90 (z)
print(list6[2][1][1][0])   #--->  90 (z)   


#Nested List Comprehensions
nested_list = [[_ + __ for _ in range(5)] for __ in range(3)]  
print(nested_list)  #--->  [[0, 1, 2, 3, 4], [1, 2, 3, 4, 5], [2, 3, 4, 5, 6]]



# Nested Loops in List Comprehension
list1=[1,2,3]
list2=[4,5,6]
CombLst=[(x,y) for x in list1 for y in list2]
print (CombLst)          #--->  [(1, 4), (1, 5), (1, 6), (2, 4), (2, 5), (2, 6), (3, 4), (3, 5), (3, 6)]

# copy
lst1 = [10, 20]
lst2 = lst1
print (lst1, id(lst1))   #--->  [10, 20] 1677677188288
print (lst2, id(lst2))   #--->  [10, 20] 1677677188288
# reflect (refrence type)
lst1[0]=100
print (lst1, id(lst1))   #--->  [100, 20] 1677677188288
print (lst2, id(lst2))   #--->  [100, 20] 1677677188288

#equal
a = [ 1, 2, "Ram", 3.50, "Rahul", 5, 6]    
b = [ 1, 2, "Ram", 3.50, "Rahul", 5, 6]    
print(a == b)   #--->  True   

# Constructor
# it is also possible to use the list() constructor when creating a new list.
mylist1 = list(("apple", "banana", "cherry"))





##########################################################################################################
#LIST_METHODS
##########################################################################################################
#   count
mylist = [1, 2, 3, 1, 5, 1, 2]
mylist.count(1)   #--->  3
mylist.count(5)   #--->  1
mylist2 = [10, 20/80, 0.25, 10/40, 30, 10, 55]
c = mylist2.count(0.25)
print (c)         #--->  3  (20/80 = 0.25 , 10/40 = 0.25)
d = mylist2.count(10)
print (d)         #--->  2  

#   index
mylist3 = [25, 12, 10, -21, 10, 100]
x = mylist3.index(10)
print (x)   #--->  2      (index of first 10 in list from left)

#   append
list1 = ["a", "b", "c", "d"]
list1.append('e')
print (list1)     #--->  ['a', 'b', 'c', 'd', 'e']
#   To add items from one list to another, a classical iterative solution
L1 = [10,20,30,40]
L2 = ['one', 'two', 'three', 'four']
for x in L2:      #equal to extend
   L1.append(x)
print (L1)        #--->  [10, 20, 30, 40, 'one', 'two', 'three', 'four']
#   to add a list as an item to the other
L1.append(L2)
print(L1)         #--->  [10, 20, 30, 40 , ['one', 'two', 'three', 'four']]

#   insert      
list1 = ["Rohan", "Physics", 21, 69.75]
list1.insert(2, 'Chemistry')
print(list1)      #--->  ['Rohan', 'Physics', 'Chemistry', 21, 69.75]
list1.insert(-1, 'Pass')        #gabl az un andis migozarad
print(list1)      #--->  ['Rohan', 'Physics', 'Chemistry', 21, 'Pass', 69.75]
list1.insertAt("riyadh",0)
print(list1)      #--->  Error-'list' object has no attribute 'insertAt'
list1.insert(len(list1), 3.14)
print(list1)      #--->  ['Rohan', 'Physics', 'Chemistry', 21, 'Pass', 69.75, 3.14]     #equal to append


#   remove
list1 = ["Rohan", "Physics", 21, 69.75]
list1.remove("Physics")     #--->  ['Rohan', 21, 69.75]

#   pop
list2 = [25.50, True, -55, 1+2j]    #--->  [25.5, True, -55, (1+2j)]
list2.pop(2)
print (list2)               #--->  [25.5, True, (1+2j)]
list2.pop()                 #pop the last item
print (list2)               #--->  [25.5, True]

#   Sort
list1 = ['physics', 'Biology', 'chemistry', 'maths']
list1.sort()
print (list1)   #--->  ['Biology', 'chemistry', 'maths', 'physics']
list2 = [10,16, 9, 24, 5]
list2.sort()
print (list2)   #--->  [5, 9, 10, 16, 24]
list3 = ['Physics', 'biology', 'Biomechanics', 'psychology']
list3.sort(key=str.lower)
print (list3)   #--->  ['biology', 'Biomechanics', 'Physics', 'psychology'] ???
def myfunction(x):
   return x%10
list1 = [17, 23, 46, 51, 90]
list1.sort(key=myfunction)
print (list1)   #--->  [90, 51, 23, 46, 17]   ???
def myfunc(n):
  return abs(n - 50)
thislist = [100, 50, 65, 82, 23]
thislist.sort(key = myfunc)
print(thislist)     #--->  [50, 65, 23, 82, 100]   which numbers difference is lower to 50
#   Sort Descending
thislist = ["orange", "mango", "kiwi", "pineapple", "banana"]
thislist.sort(reverse = True)   #nuzuli
print(thislist)   #--->  ['pineapple', 'orange', 'mango', 'kiwi', 'banana']
#By default the sort() method is case sensitive, resulting in all capital letters being sorted before lower case letters
thislist = ["banana", "Orange", "Kiwi", "cherry"]
thislist.sort()
print(thislist)   #--->  ['Kiwi', 'Orange', 'banana', 'cherry']
thislist.sort(key = str.lower)
print(thislist)   #--->  ['banana', 'cherry', 'Kiwi', 'Orange']

#   copy
lst1 = [10, 20]
lst2 = lst1.copy()
print (lst1, id(lst1))   #--->  [10, 20] 1677678705472
print (lst2, id(lst2))   #--->  [10, 20] 1677678706304
#   reflect (it will not reflect)
lst1[0]=100
print (lst1, id(lst1))   #--->  [100, 20] 1677678705472
print (lst2, id(lst2))   #--->  [10, 20] 1677678706304

#   extend
L1 = [10,20,30,40]
L2 = ['one', 'two', 'three', 'four']
L1.extend(L2)
print (L1)               #--->  [10, 20, 30, 40, 'one', 'two', 'three', 'four']
L1.extend(['Kiran', 'Sunil'])
print (L1)               #--->  [10, 20, 30, 40, 'one', 'two', 'three', 'four', 'Kiran', 'Sunil']
thislist = ["apple", "banana", "cherry"]
thistuple = ("kiwi", "orange")
thislist.extend(thistuple)      #--->  you can add any iterable object (tuples, sets, dictionaries etc.).
print(thislist)          #--->  ['apple', 'banana', 'cherry', 'kiwi', 'orange']

#   reverse
list5 = [25, 12, 10, -21, 10, 100]
list5.reverse()
print (list5)           #--->  [100, 10, -21, 10, 12, 25]

#   clear
lst = [25, 12, 10, -21, 10, 100]
lst.clear()              #      The list still remains, but it has no content.
print (lst)              #--->  []   
del lst
print (lst)              #--->  NameError: name 'lst' is not defined. 
                         #      The NameError occurs because "lst" is no longer in the memory.

                      
#   random choice
import random
colors = ["red", "blue", "green"]
print(random.choice(colors))   #--->  blue  (each time we run this code a new random color is choose)  

#example 1
#queue with list
queue = []
def qinput(item, queue):
    queue.append(item)
    
def qoutput(queue):
    queue.pop(0)
    
qinput(1, queue)        
qinput(2, queue)
qinput(3, queue)
qoutput(queue)
qinput(4, queue)
print(queue)    #--->  [2, 3, 4]

#example 2
#stack with list
stack = []
def sinput(item, s):
    s.append(item)

def soutput(s):
    s.pop()
    
sinput(1, stack)
sinput(2, stack)
soutput(stack)
print(stack)    #--->  [1]     





#list of object in Python class
# Python3 code here creating class
class geeks:
	def __init__(self, name, roll):
		self.name = name
		self.roll = roll

# creating list
list = []

# appending instances to list
list.append(geeks('Akash', 2))
list.append(geeks('Deependra', 40))
list.append(geeks('Reaper', 44))
list.append(geeks('veer', 67))

# Accessing object value using a for loop
for obj in list:
	print(obj.name, obj.roll, sep=' ')

print("")
# Accessing individual elements
print(list[0].name)
print(list[1].name)
print(list[2].name)
print(list[3].name)


##########################################################################################################
#TUPLE
##########################################################################################################
#tuple is a sequence of comma separated items, enclosed in parentheses (). The items in a Python tuple 
#need not be of same data type.
#Because of its static structure, the tuple is more efficient than the list.
#In most cases, lists and tuples are equivalent.
#difference between list and tuple
'''
1-Syntax                The syntax of a list differs from that of a tuple. Items of a tuple are enclosed by parentheses or curved brackets (), whereas items of a list are enclosed by square brackets [].
2-Changeability         list ares changeable but tuples are not (mutable vs immutable) 
3-Size Difference       Since tuples are immutable, Python allocates bigger chunks of memory with minimal overhead. allots smaller memory chunks for lists.
4-Available Functions   Tuples have fewer built-in functions than lists.
''' 
#contain different type of values (int,string,float,bool)
T1 = (1,"Ravi",75.50, True)   
T2 = (1, 2, 3, 4, 5)
T3 = ("a", "b", "c", "d")
T4 = (25.50, True, -55, 1+2j)
T5 = ("Rohan", "Physics", 21, 69.75)
T6 = (10,20,"Dev",[2,3,4])  
print(T6)                #--->  (10, 20, 'Dev', [2, 3, 4])

# empty tuple    
empty_tuple = ()    
print(empty_tuple)      #--->  ()

# nested tuple    
nested_tuple = ("Python", {4: 5, 6: 2, 8:2}, (5, 3, 5, 6))    
print(nested_tuple)     #--->  ('Python', {4: 5, 6: 2, 8: 2}, (5, 3, 5, 6))

# tuple without parentheses 
tuple_ = 4, 5.7, "Tuples", ["Python", "Tuples"]    
print(tuple_)           #--->  (4, 5.7, 'Tuples', ['Python', 'Tuples'])    

# single element    
T1 = ("Tuple")    
print( type(T1) )     #--->  <class 'str'>
T2 = ("Tuple",)    
print( type(T2) )     #--->  <class 'tuple'>        
T3 = "Tuple",    
print( type(T3) )     #--->  <class 'tuple'>      


tup  = (1 , "hi", "Python", 2) 

tup[0]    #--->  1
tup[1]    #--->  "hi"
tup[2]    #--->  "Python"
tup[3]    #--->  2

tup[-1]    #--->  2
tup[-2]    #--->  "Python"
tup[-3]    #--->  "hi"
tup[-4]    #--->  1

# Checking type of tup  
print (type(tup))         #--->  <class 'tuple'>   
  
#Printing the tuple  
print (tup)               #--->  (1, 'hi', 'Python', 2)
  
# slicing  (Subtuple)
print (tup[1:])        #--->  ('Python', 2)
print (tup[1:3])       #--->  ('hi', 'Python')
print (tup[0:1])       #--->  (1)
print (tup[:])         #--->  (1, 'hi', 'Python', 2)
print (tup[0:])        #--->  (1, 'hi', 'Python', 2)   
print (tup[3:])        #--->  (2)
print (tup[:2])        #--->  (1, 'hi')            [0-2)  
print (tup[0:2])       #--->  (1, 'hi')            [0-2)
print (tup[2:-1])      #--->  ('Python')
print (tup[2:-1])      #--->
print (tup[-3:])       #--->   
print (tup[:-1])       #---> 
print (tup[:-3])       #---> 
print (tup[-3:-1])     #--->  
list3 = [1,2,3,4,5,6,7]   
print(tup[1:6:2])      #--->  [2, 4, 6]   


# concatenation (using + operator)  join
print (tup + tup)         #--->  ('hi', 'Python', 2, 'hi', 'Python', 2)
T1+=T2                    #--->  T1 = T1 + T2
print(tup + (4, 5, 6))    #--->  ('hi', 'Python', 2, 4, 5, 6)
  
# repatation (using * operator)  
print (tup * 3)           #--->  ('hi', 'Python', 2, 'hi', 'Python', 2, 'hi', 'Python', 2)
  
# membership
print(3 in (1, 2, 3))     #--->  True  
print(3 in tup)           #--->  False  

# Index     (Returns the lowest index in tuple that obj appears)
print (tup.index(2))      #--->  3

# index of a nested tuple   
tup3 = ("Tuple", [4, 6, 2, 6], (6, 2, 6, 7))    
print(tup3[0][3])      #--->  l     
print(tup3[1][1])      #--->  6

#the null data type (defined by the None Keyword.)
tup5 = (None, 1, 2)    #--->  (None, 1, 2)
print(tup5)

# Update (change) 
#it is not possible to update a tuple. Therefore, the tuple class doesn't provide methods for adding,
#inserting, deleting, sorting items from a tuple object
#Using the list() function, convert the tuple to a list, perform the desired append/insert/remove operations
#and then parse the list back to tuple object.

# direct way
tup[2] = "hi"             #--->  TypeError: 'tuple' object does not support item assignment

# convert way
tup1 = ("a", "b", "c", "d")
print (id(tup1))        #--->  2295023084192
list1 = list(tup1)      # convert tuple to list
list1[2]='F'
list1.append('Z')
list1.sort()
tup1 = tuple(list1)     # reconvert list to tuple
print (tup1)            #--->  ('F', 'Z', 'a', 'b', 'd')
print (id(tup1))        #--->  2295021518128

# change nested value
tup4 = ("Python", "Tuple", "Ordered", "Immutable", [1,2,3,4])    
tup4[-1][2] = 10 
print(tup4)            #--->  ('Python', 'Tuple', 'Ordered', 'Immutable', [1, 2, 10, 4])

# extend  (add elements from one list to another)
#we need cast the two tuple objects to lists, extend so as to add elements from one list to another, 
#and convert the joined list back to a tuple.
T1 = (10,20,30,40)
T2 = ('one', 'two', 'three', 'four')
L1 = list(T1)   #convert T1 to List
L2 = list(T2)   #convert T2 to List
L1.extend(L2)   #extend two lists
T1 = tuple(L1)  #reconvert to tuple
print ("Joined Tuple:", T1)

# Add
x = 5
T2 += (x,)

# Count     (Returns count of how many times obj occurs in tuple)	
print (tuple.count(2))    #--->  1  
Tup1 = (10, 20/80, 0.25, 10/40, 30, 10, 55)
print ("Tup1:", tup1)
c = tup1.count(0.25)
print ("count of 10:", c)

#example
#find unique numbers in a given tuple
T1 = (1, 9, 1, 6, 3, 4, 5, 1, 1, 2, 5, 6, 7, 8, 9, 2)
T2 = ()
for x in T1:
   if x not in T2:
      T2+=(x,)
print ("Unique numbers:", T2)   #--->  (1, 9, 6, 3, 4, 5, 2, 7, 8)

# sum   
T1 = (10,20,30,40)
T2 = ('one', 'two', 'three', 'four')
T3 = sum((T1, T2), ())
print ("Joined Tuple:", T3)   #--->  (10, 20, 30, 40, 'one', 'two', 'three', 'four')

# comprehension
T1 = (10,20,30,40)
T2 = ('one', 'two', 'three', 'four')
L1, L2 = list(T1), list(T2)
L3 = [y for x in [L1, L2] for y in x]
T3 = tuple(L3)
print ("Joined Tuple:", T3)

# for loop
T1 = (10,20,30,40)
T2 = ('one', 'two', 'three', 'four')
for t in T2:
   T1+=(t,)
print (T1)      #--->  (10, 20, 30, 40, 'one', 'two', 'three', 'four')

tup1 = (25, 12, 10, -21, 10, 100)
indices = range(len(tup1))
for i in indices:
   print ("tup1[{}]: ".format(i), tup1[i])      #--->  tup1[0]: 25 
                                                #      tup1 [1]: 12 
                                                #      tup1 [2]: 10 
                                                #      tup1 [3]: -21
                                                #      tup1 [4]: 10 
                                                #      tup1 [5]: 100
   
   
# Unpack Tuple Items
tup1 = (10,20,30)
x, y, z = tup1
print ("x: ", x, "y: ", "z: ",z)    #---> x: 10 y: 20 z: 30
print (type (tup1))                 #--->  <class 'tuple'>

tup2 = (10,20,30)
x, y = tup2         #--->  ValueError: too many values to unpack (expected 2)
x, y, p, q = tup2   #--->  ValueError: not enough values to unpack (expected 4, got 3)

tup3 = (10, 20, 30, 40, 50, 60)
x, *y, z = tup3                      # the "*" symbol is used for unpacking
print ("x: ",x, "y: ", y, "z: ", z)  #--->  x: 10 y: [20, 30, 40, 50] z: 60
   
# size
L1  = ["Python", "Lists", "Tuples", "Differences"]  
T1  = ("Python", "Lists", "Tuples", "Differences") 
print("Size of list: ",   L1.__sizeof__())       #--->  72   
print("Size of tuple: ",  T1.__sizeof__())       #--->  56
print(sys.getsizeof(L1))    #--->  ???
print(sys.getsizeof(T1))    #--->  ???
dir(L1)                       #--->  ['__add__', '__class__', '__class_getitem__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']
print( dir(T1), end = ", " )  #--->  ['__add__', '__class__', '__class_getitem__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'count', 'index']
   
# constructor
#It is also possible to use the tuple() constructor to make a tuple.
T2 = tuple(("apple", "banana", "cherry"))
print(T2)              #--->  ('apple', 'banana', 'cherry')  


# delete
#direct way
del tup[3]                #--->  'tuple' object does not support item deletion  

#convert way
T3 = ("apple", "banana", "cherry")
y = list(T3)
y.remove("apple")
T3 = tuple(y)
print(T3)                 #--->  ('banana', 'cherry')

#complete delete
del T3  
print(T3)             #--->  NameError - name 'T3' is not defined




##########################################################################################################
#SET
##########################################################################################################
#The data type's unordered collection
#it is not an ordered collection
#items in set not accessible by its positional index
#Objects in a set can be of any data type.
s1 = {"Rohan", "Physics", 21, 69.75}
s2 = {1, 2, 3, 4, 5}
s3 = {"a", "b", "c", "d"}
s4 = {25.50, True, -55, 1+2j}

s1 = {["Rohan", "Physics"], 21, 69.75}  #--->  TypeError



#list in set
s0 = {1, 2, [3, 4, 5], 3,0, 1, 9}
print (s0)                  #--->  TypeError: unhashable type: 'list'

#dictionary in set
s0 = {"Rohan", {"phy":50}}
print (s0)                  #--->  TypeError: unhashable type: 'dict'

#Creating Empty set  
set1 = set()  

set2 = set(["one", "two", "three"])
print(set2)     #--->  {'three', 'one', 'two'}
  
set3 = {}                    # Empty curly braces will create dictionary  
print(type(set3))            #--->  <class 'dict'>
 
  
set2 = {'James', 2, 3,'Python'}  

#size of set in memory
print(s0.__sizeof__())
  
#number of objects in set
print(len(s0))
  
#Printing Set value  
print(set2)                  #--->  {3, 'Python', 'James', 2}
  
# Adding element to the set  
set2.add(10)  
print(set2)                  #--->  {'Python', 'James', 3, 2, 10}
lang1 = {"C", "C++", "Java", "Python"}
lang1.add("Golang")
print (lang1)                #--->  {'Python', 'C', 'Golang', 'C++', 'Java'}

#update
lang1 = {"C", "C++", "Java", "Python"}
lang2 = {"PHP", "C#", "Perl"}
lang1.update(lang2)
print (lang1)                #--->  {'Python', 'Java', 'C', 'C#', 'PHP', 'Perl', 'C++'}
  
#The update() method also accepts any sequence object as argument.
lang1 = {"C", "C++", "Java", "Python"}
lang2 = ("PHP", "C#", "Perl")   #a tuple is the argument for update() method.
lang1.update(lang2)
print (lang1)                #--->  {'Java', 'Perl', 'Python', 'C++', 'C#', 'C', 'PHP'}
  
#example
set1 = set("Hello")
set1.update("World")
print (set1)                 #--->  {'H', 'r', 'o', 'd', 'W', 'l', 'e'}

#Removing element from the set  
set2.remove(2)  
print(set2)                  #--->  {'Python', 'James', 3, 10}

#collection of distinct objects
s2 = {1, 2, 3, 4, 5, 3,0, 1, 9}
s3 = {"a", "b", "c", "d", "b", "e", "a"}
print (s2)                   #--->  {0, 1, 2, 3, 4, 5, 9}
print (s3)                   #--->  {'a', 'b', 'd', 'c', 'e'}

#for loop in set
langs = {"C", "C++", "Java", "Python"}
for lang in langs:
   print (lang)             #--->  Python
                            #      C
                            #      C++
                            #      Java
   
#example
s1={1,2,3,4,5}
s2={4,5,6,7,8}
for x in s2:
   s1.add(x)
print (s1)                  #--->  {1, 2, 3, 4, 5, 6, 7, 8}   
   
#membership
print ("PHP"  in langs)     #--->  False
print ("Java" in langs)     #--->  True



#union
lang1 = {"C", "C++", "Java", "Python"}
lang2 = {"PHP", "C#", "Perl"}
lang3 = lang1.union(lang2)
print (lang3)               #--->  {'C#', 'Java', 'Perl', 'C++', 'PHP', 'Python', 'C'}

#If a sequence object is given as argument to union() method, Python automatically converts it to
#a set first and then performs union.
lang1 = {"C", "C++", "Java", "Python"}
lang2 = ["PHP", "C#", "Perl"]
lang3 = lang1.union(lang2)
print (lang3)               #--->  {'PHP', 'C#', 'Python', 'C', 'Java', 'C++', 'Perl'}



#remove
lang1 = {"C", "C++", "Java", "Python"}
lang1.remove("Java")
print(lang1)                #--->  {'C', 'C++', 'Python'}
lang1.remove("PHP")         #--->  KeyError: 'PHP'

#remove vs discard
#If the key to be deleted from the set using discard() doesn't exist in the set, the Python will not give the 
#error. The program maintains its control flow.
#On the other hand, if the item to be deleted from the set using remove() doesn't exist in the set, the Python
#will raise an error.


#discard
#The discard() method in set class is similar to remove() method. The only difference is, it doesn't raise
#error even if the object to be removed is not already present in the set collection.
lang1 = {"C", "C++", "Java", "Python"}
lang1.discard("C++")
print (lang1)               #--->  {'Java', 'Python', 'C'}
lang1.discard("PHP")
print (lang1)               #--->  {'Java', 'Python', 'C'}



#pop
lang1 = {"C", "C++"}
obj = lang1.pop()
print (obj)                 #--->  C++
print (lang1)               #--->  {'C'}
obj = lang1.pop()
obj = lang1.pop()           #--->  KeyError: 'pop from an empty set'



#clear
#The clear() method in set class removes all the items in a set object, leaving an empty set.
lang1 = {"C", "C++", "Java", "Python"}
lang1.clear()
print (lang1)               #--->  set()


#difference update
#The difference_update() method in set class updates the set by removing items that are common between itself and another set given as argument.
s1 = {1,2,3,4,5}
s2 = {4,5,6,7,8}
s1.difference_update(s2)
print (s1)                  #--->  {1, 2, 3}


#difference
#it returns a new set object that contains the difference of the two existing sets.
s1 = {1,2,3,4,5}
s2 = {4,5,6,7,8}
s3 = s1.difference(s2)      #s3 = s1-s2
s3 = s1 - s2                #correct
print (s3)                  #--->  {1, 2, 3}


#intersection update
s1 = {1,2,3,4,5}
s2 = {4,5,6,7,8}
s1.intersection_update(s2)
print (s1)                  #--->  {4, 5}


#intersection
s1 = {1,2,3,4,5}
s2 = {4,5,6,7,8}
s3 = s1.intersection(s2)    #s3 = s1 & s2
s3 = s1 & s2                #correct
print (s3)                  #--->  {4, 5}


#symmetric difference update
s1 = {1,2,3,4,5}
s2 = {4,5,6,7,8}
s1.symmetric_difference_update(s2)  #A Δ B = (A − B) ⋃ (B − A)
print (s1)                  #--->  {1, 2, 3, 6, 7, 8}


#symmetric difference (delta)
s1 = {1,2,3,4,5}
s2 = {4,5,6,7,8}
s3 = s1.symmetric_difference(s2)    #s1 = s1^s2         A Δ B = (A − B) ⋃ (B − A)
s3 = s1 ^ s2
print (s3)                          #--->  {1, 2, 3, 6, 7, 8}

#union
#the "|" Operator
s1={1,2,3,4,5}
s2={4,5,6,7,8}
s3 = s1|s2
s3 = s1.union(s2)
print (s3)                  #--->  {1, 2, 3, 4, 5, 6, 7, 8}


#unpacking
s1={1,2,3,4,5}
s2={4,5,6,7,8}
s3 = {*s1, *s2}
print (s3)                  #--->  {1, 2, 3, 4, 5, 6, 7, 8}
se1 , se2 = {*s1}           #--->  ValueError: too many values to unpack (expected 2)
se3 , *se4 = {s1}           #--->  TypeError: unhashable type: 'set'
se5 , *se6 = {*s1}
print (se5)                 #--->  1
print (se6)                 #--->  [2, 3, 4, 5]


#copy
lang1 = {"C", "C++", "Java", "Python"}
lang2 = lang1.copy()
print(lang2)                #--->  {'Python', 'Java', 'C', 'C++'}


#id
lang1 = {"C", "C++", "Java", "Python"}
print (id(lang1))           #--->  2451578196864
lang2 = lang1.copy()
print (id(lang2))           #--->  2451578197312
lang1.add("PHP")
print (id(lang1))           #--->  2451578196864
print (id(lang2))           #--->  2451578197312


#isdisjoint()        Return True if two sets have a null intersection.
#The isdisjoint() method returns True if none of the items are present in both sets, otherwise it returns False.
x = {"apple", "banana", "cherry"}
y = {"google", "microsoft", "facebook"}
print(x.isdisjoint(y))      #--->  True

x = {"apple", "banana", "cherry"}
y = {"google", "microsoft", "apple"}
print(x.isdisjoint(y))      #--->  False




#issubset()          Return True if another set contains this set.
s1={1,2,3,4,5}
s2={4,5}
if s2.issubset(s1):
   print ("s2 is a subset of s1")   #--->  s2 is a subset of s1
   
   	
#issuperset()        Return True this set contains another set.
#The issuperset() method returns True if all items in the specified set exists in the original set, otherwise it returns False.
x = {"f", "e", "d", "c", "b", "a"}
y = {"a", "b", "c"}
print(x.issuperset(y))      #--->  True

x = {"f", "e", "d", "c", "b"}
y = {"a", "b", "c"}
print(x.issuperset(y))      #--->  False


#Comprehension
set1 = {0, 1, 2, 3, 4}
set2 = {3, 4, 5, 6}
print({item for item in set1 if item not in set2})  #--->  ???



#comparisons
'''
==
!=
<
<=
>
>=
'''

Days1 = {"Monday",  "Tuesday", "Wednesday", "Thursday"}    
Days2 = {"Monday", "Tuesday"}    
Days3 = {"Monday", "Tuesday", "Friday"}    
#Days1 is the superset of Days2 hence it will print true.     
print (Days1 > Days2)         #--->  True     
#prints false since Days1 is not the subset of Days2     
print (Days1 < Days2)         #--->  False
#prints false since Days2 and Days3 are not equivalent     
print (Days2 == Days3)      #--->  False

print (Days1 >= Days2)         #--->  True     
   
print (Days1 <= Days2)         #--->  False


#constructor
#It is also possible to use the set() constructor to make a set.
s5 = set(["Peter","Joseph", 65,59,96])  
s6  = set(["Peter",1,2,"Joseph"])  


#delete
#The del keyword will delete the set completely:
del s6
print(s6)                   #--->  NameError: name 's6' is not defined


#------------------------------------------------
#FrozenSets
#a frozen set is an immutable version of the set data type.
#It is similar to a set, but its contents cannot be changed once a frozen set is created.
#They can be used the same way as sets, except they cannot be modified
#Because they are immutable, frozen set objects can be used as elements of other sets or dictionary keys, while standard sets cannot.
#they are hashable, meaning they can be used as keys in dictionaries or as elements of other sets.
#Their contents cannot change, so their hash values remain constant.
#Standard sets are not hashable because they can be modified, so their hash values can change.
#They also support operations that do not modify the frozen set, such as len(), min(), max(), and in.

Frozenset = frozenset([1,2,3,4,5])     
print(type(Frozenset))      #--->  <class 'frozenset'>
Frozenset.add(6)            #--->  AttributeError: 'frozenset' object has no attribute 'add'


#Frozenset for the dictionary
Dictionary1 = {"Name":"John", "Country":"USA", "ID":101}     
myKeys = frozenset(Dictionary1)

print(type(Dictionary))             #--->  <class 'dict'>
FS1 = frozenset(Dictionary);  #Frozenset will contain the keys of the dictionary    
print(type(FS1))              #--->  <class 'frozenset'>
for i in FS1:     
    print(i)                  #--->  Name  
                              #      Country
                              #      ID




##########################################################################################################
#DICTIONARY
##########################################################################################################
#Python's dictionary is example of mapping type
#Two parts of pair are key (word) and value (meaning).
#Similarly, Python dictionary is also a collection of key:value pairs.
#The pairs are separated by comma and put inside curly brackets {}.
#To establish mapping between key and value, the colon ':' symbol is put between the two.
#As of Python version 3.7, dictionaries are ordered. In Python 3.6 and earlier, dictionaries are unordered.

capitals = {"India":"Delhi", "Iraq":"Baghdad", "Iran":"Tehran", "Turkey":"Ankara"}
numbers  = {10:"Ten", 20:"Twenty", 30:"Thirty",40:"Forty"}
marks    = {"Savita":67, "Salman":88, "Laxman":91, "David":49} 
capitals2= {"USA":"New York", "France":"Paris", "Japan":"Tokyo", "India":"New Delhi"}
numbers2 = {1:"one", 2:"Two", 3:"three",4:"four"}
points   = {"p1":(10,10), "p2":(20,20)}
Employee = {"Name": "John", "Age": 29,"Company":"WIPRO", [100,201,301]:"Department ID"} #TypeError: unhashable type: 'list'
student = dict(name = "Ali", age = 23, mark = 88)
print(student) #--->  {'name': 'Ali', 'age': 23, 'mark': 88}

#empty dictionary
d1 = dict()             #use constructor
d2 = {}                 #without constructor  
print ('d1: ', d1)      #--->  d1: {}
print ('d2: ', d2)      #--->  d2: {}


#printing
d1 = {1:'Jimmy', 2:'Alex', 3:'john', 4:'mike'} 
d2 = {"Fruit":["Mango","Banana"], "Flower":["Rose", "Lotus"]}
d3 = {["Mango","Banana"]:"Fruit", "Flower":["Rose", "Lotus"]}
d4 = {('India, USA'):'Countries', ('New Delhi', 'New York'):'Capitals'}
print (d1)   #--->  {1: 'Jimmy', 2: 'Alex', 3: 'john', 4: 'mike'}
print (d2)   #--->  {'Fruit': ['Mango', 'Banana'], 'Flower': ['Rose', 'Lotus']}
print (d3)   #--->  TypeError - unhashable type: 'list'
print (d4)   #--->  {'India, USA': 'Countries', ('New Delhi', 'New York'): 'Capitals'}  ???
print (len(d1)) #--->   4
print (len(d2)) #--->   2
print (len(d3)) #--->   TypeError
print (len(d4)) #--->   ???



#assign a value to more than one keys
d1 = {"Banana":"Fruit", "Rose":"Flower", "Lotus":"Flower", "Mango":"Fruit"}
print (d1)   #--->  {'Banana': 'Fruit', 'Rose': 'Flower', 'Lotus': 'Flower', 'Mango': 'Fruit'}
#a key cannot appear more than once in a dictionary.
d2 = {"Fruit":"Banana","Flower":"Rose", "Fruit":"Mango", "Flower":"Lotus"}
print (d2)   #--->  {'Fruit': 'Mango', 'Flower': 'Lotus'} 


#Any Method
#returns True indeed if one dictionary key does have a Boolean expression that evaluates to True.
dict = {1: "Ayan", 2: "Bunny", 3: "Ram", 4: "Bheem"}  
any({'':'','':'','3':''})   #--->  True

#All Method
#only returns True if each of the dictionary's keys contain a True Boolean value.
dict = {1: "Ayan", 2: "Bunny", 3: "Ram", 4: "Bheem"}  
all({1:'',2:'','':''})      #--->  False

#Sorted Method
#Sort by key 
#returns an ordered series of the dictionary's keys. The ascending sorting has no effect on the original Python dictionary.
dict = {7: "Ayan", 5: "Bunny", 8: "Ram", 1: "Bheem"}  
sorted(dict)                #--->  [ 1, 5, 7, 8] 
#Sort by value
d3 = dict(sorted(d3.items(), key=operator.itemgetter(1)))
#way-2
#d3 = {k: v for k, v in sorted(d3.items(), key=lambda item: item[1])}


#setdefault
#is similar to get(), but will set dict[key]=default if key is not already in dict.
dict = {'Name': 'Zara', 'Age': 7}
print("Value : %s" % dict.setdefault('Age', None))  #--->  Value : 7
print("Value : %s" % dict.setdefault('Sex', None))  #--->  Value : None

#has_key Method
#returns true if a given key is available in the dictionary, otherwise it returns a false.
dict = {'Name': 'Zara', 'Age': 7}
print("Value : %s" % dict.has_key('Age'))    #--->  True
print("Value : %s" % dict.has_key('Sex'))    #--->  False


#fromkeys() Method
#creates a new dictionary with keys from seq and values set to value.
x = ('key1', 'key2', 'key3')
y = 100
thisdict = dict.fromkeys(x, y)
print(thisdict)     #--->  {'key1': 100, 'key2': 100, 'key3': 100}

x = ('key1', 'key2', 'key3')
thisdict = dict.fromkeys(x)
print(thisdict)     #--->  {'key1': None, 'key2': None, 'key3': None}


#Accesing value using keys  
d = {1:'Jimmy', 2:'Alex', 3:'john', 4:'mike'} 
print(d[1])        #--->  Jimmy
print(d[4])        #--->  mike
print(d[5])        #--->  KeyError: '5'
#Unlike the "[]" operator, the get() method doesn't raise error if the key is not found; it return None.
print(d.get(2))    #--->  Alex
print(d.get(6))    #--->  None
#The get() method accepts an optional string argument. If it is given, and if the key is not found, this string becomes the return value.
print(d.get(7, 'Not found'))   #--->  Not found
#we can see keys and values separated
print(d.keys())    #--->  dict_keys([1, 2, 3, 4])
print(d.values())  #--->  dict_values(['Jimmy', 'Alex', 'john', 'mike'])
print(d.items())   #--->  dict_items([(1, 'Jimmy'), (2, 'Alex'), (3, 'john'), (4, 'mike')])


#Accesing items
numbers = {10:"Ten", 20:"Twenty", 30:"Thirty",40:"Forty"}
obj = numbers.items()           
print (type(obj))               #--->  <class 'dict_items'>
print (obj)                     #--->  dict_items([(10, 'Ten'), (20, 'Twenty'), (30, 'Thirty'), (40, 'Forty')])
numbers.update({50:"Fifty"})    #update numbers dictionary
print ("automatically updated") #obj will automatically updated   
print (obj)                     #--->  dict_items([(10, 'Ten'), (20, 'Twenty'), (30, 'Thirty'), (40, 'Forty'), (50, 'Fifty')])

#Accesing keys
obj2 = numbers.keys()
print (type(obj2))              #--->  <class 'dict_keys'>
print (obj2)                    #--->  dict_keys([10, 20, 30, 40, 50])
numbers.update({60:"Sixty"})    #update numbers dictionary
print ("automatically updated") #obj2 will updated automatically
print (obj2)                    #--->  dict_keys([10, 20, 30, 40, 50, 60])

#Accesing values 
obj3 = numbers.values()                  
print (type(obj3))              #--->  <class 'dict_values'>   
print (obj3)                    #--->  dict_values(['Ten', 'Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty'])
numbers.update({70:"Seventy"})  #update numbers dictionary
print ("automatically updated") #
print (obj3)                    #--->  dict_values(['Ten', 'Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy'])




#Assign (Change)
d1[4] = 'Zara'
print(d1)          #--->  {1: 'Jimmy', 2: 'Alex', 3: 'john', 4: 'Zara'}  
d1[4] += ' Zarcosani'
print(d1)          #--->  {{1: 'Jimmy', 2: 'Alex', 3: 'john', 4: 'Zara Zarcosani'}  }  

#example
d1 = {"one":11, "two":22, "three":33, "four":44, "five":55}
keys = ['two', 'five']
d2={}
for k in keys:
   d2[k]=d1[k]
print (d2)      #--->  {'two': 22, 'five': 55}


#Union
d2 = {'a': 2, 'b': 4, 'c': 30}
d3 = {'a1': 20, 'b1': 40, 'c1': 60}
d4=d2|d3 
print (d3)   #--->  {'a': 2, 'b': 4, 'c': 30, 'a1': 20, 'b1': 40, 'c1': 60}
d2|=d3
print (d1)   #--->  {'a': 2, 'b': 4, 'c': 30, 'a1': 20, 'b1': 40, 'c1': 60}


#Dictionary from List of Tuples
d1 = dict([('a', 100), ('b', 200)])
d2 = dict((('a', 'one'), ('b', 'two')))
print (d1)      #--->  {'a': 100, 'b': 200}
print (d2)      #--->  {'a': 'one', 'b': 'two'}


#Dictionary from Keyword Arguments
#The dict() function can take any number of keyword arguments with name=value pairs
d1 = dict(a= 100, b=200)
d2 = dict(a='one', b='two')
print (d1)      #--->  {'a': 100, 'b': 200}
print (d2)      #--->  {'a': 'one', 'b': 'two'}


#Add
#if its key is not available in the dictionary, hence a new key-value pair is added.
marks = {"Savita":67, "Ilga":88, "Laxman":91, "David":49}
marks['Chris'] = 74
print (marks)   #--->  #--->  {'Savita': 67, 'Ilga': 88, 'Laxman': 91, 'David': 49, 'Chris': 74}       


#Update
marks  = {"Savita":67, "Imtiaz":88, "Laxman":91, "David":49}
marks1 = {"Sharad": 51, "Mushtaq": 61, "Laxman": 89}
marks.update(marks1)
print(marks)   #--->  {'Savita': 67, 'Imtiaz': 88, 'Laxman': 89, 'David': 49, 'Sharad': 51, 'Mushtaq': 61}
marks1.update({"Laxman": 2020})
print(marks1)  #--->  {'Sharad': 51, 'Mushtaq': 61, 'Laxman': 2020}


#Update with list or tuple
marks  = {"Savita":67, "Imtiaz":88, "Laxman":91, "David":49}
marks1 = [("Sharad", 51), ("Mushtaq", 61), ("Laxman", 89)]
marks.update(marks1)
print (marks)   #--->   {'Savita': 67, 'Imtiaz': 88, 'Laxman': 89, 'David': 49, 'Sharad': 51, 'Mushtaq': 61}


#Update with Keyword Arguments
marks = {"Savita":67, "Imtiaz":88, "Laxman":91, "David":49}
marks.update(Sharad = 51, Mushtaq = 61, Laxman = 89)
print (marks)   #--->  {'Savita': 67, 'Imtiaz': 88, 'Laxman': 89, 'David': 49, 'Sharad': 51, 'Mushtaq': 61}


#Example
#Python program to remove keys with same values in a dictionary.
d1 = {"one":"eleven", "2":2, "three":3, "11":"eleven", "four":44, "two":2}
vals = list(d1.values())#all values
uvals = [v for v in vals if vals.count(v)==1]#unique values
d2 = {}
for k,v in d1.items():
   if v in uvals:
      d = {k:v}
      d2.update(d)
print ("dict with unique value:",d2)    #--->  {'three': 3, 'four': 44}


#Unpack
marks  = {"Savita":67, "Imtiaz":88, "Laxman":91, "David":49}
marks1 = {"Sharad": 51, "Mushtaq": 61, "Laxman": 89}
newmarks = {**marks, **marks1}
print (newmarks)    #--->  {'Savita': 67, 'Imtiaz': 88, 'Laxman': 89, 'David': 49, 'Sharad': 51, 'Mushtaq': 61}
newmarks = {*marks, *marks1}
print (newmarks)    #--->  {'Imtiaz', 'Savita', 'Sharad', 'Mushtaq', 'David', 'Laxman'}
newmarks2 = {*marks}
print (newmarks2)   #--->  {'David', 'Savita', 'Imtiaz', 'Laxman'}
newmarks3 = {marks}
print (newmarks2)   #--->  TypeError - unhashable type: 'dict'


#Delete
numbers = {10:"Ten", 20:"Twenty", 30:"Thirty",40:"Forty"}
del numbers[20]
print (numbers)     #--->  {10: 'Ten', 30: 'Thirty', 40: 'Forty'}
del numbers
print (numbers)     #--->  NameError - name 'numbers' is not defined

#Pop
numbers = {10:"Ten", 20:"Twenty", 30:"Thirty",40:"Forty"}
val = numbers.pop(20)
print (numbers)     #--->  {10: 'Ten', 30: 'Thirty', 40: 'Forty'}
print (val)         #--->  Twenty
val2 = numbers.popitem()           # It pops out the last inserted key-value pair, and returns the same as a tuple
print (numbers)     #--->  {10: 'Ten', 30: 'Thirty'}
print (val2)        #--->  (40, 'Forty')


#Clear
numbers.clear()     #It is mainly used to delete all the items of the dictionary.
print (numbers)     #--->  {}


#Loop
numbers = {10:"Ten", 20:"Twenty", 30:"Thirty",40:"Forty"}
for x in numbers:
    print (x,":",numbers[x]) #--->  10 : Ten
                             #      20 : Twenty
                             #      30 : Thirty
                             #      40 : Forty

for x in numbers.items():
    print (x)               #--->  (10, 'Ten')
                            #      (20, 'Twenty')
                            #      (30, 'Thirty')
                            #      (40, 'Forty')
       
for x,y in numbers.items():
    print (x, y)            #--->  10 Ten
                            #      20 Twenty
                            #      30 Thirty
                            #      40 Forty

for x in numbers.values():        
    print(x)                #--->  Ten
                            #      Twenty
                            #      Thirty
                            #      Forty    
       
for x in numbers.keys():
    print (x, ":", numbers[x]) #--->  10 : Ten
                               #      20 : Twenty
                               #      30 : Thirty
                               #      40 : Forty     
       
l = len(numbers)
for x in range(l):
    print (list(numbers.keys())[x], ":", list(numbers.values())[x]) #--->  10 : Ten
                                                                    #      20 : Twenty
                                                                    #      30 : Thirty
                                                                    #      40 : Forty       
       

#Copy
d1 = {"a":11, "b":22, "c":33}
d2 = d1
print (d2)      #--->  {'a': 11, 'b': 22, 'c': 33}
print (id(d1))  #--->  2215278891200
print (id(d2))  #--->  2215278891200
d1["b"] = 100   #d2 will automatically updated 
print (id(d1))  #--->  2215278891200
print (id(d2))  #--->  2215278891200     
print (d2)      #--->  {'a': 11, 'b': 100, 'c': 33}

d1 = {"a":11, "b":22, "c":33, "d":44}
d2 = d1.copy()
print (d2)      #--->  {'a': 11, 'b': 22, 'c': 33, 'd':44}  
print (id(d1))  #--->  1586671734976
print (id(d2))  #--->  1586673973632
d1["b"] = 100   #d2 will not update   
print (id(d1))  #--->  1586671734976
print (id(d2))  #--->  1586673973632
print (d2)      #--->  {'a': 11, 'b': 22, 'c': 33, 'd':44}


#Membership
thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
if "model" in thisdict:
  print("Yes, 'model' is one of the keys in the thisdict dictionary")
print(1964 in thisdict)     #--->  False    (we always can see & search keys not values)


#Nested Dictionaries
#value of one or more keys is another dictionary
marklist = {
   "Mahesh"   : {"Phy" : 60, "maths" : 70},
   "Madhavi"  : {"phy" : 75, "maths" : 68},
   "Mitchell" : {"phy" : 67, "maths" : 71}
}

myfamily = {
  "child1" : {
    "name" : "Emil",
    "year" : 2004
  },
  "child2" : {
    "name" : "Tobias",
    "year" : 2007
  },
  "child3" : {
    "name" : "Linus",
    "year" : 2011
  }
}



child1 = {
  "name" : "Emil",
  "year" : 2004
}
child2 = {
  "name" : "Tobias",
  "year" : 2007
}
child3 = {
  "name" : "Linus",
  "year" : 2011
}
myfamily = {
  "child1" : child1,
  "child2" : child2,
  "child3" : child3
}



#Loop in Nested
for k,v in marklist.items():
    print (k, ":", v)   #--->  Mahesh : {'Phy': 60, 'maths': 70}
                        #      Madhavi : {'phy': 75, 'maths': 68}
                        #      Mitchell : {'phy': 67, 'maths': 71}

#Access in Nested
print(marklist.get("Madhavi")['maths'])   #--->  68 
obj=marklist['Mahesh']
print(obj.get('Phy'))                     #--->  60
print(marklist['Mitchell'].get('maths'))  #--->  71
print(myfamily["child2"]["name"])         #--->  Tobias


#Dictionary Comprehension
cubes = {x: x**2 for x in (2, 4, 6)}
print(cubes)    #--->  {2:4, 4:16, 6:36}

#Dictionaries are (list of tuples)
#in point of view of python compilers dictionaries are tuples in list
dic = [(1, 'A'),(2, 'B'),(3, 'C')]
#it is nt useful for coding just for increase knowledge



#create nested dictionary
A nested dict is a dictionary within a dictionary. A very simple thing.

>>> d = {}
>>> d['dict1'] = {}
>>> d['dict1']['innerkey'] = 'value'
>>> d['dict1']['innerkey2'] = 'value2'
>>> d
{'dict1': {'innerkey': 'value', 'innerkey2': 'value2'}}

You can also use a defaultdict from the collections package to facilitate creating nested dictionaries.

>>> import collections
>>> d = collections.defaultdict(dict)
>>> d['dict1']['innerkey'] = 'value'
>>> d  # currently a defaultdict type
defaultdict(<type 'dict'>, {'dict1': {'innerkey': 'value'}})
>>> dict(d)  # but is exactly like a normal dictionary.
{'dict1': {'innerkey': 'value'}}


##########################################################################################################
#ORDERED_DICTIONARY
########################################################################################################## 
from collections import OrderedDict

#empty 
od = OrderedDict()

od['a'] = 1
od['b'] = 2
od['c'] = 3
od['d'] = 4

for key, value in od.items():
    print(key, value)   #--->  a    1
                        #      b    2
                        #      c    3
                        #      d    4

#update an item
od['c'] = 99
for key, value in od.items():
    print(key, value)   #--->  a    1
                        #      b    2
                        #      c    99
                        #      d    4

#pop
od.pop('c')
for key, value in od.items():
    print(key, value)   #--->  a    1
                        #      b    2
                        #      d    4

#insert
od['c'] = 3
for key, value in od.items():
    print(key, value)   #--->  a   1
                        #      b   2
                        #      d   4
                        #      c   3

my_dict = OrderedDict([('a', 1), ('b', 2), ('c', 3)])
#insert
my_dict['d'] = 4
#update
my_dict.update([('e', 5), ('f', 6)])
for key, value in my_dict.items():
    print(key, value)   #--->  ???

#move to end
my_dict.move_to_end('e', last=False)
for key, value in my_dict.items():
    print(key, value)   #--->  e 5
                        #      a 1
                        #      b 2
                        #      c 3
                        #      d 4
                        #      f 6



#example
from collections import OrderedDict
marks = OrderedDict(amir = 12, ali = 17, hassan = 19, mehrdad = 15) 
print(marks) 
marks.move_to_end("ali")  
print(marks)
marks.move_to_end("ali", last = False)  #send to first index 
marks.popitem()
print(marks)
marks.popitem(last=False) #pop the first item
print(marks)
marks["Mesut"] = 18     #will added to end
print(marks)
marks["hassan"] = 20    #just change value - not change place or index 
##########################################################################################################
#COLLECTIONS
##########################################################################################################  
#The collection Module in Python provides different types of containers. A Container is an object that is used to store different objects and provide a way to access the contained objects and iterate over them.
#the different containers provided by the collections module :
#   Counters
#   OrderedDict
#   DefaultDict
#   ChainMap
#   NamedTuple
#   DeQue
#   UserDict
#   UserList
#   UserString

################
#   Counter    #
################
from collections import Counter  
# With sequence of items   
print(Counter(['B','B','A','B','C','A','B', 
               'B','A','C']))          #--->  Counter({'B': 5, 'A': 3, 'C': 2})
# with dictionary  
print(Counter({'A':3, 'B':5, 'C':2}))  #--->  Counter({'B': 5, 'A': 3, 'C': 2})
# with keyword arguments  
print(Counter(A=3, B=5, C=2))          #--->  Counter({'B': 5, 'A': 3, 'C': 2})


#example-1
from collections import Counter
# Creation of a Counter Class object using string as an iterable data container
x = Counter("geeksforgeeks")
for i in x.elements():
	print ( i, end = " ")   #--->  g g e e e e k k s s f o r 


#example-2
a = [12, 3, 4, 3, 5, 11, 12, 6, 7]
x = Counter(a)
print(x)        #--->  Counter({12: 2, 3: 2, 4: 1, 5: 1, 11: 1, 6: 1, 7: 1})
for i in x.keys():
	print(i, ":", x[i]) #--->  12 : 2
                        #       3 : 2
                        #       4 : 1
                        #       5 : 1
                        #      11 : 1
                        #       6 : 1
                        #       7 : 1
x_keys = list(x.keys())
print(x_keys)           #--->  [12, 3, 4, 5, 11, 6, 7]
x_values = list(x.values())
print(x_values)         #--->  [2, 2, 1, 1, 1, 1, 1]


#example-3
a = Counter("geeksforgeeks")
for i in a.elements():
	print ( i, end = " ")   #--->  g g e e e e k k s s f o r
b = Counter({'geeks' : 4, 'for' : 1, 
			'gfg' : 2, 'python' : 3})
for i in b.elements():
	print ( i, end = " ")   #--->  geeks geeks geeks geeks for gfg gfg python python python
c = Counter([1, 2, 21, 12, 2, 44, 5,
			13, 15, 5, 19, 21, 5])
for i in c.elements():
	print ( i, end = " ")   #--->  1 2 2 21 21 12 44 5 5 5 13 15 19 
d = Counter( a = 2, b = 3, c = 6, d = 1, e = 5)
for i in d.elements():
	print ( i, end = " ")   #--->  a a b b b c c c c c c d e e e e e

 
 




###################
#   DefaultDict   #
###################
#takes the first argument as a default data type.
from collections import defaultdict  
d = defaultdict(int)  
L = [1, 2, 3, 4, 2, 4, 1, 2]  
for i in L:  
    d[i] += 1
print(d)    #--->  defaultdict(<class 'int'>, {1: 2, 2: 3, 3: 1, 4: 2})

d2 = defaultdict(list)      
for i in range(5):  
    d2[i].append(i)  
print(d2)   #--->  defaultdict(<class 'list'>, {0: [0], 1: [1], 2: [2], 3: [3], 4: [4]})


#defaultdict can handle error 
#   in normal dictionary
Dict = {1: 'Geeks', 2: 'For', 3: 'Geeks'}  
print(Dict)     #--->  {1: 'Geeks', 2: 'For', 3: 'Geeks'}
print(Dict[1])  #--->  Geeks
print(Dict[4])  #--->  Error-KeyError: 4

#   in default dictionary
from collections import defaultdict 
def def_value(): 
	return "Not Present"
d = defaultdict(def_value) 
#or
#d = defaultdict(lambda: "Not Present") 
d["a"] = 1
d["b"] = 2
print(d["a"]) #--->  1
print(d["b"]) #--->  2  
print(d["c"]) #--->  Not Present  

print(d.__missing__('a'))   #--->  ??? 
print(d.__missing__('d'))   #--->  ???




################
#   ChainMap   #
################
from collections import ChainMap  
     
d1 = {'a': 1, 'b': 2} 
d2 = {'c': 3, 'd': 4} 
d3 = {'e': 5, 'f': 6} 
c = ChainMap(d1, d2, d3)       
print(c)    #--->  ChainMap({'a': 1, 'b': 2}, {'c': 3, 'd': 4}, {'e': 5, 'f': 6})
d4 = {'a': 5 , 'f': 66 }
c2 = ChainMap(d1, d2, d3, d4)  
print(c2['b'])      #--->  2     
print(c2['a'])      #--->  1
print(c2['f'])      #--->  6
print(c2.values())  #--->  ValuesView(ChainMap({'a': 1, 'b': 2}, {'c': 3, 'd': 4}, {'e': 5, 'f': 6}, {'a': 5, 'f': 66}))
print(c2.keys())    #--->  KeysView(ChainMap({'a': 1, 'b': 2}, {'c': 3, 'd': 4}, {'e': 5, 'f': 6}, {'a': 5, 'f': 66}))


#example-1
import collections 
dic1 = { 'a' : 1, 'b' : 2 } 
dic2 = { 'b' : 3, 'c' : 4 } 
chain = collections.ChainMap(dic1, dic2) 
print (chain.maps)           #--->  [{'b': 2, 'a': 1}, {'c': 4, 'b': 3}]
print (list(chain.keys()))   #--->  ['a', 'c', 'b']
print (list(chain.values())) #--->  [1, 4, 2]


#example-2
import collections 
dic1 = { 'a' : 1, 'b' : 2 } 
dic2 = { 'b' : 3, 'c' : 4 } 
dic3 = { 'f' : 5 } 
chain = collections.ChainMap(dic1, dic2) 
print (chain.maps)  #--->  [{'b': 2, 'a': 1}, {'b': 3, 'c': 4}]
chain1 = chain.new_child(dic3) 
print (chain1.maps) #--->  [{'f': 5}, {'b': 2, 'a': 1}, {'b': 3, 'c': 4}]
print (chain1['b']) #--->  2
chain1.maps = reversed(chain1.maps) 
print (chain1.maps) #--->  ???
print (chain1['b']) #--->  3






##################
#   NamedTuple   #
##################
#in normal tuples we use index to acces to what we want
#but if we forget the true index we will face with problems to find
#because of that namedtuble created
#A NamedTuple returns a tuple object with names for each position which the ordinary tuples lack.
from collections import namedtuple 
Student = namedtuple('Student',['name','age','DOB'])  
    
# Adding values  
S = Student('Nandini','19','2541997')  
    
# Access using index  
print ("The Student age using index is : ",end ="")  
print (S[1])    #--->  19
    
# Access using name   
print ("The Student name using keyname is : ",end ="")  
print (S.name)  #--->  Nandini



li = ['Manjeet', '19', '411997' ]      
# using _make() to return namedtuple()  
print ("The namedtuple instance using iterable is  : ")  
print (Student._make(li))   #--->  Student(name='Manjeet', age='19', DOB='411997') 
    
# using _asdict() to return an OrderedDict()  
print ("The OrderedDict instance using namedtuple is  : ")  
print (S._asdict()) #--->  {'name': 'Nandini', 'age': '19', 'DOB': '2541997'}




#example

from collections import namedtuple
Person = namedtuple('Person', ['name', 'age', 'height'])
p1 = Person("amir", 34, 175)
print(p1)       #--->  Person(name='amir', age=34, height=175)
print(p1[1])    #--->  34
print(p1.name)  #--->  amir
print(getattr(p1, 'name'))  #--->  amir
print(p1._asdict())         #--->  {'name': 'amir', 'age': 34, 'height': 175}
print(p1._fields)           #--->  ('name', 'age', 'height')
p1 = p1._replace(name = "john")
print(p1)       #--->  Person(name='john', age=34, height=175)

#convert tuple to namedtuple
x = {'name': "john", 'age': 12, 'height':198}
p2 = Person(**x)
print(p2)  #--->  Person(name='john', age=12, height=198)













#############
#   Deque   #
#############
#Deque (Doubly Ended Queue) is the optimized list for quicker append and pop operations from both sides of 
#the container. It provides O(1) time complexity for append and pop operations as compared to list with O(n) time complexity.
from collections import deque 
queue = deque(['name','age','DOB'])  
print(queue)    #--->  deque(['name', 'age', 'DOB'])
de = deque([1,2,3]) 
# using append() to insert element at right end 
# inserts 4 at the end of deque 
de.append(4) 
print (de)  #--->  deque([1, 2, 3, 4])
# using appendleft() to insert element at left end 
# inserts 6 at the beginning of deque 
de.appendleft(6) 
print (de)  #--->  deque([6, 1, 2, 3, 4])
de = deque([6, 1, 2, 3, 4]) 
# using pop() to delete element from right end   
# deletes 4 from the right end of deque  
de.pop()  
print (de)  #--->  deque([6, 1, 2, 3])
# using popleft() to delete element from left end   
# deletes 6 from the left end of deque  
de.popleft()  
print (de)  #--->  deque([1, 2, 3])


#example-1
import collections
de = collections.deque([1, 2, 3, 3, 4, 2, 4])
# using index() to print the first occurrence of 4
print ("The number 4 first occurs at a position : ")
print (de.index(4,2,5))  #value,startindex,endindex     --->  4
# using insert() to insert the value 3 at 5th position
de.insert(4,3) #index,value
print (de)                          #--->  deque([1, 2, 3, 3, 3, 4, 2, 4])
print(f"Size of Deque: {len(de)}")  #--->  8
print (de.count(3))                 #--->  3
de.remove(3)
print (de)                          #--->  deque([1, 2, 3, 3, 4, 2, 4])
print(f"Size of Deque: {len(de)}")  #--->  7


#example-2
from collections import deque
de = deque([1, 2, 3, 4, 5, 6])
print(de)       #--->  deque([1, 2, 3, 4, 5, 6])
print(de[0])    #--->  1
print(de[-1])   #--->  6


#example-3
de = collections.deque([1, 2, 3,])
# using extend() to add numbers to right end 
de.extend([4,5,6])
print (de)  #--->  deque([1, 2, 3, 4, 5, 6])
# using extendleft() to add numbers to left end 
de.extendleft([7,8,9])
print (de)  #--->  deque([9, 8, 7, 1, 2, 3, 4, 5, 6])
# using rotate() to rotate the deque
# rotates by 3 to left
de.rotate(-3)
print (de)  #--->  deque([1, 2, 3, 4, 5, 6, 9, 8, 7])
# using reverse() to reverse the deque
de.reverse()
print (de)  #--->  deque([7, 8, 9, 6, 5, 4, 3, 2, 1])

de.rotate()
print (de)  #--->  deque([1, 7, 8, 9, 6, 5, 4, 3, 2])
de.rotate(2)
print (de)  #--->  deque([3, 2, 1, 7, 8, 9, 6, 5, 4])
de.rotate(-1)
print (de)  #--->  deque([2, 1, 7, 8, 9, 6, 5, 4, 3])
de.rotate(-2)
print (de)  #--->  deque([7, 8, 9, 6, 5, 4, 3, 2, 1])


#clear()
#Remove all elements from the deque leaving it with length 0.

#copy()
#Create a shallow copy of the deque.

##################
#   UserString   #
##################
#UserString is a string like container it acts as a wrapper around string objects. It is used when someone 
#wants to create their own strings with some modified or additional functionality. 
from collections import UserString 
		
# Creating a Mutable String 
class Mystring(UserString): 
		
	# Function to append to string
	def append(self, s): 
		self.data += s 
			
	# Function to remove from string
	def remove(self, s): 
		self.data = self.data.replace(s, "") 
		
s1 = Mystring("Geeks") 
print("Original String:", s1.data)  #--->  Geeks
	
# Appending to string 
s1.append("s") 
print("String After Appending:", s1.data)   #--->  Geekss 
	
# Removing from string 
s1.remove("e") 
print("String after Removing:", s1.data)    #--->  Gkss



#######################
#   collections.abc   #
#######################
from collections.abc import Sequence

def one(arg1):
    if isinstance(arg1, Sequence):
        print("yes")
    else:
        print("no")  

one(12)     #--->  yes
one("12")   #--->  no
one('12')   #--->  no

from collections.abc import Container
class One:
    def __str__(self):
        pass

print(issubclass(One, Container))   #--->  False    

class One:
    def __str__(self):
        pass
    def __contains__(self,item):
        pass

print(issubclass(One, Container))    #--->  True
a = One()
print(issubclass(a, Container))    #--->  False

from collections.abc import Sized
print(isinstance(a, Sized))



##########################################################################################################
#ARRAYS_MODULE
##########################################################################################################       
#Python's standard library has array module. The array class in it allows you to construct an array of three
#basic types, integer, float and Unicode characters.       
import array as arr

# creating an array with integer type
a = arr.array('i', [1, 2, 3])
print (type(a))     #--->  <class 'array.array'> 
print (a)           #--->  array('i', [1, 2, 3])

# creating an array with char type
a = arr.array('u', 'BAT')
print (type(a))     #--->  <class 'array.array'>
print (a)           #--->  array('u', 'BAT')

# creating an array with float type
a = arr.array('d', [1.1, 2.2, 3.3])
print (type(a))     #--->  <class 'array.array'>  
print (a)           #--->  array('d', [1.1, 2.2, 3.3])
   
   
   
       
# typecode
#Arrays are sequence types and behave very much like lists, except that the type of objects stored in them is constrained.
#Python array type is decided by a single character Typecode argument.

#   code    datatype        size

#   'b'	signed integer	    1
#   'B'	unsigned integer	1
#   'u'	Unicode character	2
#   'h'	signed integer	    2
#   'H'	unsigned integer	2
#   'i'	signed integer	    2
#   'I'	unsigned integer	2
#   'l'	signed integer	    4
#   'L'	unsigned integer	4
#   'q'	signed integer	    8
#   'Q'	unsigned integer	8
#   'f'	floating point	    4
#   'd'	floating point	    8
#



#Arrays are sequence types and behave very much like lists, except that the type of objects stored in them is constrained.

#Access Array Items
a = arr.array('i', [1, 2, 3])
print (a[0])     #--->  1
print (a[1])     #--->  2
print (a[2])     #--->  3
print (a[-1])    #--->  3
print (a[-2])    #--->  2
print (a[-3])    #--->  1

#count
c = a.count(2)              #the number of times v appears in the array.
print ("Count of 2:", c)    #--->  1

#index
print (a.index(2))          #--->  1

#slicing
print (a[1:])    #--->  array('i', [2, 3])   
   
#Changing Array Items
a = arr.array('i', [1, 2, 3])
a[1] = 20
print (a[1])     #--->  20
a[2] = 'A'       #--->  TypeError: 'str' object cannot be interpreted as an integer   

#Add
a = arr.array('i', [1, 2, 3])
a.append(10)
print (a)        #--->  array('i', [1, 2, 3, 10])

#Insert
a = arr.array('i', [1, 2, 3])
a.insert(1,20)
print (a)        #--->  array('i', [1, 20, 2, 3])

#Extend
a = arr.array('i', [1, 2, 3, 4, 5])
b = arr.array('i', [6,7,8,9,10])
a.extend(b)
print (a)        #--->  array('i', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

#Remove
a = arr.array('i', [1, 2, 1, 4, 2])
a.remove(2)
print (a)        #--->  array('i', [1, 1, 4, 2])

#Pop
a = arr.array('i', [1, 2, 1, 4, 2])
a.pop(2)
print (a)        #--->  array('i', [1, 2, 4, 2])
a.pop()
print ()         #--->  ???

#Clear

#Loop
a = arr.array('d', [1, 2, 3])
for x in a:
   print (x)    #--->  1.0
                #      2.0
                #      3.0

l = len(a)
for x in range(l):
   print (a[x])

l = len(a)
idx =0
while idx<l:
   print (a[idx])
   idx+=1

#Copy
#way-1  with .copy() function
a = arr.array('i', [1, 2, 3, 4, 5])
b = a.copy()
print(id(a))    #--->  ???
print(id(b))    #--->  ???
print(b)        #--->  ???
a[2]=10
print(b)        #--->  ???

#way-2  with assignment sign
a = arr.array('i', [1, 2, 3, 4, 5])
b=a
print(id(a))    #--->  2771967068656
print(id(b))    #--->  2771967068656
print(b)        #--->  ???
a[2]=10         #any change in "a" will reflect in "b" too
print(b)        #--->  ???

#way-3  with copy module
import array, copy
a = arr.array('i', [1, 2, 3, 4, 5])
b = copy.deepcopy(a) 
print(id(a))    #--->  2771967069936
print(id(b))    #--->  2771967068976
print(b)        #--->  array('i', [1, 2, 3, 4, 5])
a[2]=10         #If we change an element in "a", it is not reflected in "b".
print(b)        #--->  array('i', [1, 2, 3, 4, 5])



#fromlist
import array as arr
a = arr.array('i', [1, 2, 3, 4, 5])
lst = [6, 7, 8, 9, 10]
c = a.fromlist(lst)
print (a)       #--->  array('i', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])



#Reverse
#way-1      with reverse for loop
import array as arr
a = arr.array('i', [10,5,15,4,6,20,9])
b = arr.array('i')
for i in range(len(a)-1, -1, -1):
    b.append(a[i])
print (b)       #--->  array('i', [9, 20, 6, 4, 15, 5, 10])

#way-2      with convert to list
from array import array as arr
a = arr.array('i', [10,5,15,4,6,20,9])
b = a.tolist()
b.reverse()
a = arr.array('i')
a.fromlist(b)
print (a)

#way-3      #with reverse function
import array as arr
a = arr.array('i', [1, 2, 3, 4, 5])
a.reverse()
print (a)       #--->  array('i', [5, 4, 3, 2, 1])





#Sort
#way-1      using classical bubble sort algorithm
import array as arr
a = arr.array('i', [10,5,15,4,6,20,9])
for i in range(0, len(a)):
    for j in range(i+1, len(a)):
        if(a[i] > a[j]):
            temp = a[i];
            a[i] = a[j];
            a[j] = temp;
print (a)       #--->  array('i', [4, 5, 6, 9, 10, 15, 20])

#way-2      Using the sort() Method from List
from array import array as arr
a = arr.array('i', [10,5,15,4,6,20,9])
b=a.tolist()
b.sort()
a = arr.array('i')
a.fromlist(b)
print (a)       #--->  array('i', [4, 5, 6, 9, 10, 15, 20])

#way-3      Using the Builtin sorted() Function
from array import array as arr
a = arr.array('i', [4, 5, 6, 9, 10, 15, 20])
sorted(a)
print (a)       #--->  array('i', [4, 5, 6, 9, 10, 15, 20])




#Join
#way-1      with append in for loop
import array as arr
a = arr.array('i', [10,5,15,4,6,20,9])
b = arr.array('i', [2,7,8,11,3,10])
for i in range(len(b)):
   a.append(b[i])
print (a, b)        #--->  array('i', [10, 5, 15, 4, 6, 20, 9, 2, 7, 8, 11, 3, 10])

#way-2      with convert to list
from array import array as arr
a = arr.array('i', [10,5,15,4,6,20,9])
b = arr.array('i', [2,7,8,11,3,10])
x=a.tolist()
y=b.tolist()
z=x+y
a=arr.array('i')
a.fromlist(z)
print (a)

#way-3      with extend function
from array import array as arr
a = arr.array('i', [10,5,15,4,6,20,9])
b = arr.array('i', [2,7,8,11,3,10])
a.extend(b)
print (a)       #--->  array('i', [10, 5, 15, 4, 6, 20, 9, 2, 7, 8, 11, 3, 10])


###################
#COPY_MODULE    
###################
#Copy_Module
#copy 
    
#Shallow copy vs Deep copy
#only for mutable objects like (list, dictionary, set)     
    

#shallow copy (whit the same id)(just like point to a var)
a  = [1, 2, 3, 4]
b = a
print (a) #--->  [1, 2, 3, 4]       
print (b) #--->  [1, 2, 3, 4]      
print (id(a))  #--->  140495350685248      
print (id(b))  #--->  140495350685248      

b[0] = 6
print (a) #--->  [6, 2, 3, 4]        
print (b) #--->  [6, 2, 3, 4]      
print (id(a))  #--->  139735737556544     
print (id(b))  #--->  139735737556544  

# list() dict() set()
b = list(a)
b[0] = 6
print (a) #--->   [1, 2, 3, 4]    
print (b) #--->   [6, 2, 3, 4]   
print (id(a))  #--->  139644539215424   
print (id(b))  #--->  139644539216064 
       


#list() method just do for direct childes not for [5,6]
a  = [1, 2, 3, 4, [5, 6]]
b = list(a)
print (a) #--->  [1, 2, 3, 4, [5, 6]]     
print (b) #--->  [1, 2, 3, 4, [5, 6]]   
print (id(a))  #--->  140607472490432  
print (id(b))  #--->  140607472443584

b[4][0] = 7
print (a) #--->   [1, 2, 3, 4, [7, 6]]   
print (b) #--->   [1, 2, 3, 4, [7, 6]]  
print (id(a))  #--->  140162286426048  
print (id(b))  #--->  140162286379200




#use copy module
import copy
a  = [1, 2, 3, 4, [5, 6]] 
b = copy.copy(a)
b[4][0] = 7
print (a) #--->   [1, 2, 3, 4, [7, 6]]
print (b) #--->   [1, 2, 3, 4, [7, 6]]  
print (id(a))  #--->   140639138715776
print (id(b))  #--->   140639138715648

import copy
a  = [1, 2, 3, 4, [5, 6]] 
b = copy.deepcopy(a)
b[4][0] = 7
print (a) #--->   [1, 2, 3, 4, [5, 6]]
print (b) #--->   [1, 2, 3, 4, [7, 6]]  
print (id(a))  #--->   139881277787136
print (id(b))  #--->   139881277790336
       
       
##########################################################################################################
#FUNCTION
##########################################################################################################
#simple
def hello(): 
   print("hello") 
   print("hello again") 

hello()   #--->  hello
          #      hello again  



#type of inputs
#def myFunc(a , b , / , c , d , e = v1 , f = v2 , *args , * , g , h , i = v3 , **kwargs) :
#           1   2       3   4   5        6         7          8   9   10         11
#
#   1,2     positional only     
#   3,4     regular
#   5,6     default arguments
#   7       arbitrary positional
#   8,9     keyword only
#   10      keyword only with default
#   11      arbitrary keyword arguments + optional
#
#   Positional argument cannot appear after keyword arguments

       
#with single input
def func1(name1) :
    print("welcome",name1)

func1("ali")   #--->  welcome ali

#with multiple input
def funcSum1(num1, num2) :
    print(num1+num2)

funcSum1(7,3)   #--->  10
funcSum1(7)     #--->  Error
funcSum1()      #--->  Error
# funcSum1(num2=0, num1=9)   #--->    

#formal arguments vs actual arguments
#def myFunc(fa1,fa2) :  --->  formal
#   do something
#   do otherthing

#myFunc(aa1,aa2)        --->  actual




#with default inputs
def funcSum2(num1, num2=6) :    #inputs which have default value should be at the end of input arguments
    print(num1+num2) 

funcSum2(3,1)   #--->  4
funcSum2(3)     #--->  9        because num2 = 6 if it not assigned by caller

def funcMul1(num1,num2=1,num3=2) :
    print(num1*num2*num3)

funcMul1(5,num3=3)   #--->  15  (5*1*3)    
                     #      num3 is keyword argument

#positional-only arguments
#gabl az / megdar dadan fagat besurate tartibi                     
#with ordered input
#keyword arguments must be after positional arguments
def desc(num1,/,num2,num3) :
    print(num1)
    print(num2)
    print(num3)

desc(1 , 2 , 3)             #--->  1 2 3
#desc(num1=1,2,3)           #SyntaxError: positional argument follows keyword argument
#desc(num1=1,num2=2,3)      #SyntaxError: positional argument follows keyword argument
desc(num1=1,num2=2,num3=3)  #TypeError: desc() got some positional-only arguments passed as keyword arguments: 'num1'
desc(num1=1,num3=3,num2=2)  #TypeError: desc() got some positional-only arguments passed as keyword arguments: 'num1'
desc(num3=3,num2=2,num1=1)  #TypeError: desc() got some positional-only arguments passed as keyword arguments: 'num1'
desc(num3=3,num1=1,num2=2)  #TypeError: desc() got some positional-only arguments passed as keyword arguments: 'num1'
desc(num2=2,num1=1,num3=3)  #TypeError: desc() got some positional-only arguments passed as keyword arguments: 'num1'
desc(1,num2=2,num3=3)       #--->  1 2 3
desc(1,2,num3=3)            #--->  1 2 3                                                 
#desc(1,num2=2,3)            #SyntaxError: positional argument follows keyword argument   
                            #keyword arguments must be after positional arguments



desc(num1=3,num2=0,num3=0)    #--->  Error-desc() got some positional-only arguments ... 
desc(1,     num2=0,num3=1)    #--->  1 0 1
#desc(1,     num2=0,1)        #--->  SyntaxError: positional argument follows keyword argument

#keyword argument
#baad az * megdar dadan fagat ba klidvazheha
#after * you should just use keyword to assign
#keyword arguments must be after positional arguments
def desc2(num1,*,num2,num3) :
    print(num1)
    print(num2)
    print(num3)

desc2(1 , 2 , 3)                #TypeError: desc2() takes 1 positional argument but 3 were given
#desc2(num1=1,2,3)              #SyntaxError: positional argument follows keyword argument
#desc2(num1=1,num2=2,3)         #SyntaxError: positional argument follows keyword argument
desc2(num1=1,num2=2,num3=3)     #--->  1 2 3
desc2(num1=1,num3=3,num2=2)     #--->  1 2 3
desc2(num3=3,num2=2,num1=1)     #--->  1 2 3
desc2(num3=3,num1=1,num2=2)     #--->  1 2 3    
desc2(num2=2,num1=1,num3=3)     #--->  1 2 3 
desc2(1,num2=2,num3=3)          #--->  1 2 3
desc2(1,2,num3=3)               #TypeError: desc2() takes 1 positional argument but 2 positional arguments (and 1 keyword-only argument) were given
#desc2(1,num2=2,3)              #SyntaxError: positional argument follows keyword argument


desc2(num1=3,num2=0,num3=0)     #--->  3 0 0
desc2(1,     num2=0,num3=1)     #--->  1 0 1
#desc2(1,     num2=0,1     )    #--->  SyntaxError: positional argument follows keyword argument

#beyne / va * megdar dadan fargi nemikonad be hamin dalil hamish dar halate default tabe ha avvalin argument / va axarin * hast
#def desc(/,num1,num2,num3,*) :
'''
    print(num1)
    print(num2)
    print(num3)
'''


#with a list as input
def myFunc(*args) :
    print(*args)

myFunc(1,2,3,4,5,6,"Ali")   #--->  1 2 3 4 5 6 Ali
print(args[0][3])   #--->  4

def myFunc(*args) :
    for arg in args:
        print(arg)
    print(len(args))
    
myFunc(1,2,3,4,5,6,"Ali")       #--->  1 2 3 4 5 6 Ali 7



#with keyword list as input
def myFunc(*ar,**kwwargs) :
    for argin in ar:
        print(argin,end=' ')
    for dicarg in kwwargs :
        print(dicarg, kwwargs[dicarg] )   #keyword args are in dictionary data type
    
myFunc(1,2,3,name="Ali",age="fifty")        #--->  1 2 3  name Ali 
                                            #             age  fifty


def addr(**kwargs):
    for k,v in kwargs.items():
        print("{}:{}".format(k,v))


addr(Name="John", City="Mumbai")            #--->  Name:John
                                            #      City:Mumbai

addr(Name="Raam", City="Mumbai", ph_no="9123134567", PIN="400001")  #--->  Name:Raam
                                                                    #      City:Mumbai
                                                                    #      ph_no:9123134567
                                                                    #      PIN:400001


def percent(math, sci, **optional):
    print ("maths:", math)
    print ("sci:", sci)
    s=math+sci
    for k,v in optional.items():
        print ("{}:{}".format(k,v), end=' ')
        s=s+v
    return s/(len(optional)+2)

result=percent(math=80, sci=75, Eng=70, Hist=65, Geo=72)    #--->  maths: 80  sci: 75  Eng:70  Hist:65  Geo:72
print ("percentage:", result)                               #--->  percentage: 72.4










#with return
def fun(): 
    S = 0
  
    for i in range(10): 
        S += i 

    return S 

print(fun())   #--->  0+1+2+3+...+9


#without return
def no_return_function():  
    num1 = 10  
    num2 = 20  
    addition = num1 + num2   
  
number = no_return_function()  
print( number )     #--->  None 


#with multiple return
def calc(num1 , num2) :
    sum = num1+num2
    mul = num1*num2
    return sum , mul

ans = calc(5,4)         #a list returned ro ans 
print(ans)              #--->  (9 , 20)      

sum_ans , mul_ans = calc(3,2)  #--->  sum_ans = 5 , mul_ans = 6
print(sum_ans)          #--->  5   

# Empty function:  
def empty():  
    pass  


#The pass Statement
#function definitions cannot be empty, but if you for some reason have a function definition with no content,
#put in the pass statement to avoid getting an error.  


#--------------------------------------
#recursive funcs
#--------------------------------------
#example1
def factorial(num):
    if num == 0 :
        return 1
    else :
        return num * factorial(num-1)
    
print(factorial(5))    
#example2
def fibonacci(num):
    #if num == 1 or num ==2 :           correct but not standard
    if num in (1, 2) :
        return 1    
    return fibonacci(num-1) + fibonacci(num-2)


#main 
def getInteger(): 
   result = int(input("Enter integer: ")) 
   return result 

def Main(): 
   print("Started") 
   
   
   output = getInteger()      
   print(output) 







#--------------------------------------
#local vs global variables
#--------------------------------------
name = 'TutorialsPoint'
marks = 50
result = True
def myfunction():
   a = 10
   b = 20
   c = a+b
   print ("globals():", globals()) #--->  ???
   print ("locals():", locals())   #--->  ??? 
   print (globals()['name']) # displays TutorialsPoint
   print (locals().get('a')) # displays 10
   
   return c
myfunction()


#If you try to manipulate value of a global variable from inside a function, Python raises UnboundLocalError..
marks = 50 # this is a global variable
def myfunction():
   marks = marks + 20
   print (marks)

myfunction()                         # UnboundLocalError: cannot access local variable 'marks' where it is not associated with a value
print (marks) # prints global value 


#modify a global variable
#  use the global keyword to refer it before modifying.
var1 = 50 #global variable
var2 = 60 #global variable
def myfunction():
   "Change values of global variables"
   globals()['var1'] = globals()['var1']+10
   global var2
   var2 = var2 + 20

myfunction()
#shows global variables with changed values
print ("var1:",var1, "var2:",var2)  #--->  var1: 60 var2: 80






#Scope and Lifetime of Variables
def number( ):    
    num = 50    
    print( "Value of num inside the function: ", num)    
    
num = 10    
number()                                             #--->  Value of num inside the function:  50
print( "Value of num outside the function:", num)    #--->  Value of num outside the function: 10



#--------------------------------------
#NameSpace
#--------------------------------------
var1 = 50 # global variable
var2 = 60 # global variable
def myfunction(x, y):
   total = x+y
   print ("Total is a local variable: ", total)

myfunction(var1, var2)
#print (total)   #--->  NameError: name 'total' is not defined 


#--------------------------------------
#NAMESPACE
#--------------------------------------

#local --->  Enclosed  --->  Global  --->  Built-In
#(inner)                                   (outer)

print(dir(__builtins__))    #--->  will show you list of all bult ins in your python

x = "amir"  # global (module level)

def username():
    x = "amir"  # local (method level)

x0 = "amir"     # global
def outer():
    x1 = "amir"    # enclosed     
    def inner():
        x2 = "amir"  # local   

x = 2
def myfunc():
    x = 1
    print(x)

myfunc()    #--->  1    # from inner to outer watch to x


y = 3
def outer():
    x = 2
    def inner():
        print(x)
        print(y)
    inner()
outer() #--->  2 # after local watch to enclose    
        #      3    



#globals() & locals()
x = 3
print(globals())  #--->  {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x7fee8eb10b80>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, '__file__': '/home/cg/root/65cb98f91ceeb/main.py', '__cached__': None, 'x': 3}

def Func1():
    y = 4
    print(locals()) #--->  {'y': 4}

Func1()    

def Func2(a,b):
    y = 4
    print(locals()) #--->  {'a': 33, 'b': 55, 'y': 4}

Func2(33,55) 


#-----------
#global 
x = 1
def Func3():
    x = 2
    print(id(x))#--->  139647241732368
    print(x)    #--->  2

Func3()
print(id(x))  #--->  139647241732336
print(x)      #--->  1


x = 1
def Func3():
    global x
    x = 2
    print(id(x))  #--->  139647241732368
    print(x)      #--->  2

Func3()
print(id(x))  #--->  139647241732368
print(x)      #--->  2

#-----------
#non-local
#work just in enclased (nested funcs)
def outer():
    x = 1

    def inner():
        x = 2
        print(id(x))    #--->  140311023812880
        print(x)        #--->  2

    inner()
    print(id(x))    #--->  140311023812848
    print(x)        #--->  1   

outer()


def outer():
    x = 1

    def inner():
        nonlocal x
        x = 2
        print(id(x))  #--->  139685025202448
        print(x)      #--->  2

    inner()
    print(id(x))    #--->  139685025202448
    print(x)        #--->  2  

outer()




#--------------------------------------
#nested functions 
#--------------------------------------
def word():    
    string = 'Python functions tutorial'    
    x = 5     
    def number():    
        print( string )  #--->  Python functions tutorial 
        print( x )       #--->  5   
    number()        
word()   

def functionA():
    print ("Outer function")
    def functionB():
        print ("Inner function")
    functionB()
functionA()     #--->  Outer function
                #      Inner function


#--------------------------------------
#Closure
#--------------------------------------
#A closure is a nested function which has access to a variable from an enclosing function that has finished its execution.
def functionA(name):
    print ("Outer function")
    def functionB():
        print ("Inner function")
        print ("Hi {}".format(name))
    functionB()
functionA("Python") #--->  Outer function
                    #      Inner function
                    #      Hi Python

#nonlocal Keyword
def functionA():
    counter = 0
    def functionB():
        nonlocal counter
        counter += 1
        return counter
    return functionB

myfunction = functionA()
retval = myfunction()
print ("Counter:", retval)  #--->  1
retval = myfunction()
print ("Counter:", retval)  #--->  2
retval = myfunction()
print ("Counter:", retval)  #--->  3




#--------------------------------------
#Annotations
#--------------------------------------
#Annotations are ignored at runtime, but are helpful for the IDEs and static type checker libraries such as mypy.
def myfunction(a: int, b: int):
    c = a+b
    return c
   
print (myfunction(10,20))                   #--->  30
print (myfunction("Hello ", "Python"))      #--->  Hello Python

def myfunc(a: int, b: (int,float)):         #b can be from two types integer & float 
    b.append(a)
    
    
#You can give annotation for the return data type
def myfunction(a: int, b: int) -> int: 
    c = a+b
    return c

#print(myfunction(2,3))   ???
#using the data type as annotation is ignored at runtime,


def myfunction(a: (int,float), b: (int,float)) -> ((int,float),(int,float)): 
    c = a+b
    d = a*b
    return c,d


#def myfunction(*args: "arbitrary args", **kwargs: "arbitrary keyword args") -> int:
#       pass
#print (myfunction.__annotations__)
#{'args': 'arbitrary args', 'kwargs': 'arbitrary keyword args', 'return': <class 'int'>}
#'''


#--------------------------------------
#MAP
#--------------------------------------
#map will give two input, first is func name, second is input for that func
#map(<Func>, <InputForFunc>)






#--------------------------------------
#LAMBDA
#--------------------------------------
#The Anonymous Functions (lambda functions)
#The lambda keyword can define anonymous, short, single-output functions.
#Arguments can be accepted in any number by lambda expressions
#Lambda functions can only refer to variables in their argument list and the global domain name because 
#they contain their distinct local domain.
#Lambda functions have exactly one line in their syntax:        
#Lambda functions can be used whenever function arguments are necessary.

# Defining a function    
lambda_ = lambda argument1, argument2: argument1 + argument2;  
#A lambda function can take n number of arguments at a time. But it returns only one argument at a time.
#they don't have a name
#The def keyword is needed to create a typical function in Python, as we already know. 
#We can also use the lambda keyword in Python to define an unnamed function.


# Calling the function and passing values    
print( "Value of the function is : ", lambda_( 20, 30 ) )  #--->  50    
print( "Value of the function is : ", lambda_( 40, 50 ) )  #--->  90

#example
add = lambda num: num + 4       #There is no label for this function.
print( add(6) )   #--->  10

#example
a = lambda x, y : (x * y)  
print(a(4, 5))  

#example
a = lambda x, y, z : (x + y + z)  
print(a(4, 5, 5))  



#Map Function in Lambda
#Using Lambda Function with map()
#A method and a list are passed to Python's map() function. The function is executed for all of the elements
#within the list, and a new list is produced with elements generated by the given function for every item.
numbers_list = [2, 4, 5, 1, 3, 7, 8, 9, 10]      
squared_list = list(map( lambda num: num ** 2 , numbers_list ))      
print( 'Square of each number in the given list:' ,squared_list )    #--->  [4, 16, 25, 1, 9, 49, 64, 81, 100]


squares = [lambda num = num: num ** 2 for num in range(0, 11)]       
for square in squares:    
    print('The square value of all numbers from 0 to 10:',square(), end = " ")   #--->  0 1 4 9 16 25 36 49 64 81 100    




#Filter Function in Lambda
#The filter() method accepts two arguments. a function and an iterable such as a list.
#is called for every item of the list, and a list is returned that holds  those elements that returned True when supplied to the function.

# This code used to filter the odd numbers from the given list  
list_ = [35, 12, 69, 55, 75, 14, 73]      
odd_list = list(filter( lambda num: (num % 2 != 0) , list_ ))      
print('The list of odd number is:',odd_list)        #--->  [35, 69, 55, 75, 73]



#Using Lambda Function with if-else
Minimum = lambda x, y : x if (x < y) else y       
print('The greater number is:', Minimum( 35, 74 ))   #--->  35



#Using Lambda with Multiple Statements
#Multiple expressions are not allowed in lambda functions, but we can construct 2 lambda functions or more 
#and afterward call the second lambda expression as an argument to the first. 

my_List = [ [3, 5, 8, 6], [23, 54, 12, 87], [1, 2, 4, 12, 5] ]    
  
  
sort_List = lambda num : ( sorted(n) for n in num )    # sorting every sublist of the above list    
third_Largest = lambda num, func : [ l[ len(l) - 2] for l in func(num)]    # Getting the third largest number of the sublist   

result = third_Largest( my_List, sort_List)      
print('The third largest number from every sub list is:', result )    #--->  [6, 54, 5]




#--------------------------------------
#Return None
#--------------------------------------

def show(value):
    if value:
        return value
    else:
        return None

def show2(value):
    if value:
        return value
    else:
        return

def show3(value):
    if value:
        return value

print(type(show(1)))  #--->  <class 'int'>                         
print(type(show2(1))) #--->  <class 'int'>
print(type(show3(1))) #--->  <class 'int'>

print(type(show(0)))  #--->  <class 'NoneType'>
print(type(show2(0))) #--->  <class 'NoneType'>
print(type(show3(0))) #--->  <class 'NoneType'>

print(show(1))  #--->  1
print(show2(1)) #--->  1
print(show3(1)) #--->  1

print(show(0))  #--->  None
print(show2(0)) #--->  None
print(show3(0)) #--->  None



#--------------------------------------
#ARGUMENT_UNPACKING
#--------------------------------------
def show(name, age, height):
    print(name, age, height)
    
show('amir', 23, 180)   #---> amir 23 180    

x = ['behzad', 27, 175] 
show(x[0], x[1], x[2])  #---> behzad 27 175
show(*x)                #---> behzad 27 175 

y = {'name':'ali', 'age':33, 'height':190}
show(*y)                #---> name age height
show(**y)               #---> ali 33 190

z = {'age':'ali', 'height':33, 'name':190}
show(**z)               #---> 190 ali 33





##########################################################################################################
#FUNCTION_DECORATOR
##########################################################################################################
#used to modify (change or modify) the behavior of the function
#They can be used to add new functionality to existing code without changing the implementation
#It is also called "meta programming" where a part of the program attempts to change another part of program at compile time.

#It is basically a function that takes a Python function as an argument (also called a parameter) and returns
#a new function with modified behavior.

#In Python, there is a title called "Higher-order functions" and they are called functions that perform 
#actions on other functions or return a new function as output.

#Decorators are used to add functionality to an existing function or function or change its behavior.
#Decorators to add functionality to a function or an existing proceeds Or Changing its behavior are used.

#They are typically used for tasks such as login, scheduling, and authentication.

#Decorators in Python are applied to functions using the "@" symbol :
@my_decorator
def my_function():
    pass

#In this example: 
#my_decorator function is applied to the my_function function using the decorator command ( @ ). 
#my_decorator function takes the my_function function as an argument and returns a new function with modified behavior.


#--------------------------------------
#create decorator
def my_decorator(func):
    def wrapper():
        print("قبل از فراخوانی تابع")
        func()
        print("بعد از فراخوانی تابع")
    return wrapper

#1- <my_decorator> function takes another function, <func>, as an argument. 
#2- Defines a new wrapper function that modifies the behavior of the func function by printing a message before and after the function is called.


#example
def decorator1(func):
    def wrapper():
        print("before func")
        func1()
        print("after func")
    return wrapper

@decorator1
def func1():
    print("inside of orginal func")

func1()  #--->  before func
         #      inside of orginal func
         #      after func            




#--------------------------------------
#Pass the argument to the decorator

#We define a decorated function that takes arguments and 
#then 
#define a nested function that takes the function to be modified as an argument.

#example-1
def repeat(num):
    def my_decorator(func):
        def wrapper():
            for i in range(num):
                func()
        return wrapper
    return my_decorator

@repeat(num=3)
def say_hello():
    print("Hi every one")



#example-2
def formatting(lowerscase=False):
    def formatting_decorator(func):
        def wrapper(text=''):
            if lowerscase:
                func(text.lower())
            else:
                func(text.upper())
        return wrapper
    return formatting_decorator

@formatting(lowerscase=True)
def chaap(message):
    print(message)

chaap("I Love Python")  #--->  i love python



#example-3
def outer_add(func):
    def inner_add(param):
        result = func(param * 10)
        return result * 10
    return inner_add

@outer_add
def calc(number):
    return number + 3

print(calc(2))  #---> 230   (((2*10) + 3) * 10)    



#example-4
def outer_add(func):
    def inner_add(param, *args , **kwargs):
        result = func(param)
        print("args is :" , args)
        print("kwargs is :", kwargs)
        return result * 10
    return inner_add

@outer_add
def calc1(num):
    return num + 1

print(calc1(2, "sam", 29, field = "IT"))    #--->  args is : ('sam', 29)
                                            #      kwargs is : {'field': 'IT'}
                                            #      30     




#example-5
def outer_dec(degree, speed):
    def outer_add(func):
        def inner_add(param, *args , **kwargs):
            result = func(param)
            print("args is :" , args)
            print(degree)
            print(speed)
            print("kwargs is :", kwargs)
            return result * 10
        return inner_add
    return outer_add

@outer_dec("master", 90)
def calc1(num):
    return num + 1

print(calc1(2, "sam", 29, field = "IT"))    #--->  args is : ('sam', 29)
                                            #      master
                                            #      90
                                            #      kwargs is : {'field': 'IT'}
                                            #      30  

#--------------------------------------
#logging decorator
#a decorator to logging from all functions

#example
import logging
logging.basicConfig(filename='example.log', level=logging.INFO)

def log_function_call(func):
    def wrapper(*args, **kwargs):
        logging.info(f"Function {func.__name__} called with arguments {args}, {kwargs}")
        return func(*args, **kwargs)
    return wrapper

@log_function_call
def add_numbers(a, b):
    return a + b

result = add_numbers(2, 3)
print(result)




#--------------------------------------
#functools
#Using Decorator always means losing the information related to the main function, 
#in order to avoid this and preserve the information related to our main function, we can use the wraps function.
#This function is actually a Decorator whose task is to copy information from the function it receives as an argument to the function assigned to it:

#with wrap
from functools import wraps

def logged(func):
    @wraps(func)    #or functools.wraps(func)
    def with_logging(*args, **kwargs):
        print(func.__name__ + " was called")
        return func(*args, **kwargs)
    return with_logging

@logged
def f(x):
   """does some math"""
   return x + x * x

print(f.__name__)   #--->  f
print(f.__doc__)    #--->  does some math

#without wrap

def logged(func):
    def with_logging(*args, **kwargs):
        print(func.__name__ + " was called")
        return func(*args, **kwargs)
    return with_logging

@logged
def f(x):
   """does some math"""
   return x + x * x

print(f.__name__)   #--->  with_logging
print(f.__doc__)    #--->  none





#example-2
#without wraps

def outer_dec(degree, speed):
    def outer_add(func):
        def inner_add(param, *args , **kwargs):
            """
            inner_add function inside of decorator
            """
            result = func(param)
            print("args is :" , args)
            print(degree)
            print(speed)
            print("kwargs is :", kwargs)
            return result * 10
        return inner_add
    return outer_add

@outer_dec("master", 90)
def calc1(num):
    """
    calc1 function inside mainfunc
    """
    return num + 1


print(calc1.__doc__)    #--->  inner_add function inside of decorator
#if we use functool.wraps  --->  calc1 function inside mainfunc

#with wraps
def outer_dec(degree, speed):
    def outer_add(func):
        @wraps(func)    # or functools.wraps(func)
        def inner_add(param, *args , **kwargs):
            """
            inner_add function inside of decorator
            """
            result = func(param)
            print("args is :" , args)
            print(degree)
            print(speed)
            print("kwargs is :", kwargs)
            return result * 10
        return inner_add
    return outer_add

@outer_dec("master", 90)
def calc1(num):
    """
    calc1 function inside mainfunc
    """
    return num + 1

#--------------------------------------
#calculate the execution time of a function using decorators

import functools
import time

def timer(func):
    """Print the runtime of the decorated function"""
    @functools.wraps(func)
    def wrapper_timer(*args, **kwargs):
        start_time = time.perf_counter()
        value = func(*args, **kwargs)
        end_time = time.perf_counter()
        run_time = end_time - start_time
        print(f"Finished {func.__name__!r} in {run_time:.4f} secs")
        return value
    return wrapper_timer

@timer
def waste_some_time(num_times):
    result = 0
    for _ in range(num_times):
        for i in range(10000):
            result += i**2

waste_some_time(1)    #--->  Finished 'waste_some_time' in 0.0072 secs
waste_some_time(999)  #--->  Finished 'waste_some_time' in 2.6838 secs

#--------------------------------------
#multiple decorator for a func

#you can use more than one decorator for each of functions


def outer_add(func):
    def inner_add():
        result = func()
        return result + 50
    return inner_add    

def outer_mul(func):
    def inner_mul():
        result = func()
        return result * 10
    return inner_mul

@outer_mul  #second affected    
@outer_add  #first  affected
def calculate():
    a = 11
    b = 4
    return a + b

print(calculate())  #--->  650     { (((11 + 4) + 50) * 10) }


##########################################################################################################
#FUNCTOOLS_MODULE
##########################################################################################################
#GENERIC_FUNCTION
#This feature was introduced in Python with version 3.5 onwards.

#A function composed of multiple functions implementing the same operation for different types. 
#Which implementation should be used during a call is determined by the dispatch algorithm.

#generics is a mechanism with which you to define functions, classes, or methods that can operate on multiple types while maintaining type safety

#With the implementation of Generics enable it is possible to write reusable code that can be used with different data types.


#------------------------------------------------
#Partial
#Partial functions allow us to: 
#   fix a certain number of arguments of a function and generate a new function
#   is a function that is created by fixing a certain number of arguments of another function





#example-2
from functools import partial
def f(a, b, c, x): # A normal function
	return 1000*a + 100*b + 10*c + x
g = partial(f, 3, 1, 4) # A partial function that calls f with
                        # a as 3, b as 1 and c as 4.
print(g(5)) # Calling g()


#example-3
from functools import *
def add(a, b, c): # A normal function
	return 100 * a + 10 * b + c
add_part = partial(add, c = 2, b = 1) # A partial function with b = 1 and c = 2
print(add_part(3)) # Calling partial function

#example-4
def power(exponent, base):
    return base ** exponent
#Partial function   
square = partial(power, 2) # setting value of exponent to 2
cube = partial(power, 3) # setting value of exponent to 3
# Calling Partial function
print("The square of 5 is", square(5))
print("The cube of 7 is", cube(7))

#example-5
from functools import partial

def times(num, time=1):
  return num * time

double = partial(times, time=2)
double(5) #---> 10
triple = partial(times, time=3)
triple(5) #---> 15
quarter = partial(times, time=1/4)
quarter(5) #---> 1.25



#example-1
from functools import partial

#way-1
def multi(x,y):
    return x * y

def double(x):
    return x *2

def triple(x):
    return x *3

print(double(2))    #--->  4
print(triple(3))    #--->  9    

#way-2
def multi(x,y):
    "this is docstring of 'multi' function"
    return x * y

double = partial(multi, y=2)
triple = partial(multi, 3)  #y=3

print(double(2))    #--->  4
print(triple(3))    #--->  9  
print(double.__name__)  #--->  Error - AttributeError
print(double.__doc__)   #--->  partial(func, *args, **keywords) - new function with partial application
                        #        of the given arguments and keywords.


#as you see partials have not __name__ and __doc__ 
#for solving this problem we use update_wrapper

#------------------------------------------------
#update_wrapper
from functools import update_wrapper
update_wrapper(double, multi)
print(double.__name__) #--->  multi
print(double.__doc__)  #--->  this is docstring of 'multi' function



#------------------------------------------------
#Single Dispatch
#a form of generic function dispatch where the implementation is chosen based 
#on the type of a single argument


#------------------------------------------------
#Multiple Dispatch
#Python's standard library doesn't have any other provision for implementing method overloading
#also we can use dispatch function from a third party module named MultipleDispatch for this purpose.
#First, you need to install the Multipledispatch module.
'''
from multipledispatch import dispatch
class example:
    @dispatch(int, int)
    def add(self, a, b):
        x = a+b
        return x
    
    @dispatch(int, int, int)
    def add(self, a, b, c):
        x = a+b+c
        return x

obj = example()

print (obj.add(10,20,30))   #--->  60
print (obj.add(10,20))      #--->  30    
'''


#------------------------------------------------
#Singel Dispatch Decorator
#transform a function into a single-dispatch generic function

#way-1
def show(data):
    if isinstance(data, int):
        two(data)
    elif isinstance(data, str):
        one(data)

def one(s):
    for i in s:
        print(i)

def two(i):
    print(i*2)


#way-2
#with singledispatch decorator
#just first argument is important if there are more than one argumnet in main func (show func in here)
from functools import singledispatch

@singledispatch
def show(data):
    raise NotImplementedError('Unsupported type')    

@show.register(str) 
@show.register(list)
def _(s):   #or one(s)
    for i in s:
        print(i)

@show.register(int)
def _(i):   
    print(i*2)
#or
@show.register
def two(i:int):
    print(i*2)

print(show.dispatch(str))   #--->  one <function _ at 0x7fee0285ce50>
print(show.dispatch(list))  #--->  one <function _ at 0x7fee0285ce50>
print(show.dispatch(int))   #--->  two <function _ at 0x7fee0285cdc0>
print(show.registry)        #--->  {<class 'object'>: <function show at 0x7fee02866d30>, <class 'list'>: <function _ at 0x7fee0285ce50>, <class 'str'>: <function _ at 0x7fee0285ce50>, <class 'int'>: <function _ at 0x7fee0285cdc0>}

show(5) #--->  10


#------------------------------------------------
#Singel Dispatch Decorator
#inside of classes
#transform a method into a single-dispatch generic function
from functools import singledispatchmethod
class Negator:
    @singledispatchmethod   #must be the outer most decorator
    @classmethod
    def neg(cls, arg):
        raise NotImplementedError("Cannot negate a")

    @neg.register   #must be the outer most decorator
    @classmethod
    def _(cls, arg: int):
        return -arg

    @neg.register   #must be the outer most decorator
    @classmethod
    def _(cls, arg: bool):
        return not arg


#------------------------------------------------
#lru_cache
#LRU (Least Recently Used)    
#Recently used entries are most likely to be reused
#if our cache become more than 'maxsize' wil act like LRU system

from functools import lru_cache


@lru_cache  #lru_cache(maxize = 3)  maximum nmber od cacheable data (default is 128 data)
#or
@cache      #maxsize = None (infinite) )(unlimited) #is smaller and faster
def add(a,b):
    print(f"processing {a} + {b} ...")
    return a + b    
    
print(add.cache_info()) #--->  CacheInfo(hits=0, misses=0, maxsize=128, currsize=0)
print(add(1,1)) #--->  processing 1 + 1 ...
                #      2
print(add.cache_info()) #--->  CacheInfo(hits=0, misses=1, maxsize=128, currsize=1)
print(add(2,2)) #--->  processing 2 + 2 ...
                #      4
print(add.cache_info()) #--->  CacheInfo(hits=0, misses=2, maxsize=128, currsize=2)
print(add(1,1)) #--->  2
print(add.cache_info()) #--->  CacheInfo(hits=1, misses=2, maxsize=128, currsize=2)

#CacheInfo(hits=0,          misses=0, maxsize=128, currsize=0)
#          hits:       how many time used from cahced data   
#          misses:     how many time run func to cache its data    
#          currsize:   how many cached data is in memory

add.cache_clear() #--->  clear cach







** Process exited - Return Code: 0 **
Press Enter to exit terminal

##########################################################################################################
#FUNCTION_GENERATOR
##########################################################################################################
#functions which are implemented in order to create a function with similar beahavior like iterator objects

#When calling a normal function, the body of the function is executed until it reaches a return statement and terminates
#But by calling a Generator function, the body of the function is not executed,
# -but a generator object will be returned, 
# -which can be requested one after the other by using its __next__ () method.  

def laplist(): # a simple generator func
    yield "Dell"
    yield "HP"
    yield "MSI"

for i in laplist():
    print(i)    #--->  Dell
                #      HP
                #      MSI




#Generator acts is lazy - doesnot store the data at once,but generates them only when they are requested.
#Generators have more efficient memory management when dealing with large datasets, and we don't have to 
#wait for all values to be generated before using a sequence.

#To create a generator function, it is enough to use one or more yield commands in a normal function.


#The syntax of the yield command is similar to the return command, 
#but with a different application...
#   At any point of the function body, this command will stop the execution of the program at that point,
#   and we can use the __next__ () method to get the yield value:

#YIELD
#yield
def cubes1():
    result = []
    for i in range(10):
        result.append(i**2)
    print(result)       #first make a list of result
    return result       

def cubes2():           #use lower memory
    for i in range(10):
        result = i**2
        print(result)
        yield result        
    

def main():
    for i in cubes1():      #loop on a list 
        print(i)
    for i in cubes2():      #produce result after variable passing
        print(i)                  
    
if __name__ == "__main__" :
    main()    
    

#example-1
def a_generator_function():
   for i in range(3):  # i: 0, 1, 2
      yield i*i
   return

my_generator = a_generator_function()  # Create a generator


#way-1 to run:
my_generator.__next__() #--->  0  
my_generator.__next__() #--->  1
my_generator.__next__() #--->  4
my_generator.__next__() #--->  Error - StopIteration
#way-2 to tun:
for i in a_generator_function():
    print(i)    #--->   0
                #       1
                #       4       ended without exception


#You can turn off a Generator object by calling the close method! 
#Note that after calling this method, a StopIteration exception will be reported if it is requested to create the sending value again (()__next__).

#example
def multiple_yield():  
    str1 = "First String"  
    yield str1  
  
    str2 = "Second string"  
    yield str2  
  
    str3 = "Third String"  
    yield str3

obj = multiple_yield()  
print(next(obj))  #--->  First String
print(next(obj))  #--->  Second string
print(next(obj))  #--->  Third String



#If inside a function, we put the yield command on the right side of an = assignment operator, 
#   then the mentioned function shows a different behavior, 
#       which is called "Coroutine" in the Python programming language.


#How to execute a Coroutine is the same as a Generator, 
#   but with the difference that
#       the send() method is also available to send the value into the function.


def receiver():
    print("Ready to receive")
    while True:
        n = (yield)
        print("Got %s" % n)


receiver_generator = receiver()
receiver_generator.__next__()   #---> Ready to receive

receiver_generator.send('WooW!!')  #--->  Got WooW!!
receiver_generator.send(1)      #--->  Got 1
receiver_generator.send(':)')   #--->  Got :)

#By calling the Coroutine function
#   -the body is not executed 
#       -but an object of the Generator type is returned. 
#           -The __next__ () method brings the execution of the program to the first yield,
#               -at this point the function is suspended and is ready to receive the value. 
#                   -The send() method sends the desired value to the function, 
#                    which is received by the expression (yield) in the Coroutine.
#                       -After receiving the value, the execution of the coroutine continues 
#                           -until the next yield (if any) or the end of the function body is reached.


#In the discussion of Coroutines
#   To get rid of calling the __next__() method
#       Decorators can be used:

def coroutine(func):
    def start(*args,**kwargs):
        generator = func(*args,**kwargs)
        generator.__next__()
        return generator
    return start

@coroutine
def receiver():
    print("Ready to receive")
    while True:
        n = (yield)
        print("Got %s" % n)

receiver_generator = receiver()
receiver_generator.send('Hello World')  #  No initial .next()/.__next__() needed
receiver_generator.close()
receiver_generator.send('value')    #--->  Error - StopIteration


#coroutine can produce and return output at the same time as receiving a value:
def line_splitter(delimiter=None):
    print("Ready to split")
    result = None
    while True:
        line = yield result
        result = line.split(delimiter)


splitter = line_splitter(",")

splitter.__next__()  #--->  Ready to split
splitter.send("A,B,C")  #--->  ['A', 'B', 'C']
splitter.send("100,200,300") #--->  ['100', '200', '300']



#--------------------------------------
#Generator Expressions

#The function of Generator Expressions is similar to List Comprehensions,
#to create it use parentheses () instead of brackets [] in List Comprehensions.

b = (10*i for i in a)

print(b)    #--->  <generator object <genexpr> at 0x7f488703aca8>

b.__next__()  #--->  10
b.__next__()  #--->  20

#The output of an Expressions Generator is an object that knows how to generate results step by step.


#example
#The_Zen_of_Python.txt
"""
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
------------------------------------------------------------------
# File Name: The_Zen_of_Python.txt
# The Zen of Python
# PEP 20: https://www.python.org/dev/peps/pep-0020
"""

file = open("/home/saeid/Documents/The_Zen_of_Python.txt")
lines = (t.strip() for t in file)
comments = (t for t in lines if t[0] == '#')
for c in comments:
    print(c)
#--->
# File Name: The_Zen_of_Python.txt
# The Zen of Python
# PEP 20: https://www.python.org/dev/peps/pep-0020

#The Generator object created by the Generator Expressions method can also be converted to a list object 
#using the list() function:

comment_list = list(comments)
print(comment_list) #--->  ['# File Name: The_Zen_of_Python.txt',
                    #       '# The Zen of Python',
                    #       '# PEP 20: https://www.python.org/dev/peps/pep-0020']



#compare memory (Generator Expression  vs   List Comprehension)
import sys  

nums_squared_list = [i * 2 for i in range(1000)]  # List comprehension  
nums_squared_gc = (i ** 2 for i in range(1000))  # Generator Expression 

print(sys.getsizeof("Memory in Bytes:"nums_squared_list))  #--->  Memory in Bytes: 4508
print(sys.getsizeof("Memory in Bytes:", nums_squared_gc))  #--->  Memory in Bytes: 56


#--------------------------------------
#Pipelining with Generators

with open('sells.log') as file:  
burger_col = (line[3] for line in file)  
per_hour = (int(x) for x in burger_col if x != 'N/A')  
print("Total burgers sold = ",sum(per_hour))  

#???


#--------------------------------------
#Generate Infinite Sequence
def infinite_sequence():  
    num = 0  
    while True:  
        yield num  
        num += 1  
  
for i in infinite_sequence():  
    print(i)  




##########################################################################################################
#BUILT-IN_FUNCTIONS
##########################################################################################################

#abs()       Returns absolute value of a number
abs(-20.33)   #--->  20

#aiter()     Returns an asynchronous iterator for an asynchronous iterable

#all()       Returns true when all elements in iterable is true 
k = [1, 3, 4, 6]              # all values true 
print(all(k))   #--->  True  
k = [0, False]                # all values false  
print(all(k))   #--->  False  
k = [1, 3, 7, 0]              # one false value 
print(all(k))   #--->  False  
k = [0, False, 5]             # one true value  
print(all(k))   #--->  False  
k = []                        # empty iterable  
print(all(k))   #--->  True  

#bin()       Converts integer to binary string
x =  10  
y =  bin(x)  
print (y)       #--->  0b1010

#bool()      Converts a Value to Boolean
test1 = []  
print(bool(test1))  #[] is False
test1 = [0]  
print(bool(test1))  #--->  [0] is True
test1 = 0.0  
print(bool(test1))  #--->  0.0 is False
test1 = None  
print(bool(test1))  #--->  None is False
test1 = True  
print(bool(test1))  #--->  True is True
test1 = 'Easy string'  
print(bool(test1))  #--->  Easy string is True

#bytearray()     returns array of given byte size
string = "Python is a programming language."  
arr = bytearray(string, 'utf-8')  
print(arr)          #--->  bytearray(b'Python is a programming language.')

#bytes()     returns immutable bytes object
#It is an immutable version of the bytearray() function.
string = "Hello World."  
array = bytes(string, 'utf-8')  
print(array)        #--->  b ' Hello World.'  

#callable()      Checks if the Object is Callable-is something that can be called.
x = 8  
print(callable(x))  #--->  False

#compile()      Returns a code object
#takes source code as input and returns a code object which can later be executed by exec() function.
code_str = 'x=5\ny=10\nprint("sum =",x+y)'  
code = compile(code_str, 'sum.py', 'exec')  
print(type(code))   #--->  <class 'code'>
exec(code)          #--->  sum = 15
exec(x)  

#exec()      Executes Dynamically Created Program
x = 8  
exec('print(x==8)') #--->  True 
exec('print(x+4)')  #--->  12

#sum()      Adds items of an Iterable
s = sum([1, 2, 4], 10)  
print(s)            #--->  17

#any()       Checks if any Element of an Iterable is True
l = [4, 3, 2, 0]                              
print(any(l))       #--->  True                                
l = [0, False]  
print(any(l))       #--->  False  
l = [0, False, 5]  
print(any(l))       #--->  True   
l = []  
print(any(l))       #--->  False  

#ascii()     Returns String Containing Printable Representation
normalText = 'Python is interesting'  
print(ascii(normalText))            #--->  'Python is interesting'
otherText = 'Pythön is interesting'  
print(ascii(otherText))             #--->  'Pyth\xf6n is interesting'
print('Pyth\xf6n is interesting')   #--->  Pythön is interesting

#eval()      Runs Code Within Program
x = 8  
print(eval('x + 1'))    #--->  9

#format()       Returns formatted representation of a value 
print(format(123, "d")) #--->  123                      #d integer type
print(format(123.4567898, "f"))  #--->  123.456790      #f float arguments  
print(format(12, "b"))  #--->  1100                     #b binary format 

#frozenset()     Returns immutable frozenset object
letters = ('m', 'r', 'o', 't', 's')  
fSet = frozenset(letters)  
print('Frozen set is:', fSet)                #--->  Frozen set is: frozenset({'o', 'm', 's', 'r', 't'})
print('Empty frozen set is:', frozenset())   #--->  Empty frozen set is: frozenset()

#getattr()       Returns value of named attribute of an object
class Details:  
    age = 22  
    name = "Phill"  
details = Details()  
print('The age is:', getattr(details, "age"))  #--->  The age is: 22
print('The age is:', details.age)              #--->  The age is: 22

#globals()      Returns dictionary of current global symbol table
age = 22  
globals()['age'] = 22  
print('The age is:', age)   #--->  The age is: 22

#locals()        Returns dictionary of a current local symbol table
def localsAbsent():  
    return locals()  
def localsPresent():  
    present = True  
    return locals()  
print('localsNotPresent:', localsAbsent())  #--->  localsAbsent:  {}
print('localsPresent:', localsPresent())    #--->  localsPresent: {'present': True}

#iter()      Returns an iterator
list = [1,2,3,4,5]  
listIter = iter(list)   
print(next(listIter))   #--->  1  
print(next(listIter))   #--->  2  
print(next(listIter))   #--->  3  
print(next(listIter))   #--->  4  
print(next(listIter))   #--->  5  

#next()     Retrieves next item from the iterator
number = iter([256, 32, 82]) 
item = next(number)   
print(item)  #--->  256
item = next(number)  
print(item)  #--->  32
item = next(number)  
print(item)  #--->  82

#map()       Applies Function and Returns a List
#is used to return a list of results after applying a given function to each item of an iterable(list, tuple etc.).
def calculateAddition(n):  
  return n+n  
numbers = (1, 2, 3, 4)  
result = map(calculateAddition, numbers)  
print(result)            #--->  <map object at 0x7fb04a6bec18>
numbersAddition = set(result)   # converting map object to set  
print(numbersAddition)   #--->  {8, 2, 4, 6}   

#memoryview()        Returns memory view of an argument
randomByteArray = bytearray('ABC', 'utf-8')  #A random bytearray  
mv = memoryview(randomByteArray)  
# access the memory view's zeroth index  
print(mv[0])            #--->  65
# It create byte from memory view  
print(bytes(mv[0:2]))   #--->  b'AB'
# It create list from memory view  
print(list(mv[0:3]))    #--->  [65, 66, 67]

#object()        Creates a featureless object
python = object()  
print(type(python))     #--->  <class 'object'>
print(dir(python))      #--->  ['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']


#delattr()       Deletes Attribute From the Object

#dir()       Tries to Return Attributes of Object
#returns the list of names in the current local scope. If the object on which method is called has a method 
#named __dir__(), this method will be called and must return the list of attributes. It takes a single object 



#type argument.
att = dir()  # Calling function  
print(att)   #--->  ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__']

#chr()       Returns a Character (a string) from an Integer

#id()        Returns Identify of an Object

#hash()     Returns hash value of an object
#Hashable types: * bool * int * long * float * string * Unicode * tuple * code object.
#mutable   => not hashable
#immutable => hashable

print(hash(21))     #--->  21
print(hash(22.2))   #--->  461168601842737174
print(hash([1,2]))  #--->  TypeError - unhashable type: 'list'





#type()      Returns the type of the object

#filter()        Constructs iterator from elements which are true
def filterdata(x):  
    if x>5:  
        return x  
result = filter(filterdata,(1,2,6))  
print(list(result))  #--->  6

#help()      Invokes the built-in Help System
print(help())        #--->  Welcome to Python 3.5's help utility! 

#slice()        Returns a slice object
result = slice(5) 
result2 = slice(0,5,3)  
print(result)    #--->  slice(None, 5, None)
print(result2)   #--->  slice(0, 5, 3)

#sorted()       Returns a sorted list from the given iterable
str = "javatpoint" 
sorted1 = sorted(str) 
print(sorted1)   #--->  ['a', 'a', 'i', 'j', 'n', 'o', 'p', 't', 't', 'v']

#ord()       Returns an integer of the Unicode character
#returns an integer representing Unicode code point for the given Unicode character.
print(ord('8'))   #--->  56  
print(ord('R'))   #--->  82 
print(ord('&'))   #--->  38  

#reversed()     Returns the reversed iterator of a sequence
#returns the reversed iterator of the given sequence.
String = 'Java'               # for string
print(list(reversed(String))) #--->  ['a', 'v', 'a', 'J'] 
Tuple = ('J', 'a', 'v', 'a')  # for tuple  
print(list(reversed(Tuple)))  #--->  ['a', 'v', 'a', 'J']
Range = range(8, 12)          # for range  
print(list(reversed(Range)))  #--->  [11, 10, 9, 8]
List = [1, 2, 7, 5]           # for list 
print(list(reversed(List)))   #--->  [5, 7, 2, 1]

#vars()     Returns the __dict__ attribute of the given object.
class Python:  
  def __init__(self, x = 7, y = 9):  
    self.x = x  
    self.y = y  
InstanceOfPython = Python()  
print(vars(InstanceOfPython))  #--->  {'y': 9, 'x': 7}





#anext()     Returns the next item from the given asynchronous iterator
#breakpoint()        This function drops you into the debugger at the call site and calls sys.breakpointhook()
#classmethod()       Returns class method for given function
#hasattr()       Returns whether object has named attribute
#property()         Returns the property attribute
#repr()     Returns a printable representation of the object
#staticmethod()     Transforms a method into a static method
#super()        Returns a proxy object of the base class
#__import__()       Function called by the import statement



#zip()       Returns an iterator of tuples
numList = [4,5, 6]  
strList = ['four', 'five', 'six']  
result = zip()  # No iterables are passed  
resultList = list(result)  # Converting itertor to list  
print(resultList)   #--->  []
result = zip(numList, strList)  # Two iterables are passed  
resultSet = set(result)  # Converting itertor to set 
print(resultSet)    #--->  {(5, 'five'), (4, 'four'), (6, 'six')}


#------------------------------------------------
#ZIP()
#combine two iterator

names  = ["amir","kevin","jack","mark"]
scores = [34, 83, 43, 56, 94]

print(zip(names, scores))       #--->  <zip object at 0x7f8ce8f9e380>
print(list(zip(names, scores))) #--->  [('amir', 34), ('kevin', 83), ('jack', 43), ('mark', 56)]

for i in zip(names, scores):
    print(i)    #--->  ('amir', 34)
                #      ('kevin', 83)
                #      ('jack', 43)
                #      ('mark', 56)


for n, s in zip(names, scores):
    print(f"{n} == {s}")    #--->  amir == 34
                            #      kevin == 83
                            #      jack == 43
                            #      mark == 56


#------------------------------------------------
#Enumerate()
    
names  = ["amir","kevin","jack","mark"]

print(enumerate(names))       #--->  <enumerate object at 0x7f2e3355c380>
print(list(enumerate(names)))   #--->  [(0, 'amir'), (1, 'kevin'), (2, 'jack'), (3, 'mark')]
print(list(enumerate(names, start = 5)))  #--->  [(5, 'amir'), (6, 'kevin'), (7, 'jack'), (8, 'mark')]

for n, i in enumerate(names):
    print(f"{n} == {i}")  #--->  0 == amir
                          #      1 == kevin
                          #      2 == jack
                          #      3 == mark





##########################################################################################################
#MODULE
##########################################################################################################
#Any text file with .py extension and containing Python code is basically a module. It can contain definitions
#of one or more functions, variables, constants as well as classes. Any Python object from a module can be 
#made available to interpreter session or another Python script by import statement. A module can also include
#runnable code.

#1-Create Module
#save the following code as
#   mymodule.py
def SayHello(name):
    print ("Hi {}! How are you?".format(name))
    return

#You can import one module in another Python script
#   import mymodule

#and use its methods
#   mymodule.SayHello("Ali")





#2-Import Statement
#The import statement will load all the resources of the module in the current namespace.

#Importing and also Renaming
#   import math as mt

#from...import Statement
#import specific names from a module without importing the module as a whole
from math import e, tau    
#Import all Names - From import * Statement
from math import *      #we use import math instead of it ... this is better

#import specific objects from a module by using this syntax
#   from mymodule import sum, average
#   print ("sum:",sum(10,20))
#   print ("average:",average(10,20))

#import all the names from a module into the current namespace
#   from modname import *


#3-Import module from a folder nearby my code
#from <foldername>.<modulename> import <methodname>
#from <dirname>.<filename> import <funcname>
#from packages.goodfunc import newsum


#assign an alias name to the imported module.
#   import mymodule as x
#   print ("sum:",x.sum(10,20))
#   print ("average:", x.average(10,20))
#   print ("power:", x.power(10, 2))

#Re-naming a Module
import mymodule as mx

a = mx.person1["age"]
print(a)



#Locating Path of Modules
import sys     
print(sys.path)     #--->  ['/home/pyodide', '/home/pyodide/lib/Python310.zip', '/lib/Python3.10', '/lib/Python3.10/lib-dynload', '', '/lib/Python3.10/site-packages']    

#identify names declared within a module
import string
print (dir(string))    #--->  ['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'removeprefix', 'removesuffix', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']

#3-Module Attributes
#a module is an object of module class, and hence it is characterized by attributes.
#   __file__        returns the physical name of the module.
#   __package__     returns the package to which the module belongs.
#   __doc__         returns the docstring at the top of the module if any
#   __dict__        returns the entire scope of the module
#   __name__        returns the name of the module

#All the built-in modules and functions and built-in classes have the __doc__ property that returns their docstring.

#example:
#mymodule.py
"The docstring of mymodule"
def sum(x,y):
   return x+y

def average(x,y):
   return (x+y)/2
   
def power(x,y):
   return x**y


#Docstring in help system
def addition(x,y):
    '''
    addition(x,y)
    Returns the sum of x and y
    '''
    return x+y


#>>> help (addition)
'''
Help on function addition in module __main__:
addition(x, y)
   addition(x,y)
   Returns the sum of x and y
'''
#Docstring also is used by IDEs to provide useful type ahead information while editing the code.



#>>> dir (mymodule)     #-->  ???



#   import mymodule

#   print (mymodule.__file__)     #--->  C:\Users\mlath\examples\mymodule.py
#   print (mymodule.__doc__)      #--->  The docstring of mymodule
#   print (mymodule.__name__)     #--->  mymodule   (name of imported file)

#   print (usemodule name: __name__)    #---> __main__ 
#   if we run a python file the name of that name will be "__main__"



#In an interactive shell, __name__ attribute returns '__main__'
#From inside a Python script, the __name__ attribute returns '__main__'
print ("__name__ attribute within a script:", __name__)     #--->  __main__


"The docstring of mymodule"
def sum(x,y):
   return x+y
   
print ("sum:",sum(10,20))


#4-

#   import mymodule
#   print ("sum:",mymodule.sum(10,20))

#The output "sum:30" appears twice. Once when mymodule module is imported. The executable statements in
#imported module are also run. Second output is from the calling script

#fix way
if __name__ == "__main__":
       print ("sum:",sum(10,20))



#5-The reload() Function
#Sometimes you may need to reload a module, especially when working with the interactive interpreter
#session of Python.


#5-A   Assume that we have a test module (test.py) with the following function :
def SayHello(name):
    print ("Hi {}! How are you?".format(name))
    return

#   >>> import test
#   >>> test.SayHello("Deepak")
#   Hi Deepak! How are you?

#5-B    suppose you need to modify the SayHello() function, such as :
def SayHello(name, course):
    print ("Hi {}! How are you?".format(name))
    print ("Welcome to {} Tutorial by TutorialsPoint".format(course))
    return


#5-C    Even if you edit the test.py file and save it, the function loaded in the memory won't update.
#       You need to reload it after edit test.py file, using reload() function in imp module.

#   >>> import imp
#   >>> imp.reload(test)
#   >>> test.SayHello("Deepak", "Python")
#   Hi Deepak! How are you?
#   Welcome to Python Tutorial by TutorialsPoint




#if we are running this file do something special 
if __name__ == "__main__" :
    main()

def main():
    print("you are running this file")



#Variables in Module
#The module can contain functions, as already described, but also variables of all types (arrays, dictionaries, objects etc)
#Save this code in the file mymodule.py
person1 = {
    "name"   : "John",
    "age"    : 36,
    "country": "Norway"
}

#in other code use it :
import mymodule
a = mymodule.person1["age"]
print(a)    



#now assume that we have ths code inside mymodule.py
def greeting(name):
    print("Hello, " + name)

person1 = {
    "name": "John",
    "age": 36,
    "country": "Norway"
}

#in other code use one piece of it :
from mymodule import person1
print (person1["age"])


##########################################################################################################   
#VENV (Virtual Environment)    
##########################################################################################################
#use module of others

#Step-1
#install virtual environment (venv) package on system  

#install venv package:
#in windows:
#   >pip install virtualenv                (install venv)
#   >python -m install --upgrade pip       (update pip)

#in ubuntu:
#   >>sudo apt install python3-venv        (install venv) (sudo : super user do) (apt : advance packaging tool)


#Step-2
#make a dir for it (mkdir) with name: mods (modules) ,then go to this directory with "cd mods" command 


#Step-3
#make a virtual environment 
#in linux:
#   >>python3 -m venv venv
#                     (v-name)

#in windows:
#   >virtualenv venv
#               (v-name)
#or
#   >python -m virtualenv venv

#Step-4
#activate the venv     
#in linux:
#   >>source venv/bin/activate     (each time you wanna work with virtual python you must activate the venv. after closing the terminal it will be deactive and you must activate it again)

#in windows:
#   >>venv\Scripts\activate.bat


#step-5
#check if you see (venv) in first of terminal line it show that you are inside of virtual environment    

#step-6
#install a pack from out of system (inside of venv) use: pip install <packname>
#pip will just work when you are inside of virtual environment 
#>>pip  --version                       version of pip installed on your linux ubuntu 
#when you use 'pip install' first it check cache if you had that package use from cache if you dont had then install the last version 
#if you had but you want to update that package you should use --upgrade package 
#for example : 
#>>pip install tqdm
#>>pip install tqdm==3.8.0          (for a special version of package) (not recommended)
#if you had tqdm v4.1.0 it will remove it then replace with v3.8.0
#>>pip install --upgrade tqdm           it will upgrade your tqdm package to last version
#pip install 'tqdm>=3,<4'               it will install last version of package between 3 , 4
#pip install 'tqdm>=3,<4,!=3.8.0'       it will install last version of package between 3 , 4 except 3.8.0 
#pip download numpy                     it will get package without installing

#it will install on this directory:
#mods/venv/lib/python3/site/packages/tqdm

#step-7
#check which packages are installed on your venv
#>>pip list     --->  will show you package names and its versions 
#>>pip freeze   --->  will show you installed packages and versions of them
#>>pip deptree   --->  will show you tree of packages 
#>>pip show <packname>  --->  will show you specs of package such as name,version,location,requires and etc  
#source of modules    
#pypi.org   #best archive for packages   
#there is a contract between programmers that make a file 'requirements.txt' that have result of pip freeze
#to share with the others to inform about versions of packages which used in code
#now others can install packages as the file
#>>pip freeze > requrements.txt
#>>pip install -r requirements.txt
#it is rare that we just write name of packages into requirements.txt without version
#>>pipdeptree -f --exclude pip,pipdeptree,setuptools| sed 's/ //g' | sort -u > requirements.txt
#legends do this !!!


#step-8
#use python inside of venv
#>>python       (not python3 in linux)
#then start to coding
#now you can "import tqdm" inside of your code

#step-9
#uninstall a pack from system
#>>pip uninstall <packname>

#step-9
#for deactivate the venv just write 'deactivate' in terminal (for windows and linux)  
    
    
#EXAMPLE-1  
#Progress Bar  
'''
import tqdm
import time
for i in tqdm.tqdm(range(10)):
    time.sleep(1)   #--->  40% ####......    
'''






#------------------------------------------------
#PYENV
#------------------------------------------------
#pyenv is like venv but you can define a special version of python to work inside of environment
#pyenv lets you easily switch between multiple versions of Python   
   
# install on linux
sudo apt update
sudo apt install -y make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncursesw5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev
curl https://pyenv.run | bash
   
   
   
   
   
#>>pyenv versions 
#>>python --version
#>>python -v                    
#>>pyenv global 3.10            switch between installed python versions
#>>pyenv local 3.11.3           switch to a version of installed python in an special local folder  
#>>pyenv install 3.10.4         To install additional Python versions
#>>pyenv install -l             gives the list of all available versions
#>>pyenv install --list         or
#>>pyenv uninstall <versions>   To remove old Python versions,
#>>pyenv commands               to get a list of all available subcommands
#>>pyenv update                 upgrade your installation

#>>pyenv exec python3.8.10 test.py      This command will run test.py using Python 3.8.10.
    
#>>pyenv virtualenv 3.9.19 <projectname>    to use Python 3.9.19 for a project    
#>>pyenv local <projectname>                to switch to this virtual environment    
    
#python -m venv venv            to create a venv in current folder
#pip install --upgrade pip      to upgrade your pip






#------------------------------------------------
#publish your own package
#------------------------------------------------
#1-make __init__.py file
#2-make <packname>.py file
#3-make pyproject.toml file with this contain:
'''
[project]
name = "<packname>"
version = "0.0.1"
description = "a brief about your package"
requires-python = ">=3.9"
dependencies = [
    "tqdm",
]
[project.script]
<scriptname> = "<packname>.<modulename>:<funcname>"
my_hello = "hello.hello:main"
'''
#4-build it with flit build
    




#find you are in really or virtual python
#>>which python3



##########################################################################################################
#MATH_MODULE
##########################################################################################################
#Python's standard library provides math module. This module includes many pre-defined functions for performing
#different mathematical operations. These functions do not work with complex numbers. 
#There is a cmath module contains mathematical functions for complex numbers.


#convert radian to degree
print (math.degrees(1))     #--->  57.29577951308232
print (math.degrees(90))    #--->  5156.620156177409

#convert degree to radian
print (math.radians(180))   #--->  3.141592653589793
	
#acos (x)
#Return the arc cosine of x, in radians.
from math import acos
x = 0.5
val = acos(x)
print (val)     #--->  1.0471975511965979
x = 0.0
val = acos(x)
print (val)     #--->  1.5707963267948966
x = -1
val = acos(x)
print (val)     #--->  3.141592653589793
x = 1
val = acos(x)
print (val)     #--->  0.0
	
 
 
#acosh (x)
#Return the inverse hyperbolic cosine of x.
from math import acosh
x = 30
val = acosh(x)
print (val)     #--->  4.0940666686320855
x = 5.5
val = acosh(x)
print (val)     #--->  2.389526434574219
x = 1
val = acosh(x)
print (val)     #--->  0.0
x = 0.5
val = acosh(x)
print (val)     #--->  ???
x = 45
val = acosh(x)
print (val)     #--->  ValueError: math domain error

 
	
#asin
#Return the arc sine of x, in radians.
#The result is between -pi/2 and pi/2.
from math import asin
x = 0.5
val = asin(x)
print (val)     #--->  0.5235987755982989
x = 0.0
val = asin(x)
print (val)     #--->  0.0
x = -1
val = asin(x)
print (val)     #--->  -1.5707963267948966
x = 1
val = asin(x)
print (val)     #--->  1.5707963267948966 
	


 
#asinh (x)
#Return the inverse hyperbolic sine of x.
from math import asinh
x = 24
val = asinh(x)
print (val)     #--->  3.8716347563877314
x = -12
val = asinh(x)
print (val)     #--->  -3.179785437699879
x = 1
val = asinh(x)
print (val)     #--->  0.881373587019543
x = 0.5
val = asinh(x)
print (val)     #--->  0.48121182505960347 
	
 

#atan
#Return the arc tangent of x, in radians.
#The result is between -pi/2 and pi/2.
from math import atan
x = 0.5
val = atan(x)
print (val)     #--->  0.4636476090008061
x = 0.0
val = atan(x)
print (val)     #--->  0.0
x = -1
val = atan(x)
print (val)     #--->  -0.7853981633974483
x = 1
val = atan(x)
print (val)     #--->  0.7853981633974483


	
#atan2
#Return atan(y/x), in radians. atan(1) and atan2(1, 1) are both. 
from math import atan2
x,y = (-0.50,-0.50)
val = atan2(x,y)
print (val)     #--->  -2.356194490192345
x,y = (0.50,0.50)
val = atan2(x,y)
print (val)     #--->  0.7853981633974483
x,y= (5,5)
val = atan2(x,y)
print (val)     #--->  0.7853981633974483
x,y = (-10,10)
val = atan2(x,y)
print (val)     #--->  -0.7853981633974483
x,y = (10,20)
val = atan2(x,y)
print (val)     #--->  0.4636476090008061



#atanh (x)
#Return the inverse hyperbolic tangent of x.
from math import atanh
x = 0.55
val = atanh(x)
print (val)     #--->  0.6183813135744636
x = -0.55
val = atanh(x)
print (val)     #--->  -0.6183813135744636
x = 0
val = atanh(x)
print (val)     #--->  0.0
x = 1.25
val = atanh(x)
print (val)     #--->  ValueError: math domain error



#cbrt (x)
#Return the cube root of x.
from math import cbrt
x = 27
cbr = cbrt(x)
print (cbr)     #--->  3.0
x = 100
cbr = cbrt(x)
print (cbr)     #--->  4.641588833612779
x = 8.8
cbr = cbrt(x)
print (cbr)     #--->  2.0645602309127344



#cell(x)
#The ceiling of x: the smallest integer not less than x.


#ceil()
#returns the ceiling value of x i.e. the smallest integer not less than x.
from math import ceil, pi
a1 = -45.17
ceil_a = ceil(a1)
print (a1, ceil_a)    #--->  -45.17  -45
a2 = 100.12
ceil_a = ceil(a2)
print (a2, ceil_a)    #--->  100.12  101       
a3 = 100.72
ceil_a = ceil(a3)
print (a3, ceil_a)    #--->  100.72  101
a4 = pi
ceil_a = ceil(a4)
print (a4, ceil_a)    #--->  3.141592653589793  4  



#comb (x,y)
#Return the number of ways to choose x items from y iter repetition and without order.
#If the value of "x" is greater than the value of y, it will return 0. If x and y are negative, a ValueError 
#occurs. If both the parameters are not integers, TypeError is raised.
#It evaluates to n! / (x! * (x-y)!) when x <= y and evaluates to zero when x > y.
from math import comb
x=7
y=5
combinations = comb(x,y)    #--->  21
print (combinations)
x=5
y=7
combinations = comb(x,y)    #--->  0
print (combinations)
	

 
#copysign(x,y)
#Return a float with the magnitude of x but the sign of y.
from math import copysign
x=10
y=-20
result = copysign(x,y)  #--->  -10.0
print (result)
x=-10
y=20
result = copysign(x,y)  #--->  10.0
print (result)
x=-10
y= -0.0
result = copysign(x,y)  #--->  -10.0
print (result)


 
#cos (x)
#Return the cosine of x radians.
from math import cos, pi
x = 3
val = cos(x)
print (val)     #--->  -0.9899924966004454
x = -3
val = cos(x)
print (val)     #--->  -0.9899924966004454
x = 0
val = cos(x)
print (val)     #--->  1.0
x = pi
val = cos(x)
print (val)     #--->  -1.0
x = 2*pi
val = cos(x)
print (val)     #--->  1.0



#cosh (x)
#Return the hyperbolic cosine of x.
#The value is equivalent to (exp(x) + exp(-x)) / 2.
from math import cosh
x = 0.55
val = cosh(x)
print (val)     #--->  1.155101414123941
x = 1
val = cosh(x)
print (val)     #--->  1.5430806348152437
x = 0
val = cosh(x)
print (val)     #--->  1.0
x = 6.50
val = cosh(x)
print (val)     #--->  332.5715682417774
 
 
 
#degrees
#Converts angle x from radians to degrees.
from math import degrees, pi
x = 3
val = degrees(x)
print (val)     #--->  171.88733853924697
x = -3
val = degrees(x)
print (val)     #--->  -171.88733853924697
x = 0
val = degrees(x)
print (val)     #--->  0.0
x = pi
val = degrees(x)
print (val)     #--->  180.0
x = pi/2
val = degrees(x)
print (val)     #--->  90.0
x = pi/4
val = degrees(x)
print (val)     #--->  45.0 
	


#dist (x,y)
#Return the Euclidean distance between two points x and y.
from math import dist
p = [3,5]
q = [6,9]
val = dist(p,q)
print (val)     #--->  5.0
p = [0,0]
q = [3,3]
val = dist(p,q)
print (val)     #--->  4.242640687119285
	
 
 
#e
#The mathematical constant e = 2.718281..., to available precision.
from math import e
print(e)    #--->  2.718281828459045  (Euler's Number)   

	
#erf (x)
#Return the error function at x.
#x − a number, whose error function we are interested in finding the error function at.
from math import erf, pi
x = 1
val = erf(x)
print (val)     #--->  0.8427007929497149
x = pi
val = erf(x)
print (val)     #--->  0.9999911238536323
x = -12.23
val = erf(x)
print (val)     #--->  -1.0
x = 0
val = erf(x)
print (val)     #--->  0.0 
#???



#erfc (x)
#Return the complementary error function at x.
#The erfc() function in math module stands for complementary error function. Value of erf(x) is equivalent to 1-erf(x). This function is used for large values, where subtraction from 1 results in loss of significance.
from math import erfc, pi
x = 1
val = erfc(x)
print (val)     #--->  0.1572992070502851
x = pi
val = erfc(x)
print (val)     #--->  8.876146367641612e-06
x = -12.23
val = erfc(x)
print (val)     #--->  2.0
x = 0
val = erfc(x)
print (val)     #--->  1.0
#???


#exp (x)
#Return e raised to the power x, where e = 2.718281...
#returns exponential 
import math 
print (math.exp(-45.17))    #--->  2.4150062132629406e-20
print (math.exp(100.12))    #--->  3.0308436140742566e+43
print (math.exp(100.72))    #--->  5.522557130248187e+43
print (math.exp(math.pi))   #--->  23.140692632779267 
	

 
#exp2 (x)
#Return 2 raised to the power x.
#It is equivalent to 2**x.
from math import exp2
x = 6
val = exp2(x)
print (val)     #--->  64.0
print (2**6)    #--->  64
x = -3
val = exp2(x)
print (val)     #--->  0.125
x = 2.5
val = exp2(x)
print (val)     #--->  5.656854249492381


	
#expm1 (x)
#Return e raised to the power x, minus 1.
#Here e is the base of natural logarithms.
from math import expm1
x = 6
val = expm1(x)
print (val)     #--->  402.4287934927351
x = -3
val = expm1(x)
print (val)     #--->  -0.950212931632136
x = 2.5
val = expm1(x)
print (val)     #--->  11.182493960703473



#fabs(x)
#The absolute value of x in float
#It always returns a float, even if the parameter is integer.
from math import fabs
x=10.25
result = fabs(x)    
print (result)      #--->  10.25
x=20
result = fabs(x)
print (result)      #--->  20.0
x=-10
result = fabs(x)
print (result)      #--->  10.0



#factorial(x)
#Return x factorial as an Integer.
from math import factorial
x=10
result = factorial(x)
print (result)          #--->  3628800
x=5
result = factorial(x)
print (result)          #--->  120      (5*4*3*2*1)
x=-5
result = factorial(x)
print (result)          #--->  ValueError: factorial() not defined for negative values



#floor (x)
#The floor of x: the largest integer not greater than x.
from math import floor, pi
a = -45.17
floor_a = floor(a)
print (floor_a)         #--->  -46
a = 100.12
floor_a = floor(a)
print (floor_a)         #--->  100
a = 100.72
floor_a = floor(a)
print (floor_a)         #--->  100
a = pi
floor_a = floor(a)
print (floor_a)         #--->  3


	
#fmod (x,y)
#Always returns float, similar to x%y
#returns same result as x%y. However fmod() gives more accurate result of modulo division than modulo operator.
#x − Positive or negative number to be divided.
#y − Positive or negative number to be divided by.
from math import fmod
a=10
b=2
c=fmod(a,b)
print (c)   #--->  0.0
a=10
b=4
c=fmod(a,b)
print (c)   #--->  2.0
a=0
b=10
c=fmod(a,b)
print (c)   #--->  0.0
a=10
b=1.5
c=fmod(a,b)
print (c)   #--->  1.0



#frexp (x)
#Returns the mantissa and exponent for a given number x.
#This function returns mantissa and exponent (m,n) such that m*2**e is equal to x.
from math import frexp
x = 8
y = frexp(x)
print (y)   #--->  (0.5, 4)
m,n=y
x = m*2**n
print (x)   #--->  (0.5, 4)
#???

	
 
#fsum (iterable)
#Sum of all numbers in any iterable, returns float.
#returns the floating point sum of all numeric items in an iterable i.e. list, tuple, array.
from math import fsum
x = [1,2,3,4,5]
y = fsum(x)
print (y)       #--->  15.0
x = (10,11,12)
y = fsum(x)
print (y)       #--->  33.0
x = [1,'a',2]
y = fsum(x)
print (y)       #--->  TypeError: must be real number, not str

	 
 
#gamma (x)
#Return the Gamma function at x..
#the gamma function (represented by Γ, the capital letter gamma from the Greek alphabet) is one commonly used extension of the factorial function to complex numbers. The gamma function is defined for all complex numbers except the non-positive integers. The mathematical notation for gamma function is −
#Γ(n)=(n−1)!
from math import gamma, pi
x = 6
val = gamma(x)
print (val)     #--->  120.0
x = 2
val = gamma(x)
print (val)     #--->  1.0
x = 1
val = gamma(x)
print (val)     #--->  1.0
x = 0
val = gamma(x)
print (val)      #--->  ValueError: math domain error




	
#gcd (x,y,z)
#Return the greatest common divisor of the specified integer arguments.
from math import gcd
x, y, z = 12, 8, 24
print ("x: {} y: {} z: {}".format(x,y,z))   #--->  x: 12 y: 8 z: 24
result = gcd(x, y, z)
print (result)      #--->  4
x, y, z = 12, 6, 9
result = gcd(x, y, z)
print (result)      #--->  3
x, y = 7, 12
result = gcd(x, y)
print (result)      #--->  1
x, y = 0, 12
result = gcd(x, y)
print (result)      #--->  12


	
#hypot
#Return the Euclidean norm, sqrt(x*x + y*y).
#This is length of vector from origin to point (x,y)
from math import hypot
x = 3
y = 2
val = hypot(x,y)
print (val)     #--->  3.605551275463989
x = -3
y = 3
val = hypot(x,y)
print (val)     #--->  4.242640687119285
x = 0
y = 2
val = hypot(x,y)
print (val)     #--->  2.0
	


#inf
#A floating-point positive infinity. Equivalent to the output of float('inf").
from math import inf
print ("Positive infinity: ",inf, "is equal to", float("Inf"))
print ("Negative infinity: ",-inf, "is equal to", float("-Inf"))
	
#Positive infinity: inf is equal to inf
#Negative infinity: -inf is equal to -inf
 
 
 
#isclose (x,y)
#Return True if the values x and y are close to each other and False otherwise.
#returns the True if the values of two numeric arguments are close to each other, false otherwise.
from math import isclose
x = 2.598
y = 2.597
result = isclose(x, y)
print (result)      #--->  False
x = 5.263
y = 5.263000001
result = isclose(x, y)
print (result)      #--->  True


	
#isfinite (x)
#Returns True if neither an infinity nor a NaN, and False otherwise.
#The isfinite() function in math module returns the True if the argument is neither an infinity nor a NaN, and False otherwise.
from math import isfinite
x = 1.23E-5
result = isfinite(x)
print (result)      #--->  ???
x = 0
result = isfinite(x)
print (result)      #--->  ???
x = float("Inf")
result = isfinite(x)
print (result)      #--->  False


	
#isinf (x)
#Return True if x is a positive or negative infinity, and False otherwise.
#returns the True if the argument is a positive or negative infinity and False otherwise. 
#It is opposite of isfinite() function.
from math import isinf
x = 1.23E-5
result = isinf(x)
print (result)      #--->  False
x = float("-Infinity")
result = isinf(x)
print (result)      #--->  True
x = float("Inf")
result = isinf(x)
print (result)      #--->  True


	
#isnan (x)
#Return True if x is a NaN (not a number), and False otherwise.
#returns Return True if x is a NaN (not a number), and False otherwise.
from math import isnan
x = 156.78
result = isnan(x)
print (result)      #--->  False
x = float("-Infinity")
result = isnan(x)
print (result)      #--->  False
x = float("NaN")
result = isnan(x)
print (result)      #--->  True
x = "NaN"
result = isnan(x)
print (result)      #--->  TypeError: must be real number, not str


	
#isqrt (x)
#Return the integer square root of the nonnegative integer x
from math import isqrt, sqrt
x = 12
y = isqrt(x)
z = sqrt(x)
print (x, z)    #--->  3    3.4641016151377544
x = 16
y = isqrt(x)
z = sqrt(x)
print (y, z)    #--->  4    4.0
x = -100
y = isqrt(x)
z = sqrt(x)
print (y, z)    #--->  ValueError: isqrt() argument must be nonnegative
	
 
 
#lcm (x1, x2, ..)
#Return the least common multiple of the specified integer arguments.
#Return least common multiple of two or more integer arguments.
from math import lcm
x = 4
y = 12
z = 9
print ("x: {} y: {} z: {}".format(x,y,z))
result = lcm(x,y,z)
print (result)  #--->  36
x = 5
y = 15
z = 0
result = lcm(x,y,z)
print (result)  #--->  0
x = 4
y = 3
z = 6
result = lcm(x,y,z)
print (result)  #--->  12



#ldexp (x,y)
#Return x * (2**y). This is the inverse of function frexp().
from math import ldexp, frexp
x = 0.5
y = 4
print ("x: {} y: {}".format(x,y))   #--->  x: 0.5 y: 4 
z = ldexp(x,y)
print (z)       #--->  8.0
x,y = frexp(z)
print ("ldexp value:", z, "frexp(z):",x,y ) #--->  ldexp value: 8.0 frexp(z): 0.5 4



#lgamma (x)
#Return the natural logarithm of the absolute value of the Gamma function at x.
from math import gamma, lgamma, log
x = 6
val = lgamma(x)
print (val)     #--->  4.787491742782047
print ("Cross check")
y = log(gamma(x))
print (y)       #--->  4.787491742782046
x = 2
val = lgamma(x)
print (val)     #--->  0.0
x = 1
val = lgamma(x)
print (val)     #--->  0.0
	

 
#log (x)
#Return the natural logarithm of x (to base e).
import math
print (math.log(100.12))    #--->  4.6063694665635735
print (math.log(100.72))    #--->  4.612344389736092
print (math.log(math.pi))   #--->  1.1447298858494002
print (math.log(1024,2))    #--->  10.0	
 
 
#log10 (x)
#Return the base-10 logarithm of x.
print (math.log10(100.12))  #--->  2.0005208409361854      
print (math.log10(100.72))  #--->  2.003115717099806
print (math.log10(119))     #--->  2.0755469613925306
print (math.log10(math.pi)) #--->  0.49714987269413385 
	

 
#log1p (x)
#Return the natural logarithm of 1+x (base e).
#The result is calculated in a way which is accurate for x near zero.
from math import log1p
x = 4
val = log1p(x)
print (val)     #--->  1.6094379124341003
x = 2.5
val = log1p(x)
print (val)     #--->  1.252762968495368
x = -3
val = log1p(x)
print (val)     #--->  ValueError: math domain error


	
#log2 (x)
#Return the base-2 logarithm of x.
from math import log2
x = 4
val = log2(x)
print (val)     #--->  2.0
x = 2.5
val = log2(x)
print (val)     #--->  1.3219280948873624
x = -3
val = log2(x)
print (val)     #--->  ValueError: math domain error
	 
 
 
#modf (x)
#The fractional and integer parts of x in a two-item tuple. Both parts have the same sign as x. The integer part is returned as a float.
from math import modf, pi
a = 100.72
modf_a = modf(a)
print (modf_a)      #--->  (0.7199999999999989, 100.0)
a = 19
modf_a = modf(a)
print (modf_a)      #--->  (0.0, 19.0)
a = pi
modf_a = modf(a)
print (modf_a)      #--->  (0.14159265358979312, 3.0)



#nan
#A floating-point "not a number" (NaN) value.
from math import nan
print ("Not a number:", nan, "is equal to", float("nan"))   
#Not a number: nan is equal to nan


#nextafter (x,y)
#Return the next floating-point value after x towards y.
from math import nextafter
x = 1.5
y = 100
z = nextafter(x, y)
print (z)   #--->  1.5000000000000002       
x = 1.5
y = float("-inf")
z = nextafter(x, y)
print (z)   #--->  1.4999999999999998
x = 0
y = float("inf")
z = nextafter(x, y)
print (z)   #--->  5e-324



#perm (x,y)
#Return the number of ways to choose x items from y items without repetition and with order.
from math import perm
x=5
y=3
permutations = perm(x,y)
print (permutations)    #--->  60
x=3
y=5
permutations = perm(x,y)
print (permutations)    #--->  0	


 
#pi
#The mathematical constant π = 3.141592..., to available precision.     (denoted as Π ) 
from math import pi
print (pi)      #--->  3.141592653589793


#pow (x,y)
#Returns x raised to y
#Use ** or the built-in pow() function for computing exact integer powers.
print (math.pow(100, 2))    #--->  10000.0
print (math.pow(100, -2))   #--->  0.0001
print (math.pow(2, 4))      #--->  16.0  
print (math.pow(3, 0))      #--->  1.0 
	

 
#prod (iterable)
#Return the product of all the elements in the input iterable.
from math import prod
x = [2,3,4]
product = prod(x)
print (product)     #--->  24   (2*3*4) 
x = (5,10,15)
product = prod(x)
print (product)     #--->  750  (5*10*15)
x = [2,3,4]
y = 3
product = prod(x, start=y)
print (product)     #--->  72   (???)


	
#radians
#Converts angle x from degrees to radians.
from math import radians, pi
x = 30
val = radians(x)
print (val)     #--->  0.5235987755982988
x = -30
val = radians(x)
print (val)     #--->  -0.5235987755982988
x = 0
val = radians(x)
print (val)     #--->  0.0
x = 90
val = radians(x)
print (val)     #--->  1.5707963267948966
x = 180
val = radians(x)
print (val)     #--->  3.141592653589793
x = 45
val = radians(x)
print (val)     #--->  0.7853981633974483


	
#remainder (x,y)
#Returns the remainder of x with respect to y
from math import remainder
x = 18
y= 4
rem = remainder(x, y)
print (rem)     #--->  2.0
x = 22
y= 4
rem = remainder(x, y)
print (rem)     #--->  -2.0
x = 15
y= float("inf")
rem = remainder(x, y)
print (rem)     #--->  15.0
x = 15
y= 0
rem = remainder(x, y)
print (rem)     #--->  ValueError: math domain error


	
#sin (x)
#Return the sine of x radians.
from math import sin, pi
x = 3
val = sin(x)
print (val)     #--->  0.1411200080598672
x = -3
val = sin(x)
print (val)     #--->  -0.1411200080598672
x = 0
val = sin(x)
print (val)     #--->  0.0
x = pi
val = sin(x)
print (val)     #--->  1.2246467991473532e-16
x = pi/2
val = sin(x)
print (val)     #--->  1.0



#sinh (x)
#Return the inverse hyperbolic sine of x.
from math import sinh, pi
x = 1
val = sinh(x)
print (val)     #--->  1.1752011936438014
x = 12.23
val = sinh(x)
print (val)     #--->  102421.59104557337
x = -12.23
val = sinh(x)
print (val)     #--->  -102421.59104557337
x = 0
val = sinh(x)
print (val)     #--->  0.0
x = pi
val = sinh(x)
print (val)     #--->  11.548739357257746 
	

 
#sqrt (x)
#Return the square root of x.
import math
print (math.sqrt(100))      #--->  10.0
print (math.sqrt(7))        #--->  2.6457513110645907
print (math.sqrt(math.pi))  #--->  1.7724538509055159



#tan (x)
#Return the tangent of x radians.
from math import tan, pi
x = 3
val = tan(x)
print (val)     #--->  -0.1425465430742778
x = -3
val = tan(x)
print (val)     #--->  0.1425465430742778
x = 0
val = tan(x)
print (val)     #--->  0.0
x = pi
val = tan(x)
print (val)     #--->  -1.2246467991473532e-16
x = pi/2
val = tan(x)
print (val)     #--->  1.633123935319537e+16 
	

 
#tanh (x)
#Return the hyperbolic tangent of x.
from math import tanh, pi
x = 1
val = tanh(x)
print (val)     #--->  0.7615941559557649
x = 12.23
val = tanh(x)
print (val)     #--->  0.9999999999523363
x = -12.23
val = tanh(x)
print (val)     #--->  -0.9999999999523363
x = 0
val = tanh(x)
print (val)     #--->  0.0
x = pi
val = tanh(x)
print (val)     #--->  0.99627207622075 
	


#tau
#The mathematical constant τ = 6.283185..., to available precision.     (denoted by τ )
#and is equal to 2Π.
from math import tau
print (tau)     #--->  6.283185307179586   


#trunc (x)
#Return x with the fractional part removed, leaving the integer part.
from math import trunc
x = 5.79
rem = trunc(x)
print (rem)     #--->  5
x = 12.04
rem = trunc(x)
print (rem)     #--->  12
x = -19.98
rem = trunc(x)
print (rem)     #--->  -19
x = 15
rem = trunc(x)
print (rem)     #--->  15



#ulp
#Return the value of the least significant bit of the float x.
#   If x is a NaN, return x.
#   If x is negative, return ulp(-x).
#   If x is a positive infinity, return x.
#   If x is equal to zero, return the smallest positive denormalized representable float.
#   If x is equal to the largest positive representable float, return the value of the least significant bit of x.
#   If x is a positive finite number, return the value of the least significant bit of x, such that the first float bigger than x is x + ulp(x).
from math import ulp
x = float('nan')
rem = ulp(x)
print (rem)     #--->  nan
x = 0.0
rem = ulp(x)
print (rem)     #--->  5e-324
x = -10
rem = ulp(x)
print (rem)     #--->  1.7763568394002505e-15
x = 15
rem = ulp(x)
print (rem)     #--->  1.7763568394002505e-15


#statistics
import statistics
data = [4, 5, 8.5 , 7, 7.75, 4.14, 6.6]
print(statistics.mean(data))   #--->  6.141428571428571
print(statistics.median(data))   #--->  6.6
print(statistics.variance(data)) #--->  3.165347619047619


##########################################################################################################
#CMATH
##########################################################################################################
#Python has a built-in module that you can use for mathematical tasks for complex numbers.
#The methods in this module accepts int, float, and complex numbers. It even accepts Python objects that has a __complex__() or __float__() method.

#The methods in this module almost always return a complex number.

#https://www.w3schools.com/python/module_cmath.asp
#???



##########################################################################################################
#STATISTICS_MODULE
##########################################################################################################
#Python has a built-in module that you can use to calculate mathematical statistics of numeric data.
#The statistics module was new in Python 3.4.
#https://www.w3schools.com/python/module_statistics.asp
#???


#provides the functions to mathematical statistics of numeric data
import statistics

# mean() function  
#is used to calculate the arithmetic mean of the numbers in the list.
datasets = [5, 2, 7, 4, 2, 6, 8]     
x = statistics.mean(datasets)     
print("Mean is :", x)  #--->  4.857142857142857

# median() function
#is used to return the middle value of the numeric data in the list.
datasets = [4, -5, 6, 6, 9, 4, 5, -2]      
print("Median of data-set is : % s " % (statistics.median(datasets)))  #--->  ???

# mode() function
#returns the most common data that occurs in the list.
dataset =[2, 4, 7, 7, 2, 2, 3, 6, 6, 8]     
# Printing out the mode of given data-set   
print("Calculated Mode % s" % (statistics.mode(dataset))) #--->  ???

# stdev() function
#is used to calculate the standard deviation on a given sample which is available in the form of the list.
sample = [7, 8, 9, 10, 11]     
print("Standard Deviation of sample is % s " % (statistics.stdev(sample)))   #---> ???

#median_low()
#is used to return the low median of numeric data in the list.
# Note: low median will always be a member of the data-set.   
set1 = [4, 6, 2, 5, 7, 7]       
print("Low median of data-set is % s "   
        % (statistics.median_low(set1)))    #--->  ???

#median_high()
#The median_high function is used to return the high median of numeric data in the list.        
dataset = [2, 1, 7, 6, 1, 9]     
print("High median of data-set is %s "   
        % (statistics.median_high(dataset)))  #--->  ???




##########################################################################################################
#RANDOM_MODULE
##########################################################################################################
#Python has a built-in module that you can use to make random numbers.
#The random module has a set of methods:

'''
-------------------------------------------------------------------------------------
Method	            Description
-------------------------------------------------------------------------------------
seed()	            Initialize the random number generator
getstate()	        Returns the current internal state of the random number generator
setstate()	        Restores the internal state of the random number generator
getrandbits()	    Returns a number representing the random bits
randrange()	        Returns a random number between the given range
randint()	        Returns a random number between the given range
choice()	        Returns a random element from the given sequence
choices()	        Returns a list with a random selection from the given sequence
shuffle()	        Takes a sequence and returns the sequence in a random order
sample()	        Returns a given sample of a sequence
random()	        Returns a random float number between 0 and 1
uniform()	        Returns a random float number between two given parameters
triangular()	    Returns a random float number between two given parameters, you can also set a mode parameter to specify the midpoint between the two other parameters
betavariate()	    Returns a random float number between 0 and 1 based on the Beta distribution (used in statistics)
expovariate()	    Returns a random float number based on the Exponential distribution (used in statistics)
gammavariate()	    Returns a random float number based on the Gamma distribution (used in statistics)
gauss()	            Returns a random float number based on the Gaussian distribution (used in probability theories)
lognormvariate()	Returns a random float number based on a log-normal distribution (used in probability theories)
normalvariate()	    Returns a random float number based on the normal distribution (used in probability theories)
vonmisesvariate()	Returns a random float number based on the von Mises distribution (used in directional statistics)
paretovariate()	    Returns a random float number based on the Pareto distribution (used in probability theories)
weibullvariate()	Returns a random float number based on the Weibull distribution (used in statistics)
'''
#--------------------------------------
#seed() Method
#The seed() method is used to initialize the random number generator.
#The random number generator needs a number to start with (a seed value), to be able to generate a random number.
#Use the seed() method to customize the start number of the random number generator.
import random
random.seed(10) #if the seed value is 10, you will always get 0.5714025946899135 as the first random number.
print(random.random())  #--->  0.5714025946899135
random.seed(10)
print(random.random())  #--->  0.5714025946899135
random.seed(2)
print(random.random())  #--->  0.9560342718892494
#--------------------------------------
#getstate() Method
#The getstate() method returns an object with the current state of the random number generator.
#Use this method to capture the state, and use the setstate() method, with the captured state, to restore the state
#Return the current state of the random generator:
import random
x = random.getstate()
print(x)    #--->  3(2147483648, 3103207354, 496875541, 757866351, 2961889146, ... )
#--------------------------------------
#setstate() Method
#The setstate() method is used to restore the state of the random number generator back to the specified state
#Use the getstate() method to capture the state
#Capture and restore the state of the random number generator:
import random
#print a random number:
print(random.random())  #--->  0.6731178120498394
#capture the state:
state = random.getstate()
#print another random number:
print(random.random())  #--->  0.5642272440431916
#restore the state:
random.setstate(state)
#and the next random number should be the same as when you captured the state:
print(random.random())  #--->  0.5642272440431916
#--------------------------------------
#getrandbits() Method
#The getrandbits() method returns an integer in the specified size (in bits)
import random
print(random.getrandbits(8))    #--->  242      Return an 8 bits sized integer:
print(random.getrandbits(2))    #--->  1
#--------------------------------------
#randrange() Method
#returns a randomly selected element from the specified range.
import random
#returns a number between 3 (included) and 9 (not included)
print(random.randrange(3, 9))   #--->  7

#random.randrange(start, stop, step)
#step Default is 1
#--------------------------------------
#choice() Method
import random
mylist = ["apple", "banana", "cherry"]
print(random.choice(mylist))    #--->  cherry

#Return a random character from a string:
x = "WELCOME"
print(random.choice(x)) #--->  E
#--------------------------------------
#choices() Method
#returns a list with the randomly selected element from the specified sequence.
#You can weigh the possibility of each result with the weights parameter or the cum_weights parameter.
#The sequence can be a string, a range, a list, a tuple or any other kind of sequence.
#   random.choices(sequence, weights=None, cum_weights=None, k=1)
#weights	Optional. A list were you can weigh the possibility for each value.
#cum_weights	Optional. A list were you can weigh the possibility for each value, only this time the possibility is accumulated.
#Example: normal weights list: [2, 1, 1] is the same as this cum_weights list; [2, 3, 4]. Default None

import random
mylist = ["apple", "banana", "cherry"]
print(random.choices(mylist, weights = [10, 1, 1], k = 14)) #--->  [apple, apple, apple, apple, apple, apple, apple, apple, apple, apple, apple, apple, cherry, apple]
#--------------------------------------
#shuffle() Method
import random
mylist = ["apple", "banana", "cherry"]
random.shuffle(mylist)
print(mylist)   #--->  ['banana', 'cherry', 'apple']
#--------------------------------------
#sample() Method
#Syntax
#   random.sample(sequence, k)
#sequence	Required. A sequence. Can be any sequence: list, set, range etc.
#k	        Required. The size of the returned list
import random
mylist = ["apple", "banana", "cherry"]
print(random.sample(mylist, k=2))   #--->  ['banana', 'apple']
#--------------------------------------
#random() Method
#returns a random floating number between 0 and 1.
import random
print(random.random())  #--->  0.8742942850321722
#--------------------------------------
#uniform() Method
#returns a random floating number between the two specified numbers (both included).
import random
print(random.uniform(20, 60))   #--->  50.84879944006473
#--------------------------------------
#uniform() Method
#returns a random floating number between the two specified numbers (both included).
import random
print(random.uniform(20, 60))   #--->  20.747418905237875
#--------------------------------------
#triangular() Method
#random.triangular(low, high, mode)
#The mode parameter gives you the opportunity to weigh the possible outcome closer to one of the other two parameter values.
#The mode parameter defaults to the midpoint between the two other parameter values, which will not weigh the possible outcome in any direction.
import random
#Return a random number between, and included, 20 and 60, but most likely closer to 20:
print(random.triangular(20, 60, 30))    #--->  37.11574593506134
#--------------------------------------
#randint() Method
#random.randint(start, stop)
import random
#returns a number between 3 and 9 (both included)
print(random.randint(3, 9)) #--->  8



##########################################################################################################
#UUID
##########################################################################################################
#Universally Unique Identifier (شناسه منحصر به فرد جهانی)
#It provides developers with the ability to generate unique random numbers of 128 bits in length, so that 
#these numbers can be used as a unique identifier to identify documents, hosts, clients in question, 
#and anything that needs unique naming.


import uuid
user_id = uuid.uuid4()      #uuid4() creates a random UUID.
print(user_id)  #--->  707968be-2d6d-4c28-9856-f5ec663a34a4

# make a UUID based on the host ID and current time
user_id = uuid.uuid1()
print(user_id) #--->  a8098c1a-f86e-11da-bd1a-00112444be1e


#example
# Python3 code to demonstrate 
# components, representations 
# and variants of uuid1() 

import uuid 

id = uuid.uuid1() 

# Representations of uuid1() 
print ("The Representations of uuid1() are : ") 
print ("byte Representation : ",end="") 
print (repr(id.bytes)) 

print ("int Representation : ",end="") 
print (id.int) 

print ("hex Representation : ",end="") 
print (id.hex) 

print("\n") 

# Components of uuid1() 
print ("The Components of uuid1() are : ") 
print ("Version : ",end="") 
print (id.version) 

print ("Variant : ",end="") 
print (id.variant) 

print("\n") 

# Fields of uuid1() 
print ("The Fields of uuid1() are : ") 
print ("Fields : ",end="") 
print (id.fields) 

print("\n") 

# Time Component of uuid1() 
print ("The time Component of uuid1() is : ") 
print ("Time component : ",end="") 
print (id.node) 




#UUID3(): This UUID-based module generates a unique identifier based on a namespace and time. UUID 3 utilizes MD5 hashing.

import uuid

# Generate a UUID3 for a namespace and name
namespace = uuid.uuid3(uuid.NAMESPACE_DNS, 'example.com')
uuid3 = uuid.uuid3(namespace, 'some string')

print(uuid3)    #--->  387d0c39-f671-333b-b6ea-33585a0bb24e



#UUID5(): To generate UUID, it employs cryptographic hashes and text strings supplied by the application. UUID 5 employs SHA-1 hashing. 

import uuid
# Generate a UUID5 for a namespace and name
namespace = uuid.uuid5(uuid.NAMESPACE_DNS, 'example.com')
uuid5 = uuid.uuid5(namespace, 'some string')
print(uuid5)    #--->  b1267b47-9e39-5ae8-92bd-668a30547a35




#example
import uuid

UUID = uuid.uuid1()

print("UUID is ", UUID)
print("UUID Type is ",type(UUID))
print('UUID.bytes   :', UUID.bytes)
print('UUID.bytes_le :', UUID.bytes_le)
print('UUID.hex     :', UUID.hex)
print('UUID.int     :', UUID.int)
print('UUID.urn     :', UUID.urn)
print('UUID.variant :', UUID.variant)
print('UUID.version :', UUID.version)
print('UUID.fields  :', UUID.fields)
print("Prining each field seperately")
print('UUID.time_low            : ', UUID.time_low)
print('UUID.time_mid            : ', UUID.time_mid)
print('UUID.time_hi_version     : ', UUID.time_hi_version)
print('UUID.clock_seq_hi_variant: ', UUID.clock_seq_hi_variant)
print('UUID.clock_seq_low       : ', UUID.clock_seq_low)
print('UUID.node                : ', UUID.node)
print('UUID.time                : ', UUID.time)
print('UUID.clock_seq           : ', UUID.clock_seq)
print('UUID.SafeUUID           : ', UUID.is_safe)

UUID is  3b212454-d494-11e8-92f4-ccaf789d94a0
UUID Type is  <class 'uuid.UUID'>
UUID.bytes   : b';!$T\xd4\x94\x11\xe8\x92\xf4\xcc\xafx\x9d\x94\xa0'
UUID.hex     : 3b212454d49411e892f4ccaf789d94a0
UUID.int     : 78596534435342896145298010144107238560
UUID.urn     : urn:uuid:3b212454-d494-11e8-92f4-ccaf789d94a0
UUID.variant : specified in RFC 4122
UUID.version : 1
UUID.fields  : (992027732, 54420, 4584, 146, 244, 225054014936224)
Prining each field seperately
UUID.time_low            :  992027732
UUID.time_mid            :  54420
UUID.time_hi_version     :  4584
UUID.clock_seq_hi_variant:  146
UUID.clock_seq_low       :  244
UUID.node                :  225054014936224
UUID.time                :  137593521747076180
UUID.clock_seq           :  4852
UUID.SafeUUID           :  SafeUUID.unknown



##########################################################################################################
#SEARCHING
##########################################################################################################


#--------------------------------------
# Binary Search 

# Python program for recursive binary search.  
# Returns index position of n in list1 if present, otherwise -1  
def binary_search(list1, low, high, n):   
  
   # Check base case for the recursive function  
   if low <= high:  
  
      mid = (low + high) // 2  
  
      # If element is available at the middle itself then return the its index  
      if list1[mid] == n:   
         return mid   
  
      # If the element is smaller than mid value, then search moves  
      # left sublist1  
      elif list1[mid] > n:   
         return binary_search(list1, low, mid - 1, n)   
  
      # Else the search moves to the right sublist1  
      else:   
         return binary_search(list1, mid + 1, high, n)   
  
   else:   
      # Element is not available in the list1  
      return -1  
  
# Test list1ay   
list1 = [12, 24, 32, 39, 45, 50, 54]  
n = 32  
  
# Function call   
res = binary_search(list1, 0, len(list1)-1, n)   
  
if res != -1:   
   print("Element is present at index", str(res))  
else:   
   print("Element is not present in list1")  







# Python program for recursive binary search.  
# Returns index position of n in list1 if present, otherwise -1  
def binary_search(list1, low, high, n):   
  
   # Check base case for the recursive function  
   if low <= high:  
  
      mid = (low + high) // 2  
  
      # If element is available at the middle itself then return the its index  
      if list1[mid] == n:   
         return mid   
  
      # If the element is smaller than mid value, then search moves  
      # left sublist1  
      elif list1[mid] > n:   
         return binary_search(list1, low, mid - 1, n)   
  
      # Else the search moves to the right sublist1  
      else:   
         return binary_search(list1, mid + 1, high, n)   
  
   else:   
      # Element is not available in the list1  
      return -1  
  
# Test list1ay   
list1 = [12, 24, 32, 39, 45, 50, 54]  
n = 32  
  
# Function call   
res = binary_search(list1, 0, len(list1)-1, n)   
  
if res != -1:   
   print("Element is present at index", str(res))  
else:   
   print("Element is not present in list1")  


#--------------------------------------
# Linear Search 

def linear_Search(list1, n, key):  
    # Searching list1 sequentially  
    for i in range(0, n):  
        if (list1[i] == key):  
            return i  
    return -1  
  
list1 = [1 ,3, 5, 4, 7, 9]  
key = 7  
  
n = len(list1)  
res = linear_Search(list1, n, key)  
if(res == -1):  
    print("Element not found")  
else:  
    print("Element found at index: ", res)  
Time complexity of linear search algorithm -

Base Case - O(1)
Average Case - O(n)
Worst Case -O(n)


#--------------------------------------
#Grid Search
#https://www.javatpoint.com/grid-search-in-python
#???


#--------------------------------------
#DFS (Depth First Search)
#https://www.javatpoint.com/dfs-in-python
#???

##########################################################################################################
#SORTING
##########################################################################################################
#--------------------------------------
#Bubble Sort

def bubble_sort(list1):  
    has_swapped = True  
  
    total_iteration = 0  
  
    while(has_swapped):  
        has_swapped = False  
        for i in range(len(list1) - total_iteration - 1):  
            if list1[i] > list1[i+1]:  
                # Swap  
                list1[i], list1[i+1] = list1[i+1], list1[i]  
                has_swapped = True  
        total_iteration += 1  
    print("The number of iteraton: ",total_iteration)  
    return list1  
  
list1 = [5, 3, 8, 6, 7, 2]  
print("The unsorted list is: ", list1)  
# Calling the bubble sort funtion  
print("The sorted list is: ", bubble_sort(list1))  

#--------------------------------------
#Insertion Sort 

#The time complexity of the insertion sort is - O(n^2).

def merge_sort(list1, left_index, right_index):    
    if left_index >= right_index:    # here, we are checking the if condition   
        return    
    middle = (left_index + right_index)//2     
# Here, we are finding the middle of the given two numbers  
    merge_sort(list1, left_index, middle)        
# Here, we are calling the merge sort function till the middle number we got   
    merge_sort(list1, middle + 1, right_index)    
# Here, we are calling the merge sort function till the end of the list i.e., right index  
    merge(list1, left_index, right_index, middle)    
# Here, we are calling the merge function to merge the divided list using the merge   # sort function above   
# Here, we are defining a function for merge the list after dividing    
def merge(list1, left_index, right_index, middle):    
   # Here, we are creating subparts of a lists    
    left_sublist = list1[left_index:middle + 1]    
    right_sublist = list1[middle+1:right_index+1]   
    # Here, we are initializing the values for variables that we use to keep    
    # track of where we are in each list1    
    left_sublist_index = 0    
    right_sublist_index = 0    
    sorted_index = left_index   
    # Here, we are traversing the both copies until we get run out one element    
    while left_sublist_index < len(left_sublist) and right_sublist_index < len(right_sublist):        # here, we are declaring a while loop  
        # If our left_sublist has the smaller element, put it in the sorted    
        # part and then move forward in left_sublist (by increasing the pointer)    
        if left_sublist[left_sublist_index] <= right_sublist[right_sublist_index]:   
        # Here, we are checking the if condition, if it is true then we will enter the block   
            list1[sorted_index] = left_sublist[left_sublist_index]    
            left_sublist_index = left_sublist_index + 1    
        # Otherwise add it into the right sublist    
        else:    
            list1[sorted_index] = right_sublist[right_sublist_index]    
            right_sublist_index = right_sublist_index + 1    
            # Here, we are moving forward in the sorted part    
        sorted_index = sorted_index + 1    
     # Here, we will go through the remaining elements and add them    
    while left_sublist_index < len(left_sublist):  # here, we are declaring a while loop  
        list1[sorted_index] = left_sublist[left_sublist_index]    
        left_sublist_index = left_sublist_index + 1    
        sorted_index = sorted_index + 1    
    while right_sublist_index < len(right_sublist):# here, we are declaring a while loop  
        list1[sorted_index] = right_sublist[right_sublist_index]    
        right_sublist_index = right_sublist_index + 1    
        sorted_index = sorted_index + 1    
list1 = [44, 65, 2, 3, 58, 14, 57, 23, 10, 1, 7, 74, 48]   
print("The given list before performing the merge sort is: ", list1)   
# Here, this is the input unsorted array given by the user  
merge_sort(list1, 0, len(list1) -1)    
print("The given list after performing the merge sort is:", list1)       
# here, we are printing the list1 after performing the merge sort amd the merge        
# functions  




#--------------------------------------
#Merge Sort

def merge_sort(list1, left_index, right_index):    
    if left_index >= right_index:    # here, we are checking the if condition   
        return    
    middle = (left_index + right_index)//2     
# Here, we are finding the middle of the given two numbers  
    merge_sort(list1, left_index, middle)        
# Here, we are calling the merge sort function till the middle number we got   
    merge_sort(list1, middle + 1, right_index)    
# Here, we are calling the merge sort function till the end of the list i.e., right index  
    merge(list1, left_index, right_index, middle)    
# Here, we are calling the merge function to merge the divided list using the merge   # sort function above   
# Here, we are defining a function for merge the list after dividing    
def merge(list1, left_index, right_index, middle):    
   # Here, we are creating subparts of a lists    
    left_sublist = list1[left_index:middle + 1]    
    right_sublist = list1[middle+1:right_index+1]   
    # Here, we are initializing the values for variables that we use to keep    
    # track of where we are in each list1    
    left_sublist_index = 0    
    right_sublist_index = 0    
    sorted_index = left_index   
    # Here, we are traversing the both copies until we get run out one element    
    while left_sublist_index < len(left_sublist) and right_sublist_index < len(right_sublist):        # here, we are declaring a while loop  
        # If our left_sublist has the smaller element, put it in the sorted    
        # part and then move forward in left_sublist (by increasing the pointer)    
        if left_sublist[left_sublist_index] <= right_sublist[right_sublist_index]:   
        # Here, we are checking the if condition, if it is true then we will enter the block   
            list1[sorted_index] = left_sublist[left_sublist_index]    
            left_sublist_index = left_sublist_index + 1    
        # Otherwise add it into the right sublist    
        else:    
            list1[sorted_index] = right_sublist[right_sublist_index]    
            right_sublist_index = right_sublist_index + 1    
            # Here, we are moving forward in the sorted part    
        sorted_index = sorted_index + 1    
     # Here, we will go through the remaining elements and add them    
    while left_sublist_index < len(left_sublist):  # here, we are declaring a while loop  
        list1[sorted_index] = left_sublist[left_sublist_index]    
        left_sublist_index = left_sublist_index + 1    
        sorted_index = sorted_index + 1    
    while right_sublist_index < len(right_sublist):# here, we are declaring a while loop  
        list1[sorted_index] = right_sublist[right_sublist_index]    
        right_sublist_index = right_sublist_index + 1    
        sorted_index = sorted_index + 1    
list1 = [44, 65, 2, 3, 58, 14, 57, 23, 10, 1, 7, 74, 48]   
print("The given list before performing the merge sort is: ", list1)   
# Here, this is the input unsorted array given by the user  
merge_sort(list1, 0, len(list1) -1)    
print("The given list after performing the merge sort is:", list1)       
# here, we are printing the list1 after performing the merge sort amd the merge        
# functions 






#--------------------------------------
#Heap Sort

from heapq import heappop, heappush  
   
def heapsort(list1):  
    heap = []  
    for ele in list1:  
        heappush(heap, ele)  
   
    sort = []  
   
    # the elements are lift in the heap  
    while heap:  
        sort.append(heappop(heap))  
   
    return sort  
   
list1 = [27, 21, 55, 15, 60, 4, 11, 17, 2, 87]  
print(heapsort(list1))  





##########################################################################################################
#STACK_&_QUEUE
##########################################################################################################
#Stack
#stack follows LIFO rule (Last In First Out)
#   push   - It adds an element to the top of the stack.
#   pop    - It removes an element from the top of the stack.




#--------------------------------------
#Queue
#queue follows FIFO rule (First In First Out)
#   enqueue     - It adds an element to the end of the queue.
#   dequeue     - It removes the element from the beginning of the queue.

import queue   

L = queue.Queue( maxsize = 10 ) # Queue is created as an object 'L'    
L.put(9)   # Data is inserted in 'L' at the end using put()  
L.put(6)   
L.put(7)   
L.put(4)   
# get() takes data from the head of the Queue 
print(L.get())   #--->  9    
print(L.get())   #--->  6
print(L.get())   #--->  7
print(L.get())   #--->  4





##########################################################################################################
#DATE_&_TIME
##########################################################################################################
import time                                                     # This is required to include time module.
ticks = time.time()
print ("Number of ticks since 12:00am, January 1, 1970:", ticks)    #--->  1681928297.5316436


#TimeTuple
'''
0	4-digit year	    2016
1	Month	            1 to 12
2	Day	                1 to 31
3	Hour	            0 to 23
4	Minute	            0 to 59
5	Second	            0 to 61 (60 or 61 are leap-seconds)
6	Day of Week	        0 to 6 (0 is Monday)
7	Day of year	        1 to 366 (Julian day)
8	Daylight savings	-1, 0, 1, -1 means library determines DST
'''


print (time.localtime())    #--->  time.struct_time(tm_year=2023, tm_mon=4, tm_mday=19, tm_hour=23, tm_min=49, tm_sec=8, tm_wday=2, tm_yday=109, tm_isdst=0)


#struct_time structure
'''
0	tm_year	        2016
1	tm_mon	        1 to 12
2	tm_mday	        1 to 31
3	tm_hour	        0 to 23
4	tm_min	        0 to 59
5	tm_sec	        0 to 61 (60 or 61 are leap-seconds)
6	tm_wday	        0 to 6 (0 is Monday)
7	tm_yday	        1 to 366 (Julian day)
8	tm_isdst	    -1, 0, 1, -1 means library determines DST
'''


#Getting the Current Time
localtime = time.localtime(time.time())
print ("Local current time :", localtime)   #--->  time.struct_time(tm_year=2023, tm_mon=4, tm_mday=19, tm_hour=23, tm_min=42, tm_sec=41, tm_wday=2, tm_yday=109, tm_isdst=0)


#Getting the Formatted Time
#a simple method to get time in a readable format is asctime()
localtime = time.asctime( time.localtime(time.time()) )
print ("Local current time :", localtime)   #--->  Wed Apr 19 23:45:27 2023


#Getting the Calendar for a Month
import calendar
cal = calendar.month(2023, 4)
print (cal)     #--->      April 2023
                #      Mo Tu We Th Fr Sa Su
                #                     1  2
                #      3  4  5  6  7  8  9
                #      10 11 12 13 14 15 16
                #      17 18 19 20 21 22 23
                #      24 25 26 27 28 29 30


s = calendar.prcal(2020)  
print(s)
'''
                                  2020

      January                   February                   March
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
       1  2  3  4  5                      1  2                         1
 6  7  8  9 10 11 12       3  4  5  6  7  8  9       2  3  4  5  6  7  8
13 14 15 16 17 18 19      10 11 12 13 14 15 16       9 10 11 12 13 14 15
20 21 22 23 24 25 26      17 18 19 20 21 22 23      16 17 18 19 20 21 22
27 28 29 30 31            24 25 26 27 28 29         23 24 25 26 27 28 29
                                                    30 31

       April                      May                       June
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
       1  2  3  4  5                   1  2  3       1  2  3  4  5  6  7
 6  7  8  9 10 11 12       4  5  6  7  8  9 10       8  9 10 11 12 13 14
13 14 15 16 17 18 19      11 12 13 14 15 16 17      15 16 17 18 19 20 21
20 21 22 23 24 25 26      18 19 20 21 22 23 24      22 23 24 25 26 27 28
27 28 29 30               25 26 27 28 29 30 31      29 30

        July                     August                  September
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
       1  2  3  4  5                      1  2          1  2  3  4  5  6
 6  7  8  9 10 11 12       3  4  5  6  7  8  9       7  8  9 10 11 12 13
13 14 15 16 17 18 19      10 11 12 13 14 15 16      14 15 16 17 18 19 20
20 21 22 23 24 25 26      17 18 19 20 21 22 23      21 22 23 24 25 26 27
27 28 29 30 31            24 25 26 27 28 29 30      28 29 30
                          31

      October                   November                  December
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
          1  2  3  4                         1          1  2  3  4  5  6
 5  6  7  8  9 10 11       2  3  4  5  6  7  8       7  8  9 10 11 12 13
12 13 14 15 16 17 18       9 10 11 12 13 14 15      14 15 16 17 18 19 20
19 20 21 22 23 24 25      16 17 18 19 20 21 22      21 22 23 24 25 26 27
26 27 28 29 30 31         23 24 25 26 27 28 29      28 29 30 31
                          30
None
'''

#find duration of run 
import timeit
eafp = """
s = "345"
try:
    n = int(s)
except ValueError:
    n = 0
"""
t = timeit.timeit(eafp)
print(t)    #--->  0.1687019999999393


#############################
##  Time Funcs
#############################
#1	time.altzone                        The offset of the local DST timezone, in seconds west of UTC, if one is defined. This is negative if the local DST timezone is east of UTC (as in Western Europe, including the UK). Only use this if daylight is nonzero.
#2	time.asctime([tupletime])           Accepts a time-tuple and returns a readable 24-character string such as 'Tue Dec 11 18:07:14 2008'.
#3	time.clock( )                       Returns the current CPU time as a floating-point number of seconds. To measure computational costs of different approaches, the value of time.clock is more useful than that of time.time().
#4	time.ctime([secs])                  Like asctime(localtime(secs)) and without arguments is like asctime( )
#5	time.gmtime([secs])                 Accepts an instant expressed in seconds since the epoch and returns a time-tuple t with the UTC time. Note : t.tm_isdst is always 0
#6	time.localtime([secs])              Accepts an instant expressed in seconds since the epoch and returns a time-tuple t with the local time (t.tm_isdst is 0 or 1, depending on whether DST applies to instant secs by local rules).
#7	time.mktime(tupletime)              Accepts an instant expressed as a time-tuple in local time and returns a floating-point value with the instant expressed in seconds since the epoch.
#8	time.sleep(secs)                    Suspends the calling thread for secs seconds.
#9	time.strftime(fmt[,tupletime])      Accepts an instant expressed as a time-tuple in local time and returns a string representing the instant as specified by string fmt.
#10	time.strptime(str,fmt='%a %b %d %H:%M:%S %Y')       Parses str according to format string fmt and returns the instant in time-tuple format.
#11	time.time( )                        Returns the current time instant, a floating-point number of seconds since the epoch.
#12	time.tzset()                        Resets the time conversion rules used by the library routines. The environment variable TZ specifies how this is done.

#attributes available with time module
#1	  time.timezone     is the offset in seconds of the local time zone (without DST) from UTC (>0 in the Americas; <=0 in most of Europe, Asia, Africa).
#2	  time.tzname       is a pair of locale-dependent strings, which are the names of the local time zone without and with DST, respectively.




#altzone() Method
#is the attribute of the time module. This returns the offset of the local DST timezone, in seconds west of
#UTC, if one is defined. This is negative if the local DST timezone is east of UTC (as in Western Europe, 
#including the UK). Only use this if daylight is nonzero
import time
print ("time.altzone: ", time.altzone)      #--->  -23400


#asctime() Method
#converts a tuple or struct_time representing a time as returned by gmtime() or localtime() to a 24-character
#string of the following form: 'Tue Feb 17 23:21:05 2009'.
t = time.localtime()
print ("asctime : ",time.asctime(t))        #--->  Wed Apr 19 23:50:25 2023


#perf_counter() Method
#return the value (in fractional seconds) of a performance counter, i.e. a clock with the highest available 
#resolution to measure a short duration. It does include time elapsed during sleep and is system-wide. The 
#reference point of the returned value is undefined, so that only the difference between the results of two 
#calls is valid.
def procedure():
       time.sleep(2.5)
t0 = time.perf_counter() # measure process time
procedure()
print (time.perf_counter() - t0, "seconds process time")    #--->  2.500478400001157 seconds process time
t0 = time.time() # measure wall time
procedure()
print (time.time() - t0, "seconds wall time")               #--->  2.5105583667755127 seconds wall time


#time.clock()
#???


#ctime() Method
#converts a time expressed in seconds since the epoch to a string representing local time. If secs is not 
#provided or None, the current time as returned by time() is used. This function is equivalent to 
#asctime(localtime(secs)). Locale information is not used by ctime(). 
print (time.ctime())        #--->  Thu Apr 20 00:04:00 2023
#time.ctime([ sec ])  ???


#gmtime() Method
#converts a time expressed in seconds since the epoch to a struct_time in UTC in which the dst flag is always
#zero. If secs is not provided or None, the current time as returned by time() is used.
print (time.gmtime(1681928297.5316436))     #--->  time.struct_time(tm_year=2023, tm_mon=4, tm_mday=19, tm_hour=18, tm_min=18, tm_sec=17, tm_wday=2, tm_yday=109, tm_isdst=0)


#localtime() Method
#is similar to gmtime() but it converts number of seconds to local time. If secs is not provided or None, 
#the current time as returned by time() is used. The dst flag is set to 1 when DST applies to the given time.
print ("time.localtime() : ".format(time.localtime()))      #--->  time.struct_time(tm_year=2023, tm_mon=4, tm_mday=20, tm_hour=0, tm_min=8, tm_sec=24, tm_wday=3, tm_yday=110, tm_isdst=0)


#mktime() Method
#is the inverse function of localtime(). Its argument is the struct_time or full 9-tuple and it returns a 
#floating point number, for compatibility with time().
#If the input value cannot be represented as a valid time, either OverflowError or ValueError will be raised.
t = (2023, 4, 20, 10, 13, 38, 1, 48, 0)
d=time.mktime(t)
print ("time.mktime(t) : %f" % d)                                               #--->  1681965818.000000
print ("asctime(localtime(secs)): {}".format(time.asctime(time.localtime(d))))  #--->  Thu Apr 20 10:13:38 2023


#sleep() Method
#suspends execution for the given number of seconds. The argument may be a floating point number to indicate a
#more precise sleep time.
#The actual suspension time may be less than that requested because any caught signal will terminate the 
#sleep() following execution of that signal's catching routine.
print ("Start : %s" % time.ctime())     #--->  Thu Apr 20 00:13:24 2023
time.sleep( 5 )
print ("End : %s" % time.ctime())       #--->  Thu Apr 20 00:13:29 2023


#strftime() Method
#converts a tuple or struct_time representing a time as returned by gmtime() or localtime() to a string as 
#specified by the format argument.
#If "t" is not provided, the current time as returned by localtime() is used. The format must be a string. 
#An exception ValueError is raised if any field in "t" is outside of the allowed range.
#time.strftime(format[, t])
#   t      - This is the time in number of seconds to be formatted.
#   format - This is the directive which would be used to format given time.

#       %a - abbreviated weekday name                                       Wed
#       %A - full weekday name                                              Wednesday
#       %b - abbreviated month name                                         Dec        
#       %B - full month name                                                December
#       %c - preferred date and time representation                         Mon Dec 31 17:41:00 2018
#       %C - century number (the year divided by 100, range 00 to 99)       20
#       %d - day of the month (01 to 31)                                    31
#       %D - same as %m/%d/%y
#       %e - day of the month (1 to 31)
#       %f - Microsecond 000000-999999                                      548513
#       %g - like %G, but without the century
#       %G - 4-digit year corresponding to the ISO week number (see %V).    2018
#       %h - same as %b
#       %H - hour, using a 24-hour clock (00 to 23)                         17
#       %I - hour, using a 12-hour clock (00 to 12)                         05
#       %j - day of the year (001 to 366)                                   365
#       %m - month (01 to 12)                                               12
#       %M - minute                                                         41
#       %n - newline character
#       %p - either am or pm according to the given time value              PM
#       %r - time in a.m. and p.m. notation
#       %R - time in 24 hour notation
#       %S - second                                                         08
#       %t - tab character
#       %T - current time, equal to %H:%M:%S
#       %u - weekday as a number (1 to 7), Monday=1. Warning: In Sun        1
#            Solaris Sunday=1
#       %U - week number of the current year, starting with the first       52
#            Sunday as the first day of the first week
#       %V - The ISO 8601 week number of the current year (01 to 53),       01
#            where week 1 is the first week that has at least 4 days 
#            in the current year, and with Monday as the first day of 
#            the week
#       %W - week number of the current year, starting with the first       52
#            Monday as the first day of the first week
#       %w - day of the week as a decimal, Sunday=0                         3
#       %x - preferred date representation without the time                 12/31/18
#       %X - preferred time representation without the date                 17:41:00
#       %y - year without a century (range 00 to 99)                        18
#       %Y - year including the century                                     2018
#       %z - UTC offset                                                     +0100
#       %Z - time zone or name or abbreviation                              CST
#       %% - a literal % character                                          %

t = (2023, 4, 20, 10, 39, 45, 1, 48, 0)
t = time.mktime(t)
print (time.strftime("%b %d %Y %H:%M:%S", time.localtime(t)))   #--->  Apr 20 2023 10:39:45



#strptime() Method
#parses a string representing a time according to a format. The return value is a struct_time as returned by gmtime() or localtime().
#time.strptime(string[, format])
#   string − This is the time in string format which would be parsed based on the given format.
#   format − This is the directive which would be used to parse the given string.
struct_time = time.strptime("20 04 2023", "%d %m %Y")
print ("tuple : ", struct_time)     #--->  time.struct_time(tm_year=2023, tm_mon=4, tm_mday=20, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=110, tm_isdst=-1)


#time() Method
#The method time() returns the time as a floating point number expressed in seconds since the epoch, in UTC.
print ("time.time(): %f " % time.time())            #--->  1681930077.653530
print (time.localtime( time.time() ))               #--->  time.struct_time(tm_year=2023, tm_mon=4, tm_mday=20, tm_hour=0, tm_min=17, tm_sec=57, tm_wday=3, tm_yday=110, tm_isdst=0)
print (time.asctime( time.localtime(time.time()) )) #--->  Thu Apr 20 00:17:57 2023


#tzset() Method
#resets the time conversion rules used by the library routines. The environment variable TZ specifies how this is done.
import time
import os
os.environ['TZ'] = 'EST+05EDT,M4.1.0,M10.5.0'
time.tzset()
print(time.strftime('%X %x %Z'))     #--->  14:53:54 04/19/23 EDT
os.environ['TZ'] = 'AEST-10AEDT-11,M10.5.0,M3.5.0'
time.tzset()
print(time.strftime('%X %x %Z'))     #--->  04:56:34 04/20/23 AEST


#############################
##  Calendar Module
#############################	
#calendar.calendar(year,w=2,l=1,c=6)
#Returns a multiline string with a calendar for year year formatted into three columns separated by c spaces. w is the width in characters of each date; each line has length 21*w+18+2*c. l is the number of lines for each week.

	
#calendar.firstweekday( )
#Returns the current setting for the weekday that starts each week. By default, when calendar is first imported, this is 0, meaning Monday.

	
#calendar.isleap(year)
#Returns True if year is a leap year; otherwise, False.

	
#calendar.leapdays(y1,y2)
#Returns the total number of leap days in the years within range(y1,y2).

	
#calendar.month(year,month,w=2,l=1)
#Returns a multiline string with a calendar for month month of year year, one line per week plus two header lines. w is the width in characters of each date; each line has length 7*w+6. l is the number of lines for each week.

	
#calendar.monthcalendar(year,month)
#Returns a list of lists of ints. Each sublist denotes a week. Days outside month month of year year are set to 0; days within the month are set to their day-of-month, 1 and up.

	
#calendar.monthrange(year,month)
#Returns two integers. The first one is the code of the weekday for the first day of the month month in year year; the second one is the number of days in the month. Weekday codes are 0 (Monday) to 6 (Sunday); month numbers are 1 to 12.

	
#calendar.prcal(year,w=2,l=1,c=6)
#Like print calendar.calendar(year,w,l,c).

	
#calendar.prmonth(year,month,w=2,l=1)
#Like print calendar.month(year,month,w,l).

	
#calendar.setfirstweekday(weekday)
#Sets the first day of each week to weekday code weekday. Weekday codes are 0 (Monday) to 6 (Sunday).

	
#calendar.timegm(tupletime)
#The inverse of time.gmtime: accepts a time instant in time-tuple form and returns the same instant as a floating-point number of seconds since the epoch.

	
#calendar.weekday(year,month,day)
#Returns the weekday code for the given date. Weekday codes are 0 (Monday) to 6 (Sunday); month numbers are 1 (January) to 12 (December).




#############################
##  datetime module
#############################	
#1)date
#2)time
#3)datetime
#4)timedelta

#----------------------------
# 1) date
#----------------------------
from datetime import date
date1 = date(2023, 4, 19)
print("Date:", date1)           #--->  Date: 2023-04-19
date2 = date(2023, 4, 31)       #--->  ValueError: day is out of range for month

#date class attributes & methods
#       date.min           The earliest representable date, date(MINYEAR, 1, 1).
#       date.max           The latest representable date, date(MAXYEAR, 12, 31).
#       date.resolution    The smallest possible difference between non-equal date objects.
#       date.year          Between MINYEAR and MAXYEAR inclusive.
#       date.month         Between 1 and 12 inclusive.
#       date.day           Between 1 and the number of days in the given month of the given year.

#       today()                      Return the current local date.
#       fromtimestamp(timestamp)     Return the local date corresponding to the posix timestamp, such as is returned by time.time().
#       fromordinal(ordinal)         Return the date corresponding to the proleptic Gregorian ordinal, where January 1 of year 1 has ordinal 1.
#       fromisoformat(date_string)   Return a date corresponding to a date_string given in any valid ISO 8601 format, except ordinal dates
#       replace()                    Return a date by replacing specified attributes with new values by keyword arguments are specified.
#       timetuple()                  Return a time.struct_time such as returned by time.localtime().
#       toordinal()                  Return the proleptic Gregorian ordinal of the date, where January 1 of year 1 has ordinal 1. For any date object d, date.fromordinal(d.toordinal()) == d.
#       weekday()                    Return the day of the week as an integer, where Monday is 0 and Sunday is 6.
#       isoweekday()                 Return the day of the week as an integer, where Monday is 1 and Sunday is 7.
#       isocalendar()                Return a named tuple object with three components: year, week and weekday.
#       isoformat()                  Return a string representing the date in ISO 8601 format, YYYY-MM-DD:
#       __str__()                    For a date d, str(d) is equivalent to d.isoformat()
#       ctime()                      Return a string representing the date:
#       strftime(format)             Return a string representing the date, controlled by an explicit format string.
#       __format__(format)           Same as date.strftime().


from datetime import date

mindate = date.min      # Getting min date
print("Minimum Date:", mindate)     #--->  0001-01-01
maxdate = date.max      # Getting max date
print("Maximum Date:", maxdate)     #--->  9999-12-31

Date1 = date(2023, 4, 20)
print("Year:", Date1.year)          #--->  Year: 2023
print("Month:", Date1.month)        #--->  Month: 4
print("Day:", Date1.day)            #--->  Day: 20

print (date.today())                    #--->  2023-04-20  

today = date.today()
print(today)
print(today.day)
print(today.month)
print(today.year)
print(today.weekday())

# monday => 0
# tuesday => 1
# wednesday => 2
# thursday => 3
# friday => 4
# saturday => 5
# sunday => 6

d1=date.fromisoformat('2023-04-20')
print (d1)                              #--->  2023-04-20
d2=date.fromisoformat('20230420')
print (d2)                              #--->  2023-04-20
d3=date.fromisoformat('2023-W16-4')
print (d3)                              #--->  2023-04-20

d = date.fromordinal(738630)        # 738630th day after 1. 1. 0001
print (d)                           #--->  2023-04-20
print (d.timetuple())               #--->  time.struct_time(tm_year=2023, tm_mon=4, tm_mday=20, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=110, tm_isdst=-1)
print (d.isoformat())               #--->  2023-04-20                   Methods related to formatting string output
print (d.strftime("%d/%m/%y"))      #--->  20/04/23
print (d.strftime("%A %d. %B %Y"))  #--->  Thursday 20. April 2023
print (d.ctime())                   #--->  Thu Apr 20 00:00:00 2023
print ('The {1} is {0:%d}, the {2} is {0:%B}.'.format(d, "day", "month"))   #--->  The day is 20, the month is April.

t = d.timetuple()       # Methods for to extracting 'components' under different calendars
for i in t:
   print(i)             #--->  2023
                        #      4
                        #      20
                        #      0
                        #      0
                        #      0
                        #      3
                        #      110
                        #      -1
   
ic = d.isocalendar()
for i in ic:
   print(i)                     #--->  2023
                                #      16
                                #      4
   
print (d.replace(month=5))      # A date object is immutable; all operations produce a new object
                                #--->  2023-05-20



#   microsecond          0 <= microsecond < 1000000
#   time.min             The earliest representable time, time(0, 0, 0, 0).
#   time.max             The latest representable time, time(23, 59, 59, 999999).
#   time.resolution      The smallest possible difference between non-equal time objects.
#   time.hour            In range(24)
#   time.minute          In range(60)
#   time.second          In range(60)
#   time.microsecond     In range(1000000)
#   time.tzinfo          the tzinfo argument to the time constructor, or None.

#   replace()           Return a time with the same value, except for those attributes given new values by whichever keyword arguments are specified.
#   isoformat()         Return a string representing the time in ISO 8601 format
#   __str__()           For a time t, str(t) is equivalent to t.isoformat().
#   strftime(format)    Return a string representing the time, controlled by an explicit format string.
#   __format__(format)  Same as time.strftime().
#   utcoffset()         If tzinfo is None, returns None, else returns self.tzinfo.utcoffset(None),
#   dst()               If tzinfo is None, returns None, else returns self.tzinfo.dst(None),
#   tzname()            If tzinfo is None, returns None, else returns self.tzinfo.tzname(None), or raises an exception

#----------------------------
# 2) time
#----------------------------
from datetime import time

time1 = time(8, 14, 36)
print("Time:", time1)       #--->  08:14:36
time2 = time(minute = 12)
print("time", time2)        #--->  00:12:00 
time3 = time()
print("time", time3)        #--->  00:00:00
time4 = time(hour = 26)     #--->  ValueError: hour must be in 0..23

print(time.min)             #--->  00:00:00
print(time.max)             #--->  23:59:59.999999
print(time.resolution)      #--->  0:00:00.000001

t = time(8,23,45,5000)
print(t.hour)               #--->  8
print(t.minute)             #--->  23
print (t.second)            #--->  45
print (t.microsecond)       #--->  5000


#----------------------------
# 3) datetime
#----------------------------

#   microsecond                0 <= microsecond < 1000000,
#   fold                       in [0, 1].
#   datetime.min               The earliest representable datetime, datetime(MINYEAR, 1, 1, tzinfo=None).
#   datetime.max               The latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None).
#   datetime.resolution        The smallest possible difference between non-equal datetime objects, timedelta(microseconds=1).
#   datetime.year              Between MINYEAR and MAXYEAR inclusive.
#   datetime.month             Between 1 and 12 inclusive.
#   datetime.day               Between 1 and the number of days in the given month of the given year.
#   datetime.hour              In range(24)
#   datetime.minute            In range(60)
#   datetime.second            In range(60)
#   datetime.microsecond       In range(1000000)
#   datetime.tzinfo            The object passed as the tzinfo argument to the datetime constructor, or None if none was passed.
#   datetime.fold              In [0, 1]. Used to disambiguate wall times during a repeated interval.
#   today()                    Return the current local datetime, with tzinfo None.
#   now(tz=None)               Return the current local date and time.
#   utcnow()                   Return the current UTC date and time, with tzinfo None.
#   utcfromtimestamp(timestamp)                  Return the UTC datetime corresponding to the posix timestamp, with tzinfo None
#   fromtimestamp(timestamp, timezone.utc)       On the posix compliant platforms, it is equivalent todatetime(1970, 1, 1, tzinfo=timezone.utc) + timedelta(seconds=timestamp)
#   fromordinal(ordinal)                         Return the datetime corresponding to the proleptic Gregorian ordinal, where January 1 of year 1 has ordinal 1.
#   fromisoformat(date_string)                   Return a datetime corresponding to a date_string in any valid ISO 8601 format.
#   date()                      Return date object with same year, month and day.
#   time()                      Return time object with same hour, minute, second, microsecond and fold.
#   timetz()                    Return time object with same hour, minute, second, microsecond, fold, and tzinfo attributes. See also method time().
#   replace()                   Return a datetime with the same attributes, except for those attributes given new values by whichever keyword arguments are specified.
#   astimezone(tz=None)         Return a datetime object with new tzinfo attribute tz
#   utcoffset()                 If tzinfo is None, returns None, else returns self.tzinfo.utcoffset(self)
#   dst()                       If tzinfo is None, returns None, else returns self.tzinfo.dst(self)
#   tzname()                    If tzinfo is None, returns None, else returns self.tzinfo.tzname(self)
#   timetuple()                 Return a time.struct_time such as returned by time.localtime().
#   atetime.toordinal()         Return the proleptic Gregorian ordinal of the date.
#   timestamp()                 Return posix timestamp corresponding to the datetime instance.
#   isoweekday()                Return day of the week as an integer, where Monday is 1, Sunday is 7.
#   isocalendar()               Return a named tuple with three components: year, week and weekday.
#   isoformat(sep='T', timespec='auto')          Return a string representing the date and time in ISO 8601 format
#   __str__()                                    For a datetime instance d, str(d) is equivalent to d.isoformat(' ').
#   ctime()                                      Return a string representing the date and time:
#   strftime(format)                             Return a string representing the date and time, controlled by an explicit format string.
#   __format__(format)                           Same as strftime().




from datetime import datetime

x = datetime.now()
print(x)                    #--->  2024-01-29 18:04:25.319252
print(x.year)               #--->  2024
print(x.strftime("%A"))     #--->  Monday
print(x.strftime("%a"))     #--->  Mon
print(x.strftime("%b"))     #--->  Feb
print(x.strftime("%B"))     #--->  Feburary
print(x.strftime("%d"))     #--->  29
print(x.strftime("%Y"))     #--->  2024
print(x.strftime("%y"))     #--->  24
print(x.strftime("%I"))     #--->  18   (hour)
print(x.strftime("%M"))     #--->  04   (minute)
print(x.strftime("%S"))     #--->  25   (second)
print(x.strftime("%p"))     #--->  pm   (or am)

dt = datetime(2023, 4, 20)          
print(dt)                   #--->  2023-04-20 00:00:00
dt = datetime(2023, 4, 20, 11, 6, 32, 5000)
print(dt)                   #--->  2023-04-20 11:06:32.005000
min = datetime.min
print(min)                  #--->  0001-01-01 00:00:00
max = datetime.max
print(max)                  #--->  9999-12-31 23:59:59.999999
dt = datetime.now()
print(dt.day)               #--->  20 
print(dt.month)             #--->  4
print(dt.year)              #--->  2023 
print(dt.hour)              #--->  15
print(dt.minute)            #--->  5
print(dt.second)            #--->  52

d = date(2022, 4, 20)       
t = time(12, 30)
datetime.combine(d, t)  
d = datetime.now()
print (d)                   #--->  2023-04-20 15:12:49.816343
dt = datetime.strptime("23/04/20 16:30", "%d/%m/%y %H:%M")
tt = dt.timetuple()
for it in tt:
   print(it)        #--->  2020
                    #      4
                    #      23
                    #      16
                    #      30
                    #      0
                    #      3
                    #      114
                    #      -1

ic = dt.isocalendar()
for it in ic:
   print(it)        #--->  2020
                    #      17
                    #      4


#----------------------------
# 4) timedelta
#----------------------------

#timedelta
#The timedelta object represents the duration between two dates or two time objects.
#   microseconds                Between 0 and 999999 inclusive
#   timedelta.min               The most negative timedelta object, timedelta(-999999999).
#   timedelta.max               The most positive timedelta object, timedelta(days=999999999, hours=23, minutes=59, seconds=59, microseconds=999999).
#   timedelta.resolution        The smallest possible difference between non-equal timedelta objects, timedelta(microseconds=1)
#   timedelta.total_seconds()   Return the total number of seconds contained in the duration.

from datetime import timedelta

delta = timedelta(
   days = 100,
   seconds = 27,
   microseconds = 10,
   milliseconds = 29000,
   minutes = 5,
   hours = 12,
   weeks = 2
)
print (delta)       #--->  114 days, 12:05:56.000010           Only days, seconds, and microseconds remain


date1 = datetime.now()
date2= date1+timedelta(days = 4)
print("Date after 4 days:", date2)      #--->  2023-04-24 18:05:39.509905
date3 = date1-timedelta(15)
print("Date before 15 days:", date3)    #--->  2023-04-05 18:05:39.509905

min = timedelta.min     # Getting minimum value
print("Minimum value:", min)        #--->  -999999999 days, 0:00:00
max = timedelta.max
print("Maximum value", max)         #--->  999999999 days, 23:59:59.999999

year = timedelta(days=365)
years = 5 * year
print (years)                   #--->  1825 days, 0:00:00
print (years.days // 365)       #--->  5
year_1 = years // 5
print(year_1.days)              #--->  365



#example
from datetime import datetime
from datetime import timedelta

x = datetime.now()

dt = datetime(2023, 3, 2)
#print(dt.year)
#print(dt.month)
#print(dt.day)

diffdate = x - dt
print(diffdate)
print(timedelta.total_seconds(diffdate))



#example-2
#add a time period to current time (now)

time = datetime.now() + timedelta(days=365, weeks=8, hours=12)  #add 365 days and 8 weeks and 12 hours 
print(time)


##########################################################################################################
#CLASS
##########################################################################################################
#Empty class  
class Empty:  
   pass  

#not empty class
class Employee:         #Class Name ~ <MyClass>

    empCount = 0        #class variable

    #initializer
    #def __init__(self):
        #self.name = "mehrdad"
        #self.age = 24
    def __init__(self, name="mehrdad", age=25):    #Parameterized Constructor  (Attributes)
        self.name = name    #public  properties
        self.__age = age    #private properties     can written like"_age" with single underscore
        Employee.empCount += 1

    def displayEmployee(self):  #Class method / Instance Method
        print ("Name : ", self.name, ", age: ", self.age)

    @staticmethod
    def showcountofemployees():
        print (Employee.empCount)
        return

    def showcount(self):        #class method (by default)
        print (self.empCount)
    counter = classmethod(showcount)



print (Employee.__doc__)        #--->  None
print (Employee.__name__)       #--->  Employee
print (Employee.__module__)     #--->  __main__
print (Employee.__bases__)      #--->  (<class 'object'>,)
print (Employee.__dict__ )      #--->  {'__module__': '__main__', '__init__': <function Employee.__init__ at 0x0000022F866B8B80>, 'displayEmployee': <function Employee.displayEmployee at 0x0000022F866B9760>, '__dict__': <attribute '__dict__' of 'Employee' objects>, '__weakref__': <attribute '__weakref__' of 'Employee' objects>, '__doc__': None}

#Objects from Class
e1 = Employee("christina", 24)
e2 = Employee("Ramadall", 26)
e3 = Employee("John", 27)

print(Employee.empCount)    #--->  3
print(e3.empCount)          #--->  3
e1.showcount()              #--->  3
print(e1.showcount())       #--->  None
Employee.counter()          #--->  3
print(Employee.counter())   #--->  None

del e1.name     #Delete property (the name property from e1 object) 
del e1          #Delete object   (the e1 object)


#-------------------------------------------------------------------
#You can add, remove, or modify attributes of classes and objects at any time
emp1 = Employee("Bharat", 25)
emp1.salary = 7000      # Add a 'salary' attribute.
emp1.name = 'xyz'       # Modify 'name' attribute.
del emp1.salary         # Delete 'salary' attribute.


print  (hasattr(e1, 'salary'))   # Returns true if 'salary' attribute exists
print  (getattr(e1, 'name'))     # Returns value of 'name' attribute
setattr(e1, 'salary', 7000)      # Set attribute 'salary' at 8
delattr(e1, 'age')               # Delete attribute 'age'


#-------------------------------------------------------------------
#add external methods to class 
@classmethod
def showcount2(cls):
    print (cls.empCount)
      
Employee.showcount2() #--->  ???

@classmethod
def newemployee(cls, name, age):
    return cls(name, age)

e4 = Employee.newemployee("Anil", 21)
Employee.showcount2()   #--->  ??? 


@staticmethod
def showcount():
    print (Employee.empCount)
e1.showcount()          #--->  ???
Employee.showcount()    #--->  ???   

#-------------------------------------------------------------------
#Access Point 
#(Public , Private , Protected)
#for attrbutes and methods
 
class Person:
    name     = "amir"   # public    (every where)
    _age     = 32       # protected (inside of class and inheritade class)
    __height = 180      # private   (just inside of class)

    def __show(self):   # private
        print("this show method is private")

class Male(Person):
    def show(self):
        print(self._age)    #--->  32

print(Person._age)  #--->  32 (There is no compulsion(اجبار) just warning about importance of age variable)
print(Person.__height)  #--->  Error
print(Person._Person__height)   #--->  180  (this technique called "Name Mangling")
p = Person()
print(p._Person__height)    #---> 180

p.__show()  #--->  Error
p._Person__show()   #---> THis show method is private #name mangling
#-------------------------------------------------------------------
#Name Mangling
#Python doesn't block access to private data, it just leaves for the wisdom of the programmer, not to write any code that access it from outside the class. 
#You can still access the private members by Python's name mangling technique.
print(e3.__age)             #--->  AttributeError: 'Employee' object has no attribute '__age'
print(e3._Employee__age)    #--->  27



#--------------------------------------------------------------------
#Class Variable
#python class variables evaluate on declaration/import

class A:
    def __init__(self):
        print("this is init from A")

class B:
    one = A()        

#run:
#--->   this is init from A

#if we had a file second.py
#and import we will see class variable will run automaticly
#second.py
'''
from first.py import B
'''   
#run second.py:
#--->  this is init from A

#then we understand that :  must pay attention to class varibles not point to heavy things because will evaluate every time call class




#------------------------------------------------------------------



#example-1
class Heyvoon() :
    __slots__ = ["name","legs"]     #we could say that each instance from this class should have just these properties
    def __init__(self, name, *,legs = 4) :
        self.legs = legs    #has a default value
        self.sound = "Meow"
        self.breath = True
        self.name = name
        self.__id = 123     #this is a private member you cant use it direct just u can use it inside of class and methods of it
    
    def __str__(self):
        return f"Heyvoon is ({self.name}) ({self.sound}) ({self.legs})"   
    
    def __repr__(self):     #for our debugging ... show when you call for debug
        return f'''
            Name  = {self.name}
            Sound = {self.sound}
            legs  = {self.legs}
        ''' 
    
    def talk(self):
        return self.sound

caty = Heyvoon()
tom = Heyvoon("tom", legs = 4) #we fill the slots
print(tom)  #--->  Heyvoon is tom Meow 4                      (because of __str__)
print(tom)  #--->  <__main__.Heyvoon object at 0x1258786688>  (without __str__ func)

print(tom.talk())   #--->  Meow
print(tom.legs)     #--->  4
tom.legs = 3
print(tom.legs)     #--->  3

#add an attribute to object
tomas = Heyvoon()
tomas.age = 5   #this will just add to tomas object not any more (not to main class constructor)

print(tomas.age)    #--->  5
print(tom.age)      #--->  AttributeError - 'heyvoon' object has no attribute 'age'

#-------------------------------------------------------------------
#initializer
#a func which will automatically run when you make an object
def __init__(self):
    self.legs = 4


#-------------------------------------------------------------------





#-------------------------------------------------------------------
#static methods
#methods which are just for class (which are just used inside of classes) not for instance of class
@staticmethod
def is_ID_Valid(id):    #this func is inside of class but without "self" as input
    return type(id) == "str"

#-------------------------------------------------------------------        
#class method
#for make some chages on our class
@classmethod


#Classmethod is decorator and is a tool, 
#which allows us to define methods that are accessible from the class level to the instance level.
#It should be attached to the class itself, not an instance of the class

#The first parameter of the class method is usually called cls, which refers to the class itself.
#The class itself is taken as the first argument.

#This allows the class method to access and manipulate class-level properties and methods.
#In a class method, we can use cls to refer to the class and its properties or methods.
#We can also pass any additional parameters to the class method as needed.


#To call a class method, we can use the class name followed by the method name without creating an instance of the class.

#Advantages of classmethod in Python:
#(1)   Access to class-level properties
#(2)   Providing alternative manufacturers
#(3)   Implementation of operations at the class level


#example for (1)
class MyClass:
    counter = 0

    def __init__(self):
        MyClass.counter += 1

    @classmethod
    def get_instance_count(cls):
        return cls.counter

# Usage
obj1 = MyClass()
obj2 = MyClass()
print(MyClass.get_instance_count())  #--->  2



#example for (2)
import json

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __repr__(self):
        return f"Person(name={self.name}, age={self.age})"

    @classmethod
    def from_json(cls, json_str):
        data = json.loads(json_str)
        return cls(data['name'], data['age'])

# Usage
json_str = '{"name": "kami", "age": 28}'
person = Person.from_json(json_str)
print(person)   #---> Person(name=kami, age=28)



#example for (3)
class Circle:
    pi = 3.14159

    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return Circle.pi * self.radius ** 2

    @classmethod
    def change_pi(cls, new_pi):
        cls.pi = new_pi

# Usage
circle1 = Circle(5)
print(circle1.area())  #--->  78.53975

Circle.change_pi(3.14)  # Changing the value of pi at the class level

circle2 = Circle(3)
print(circle2.area())  #--->  28.26





#example
#use it to track the total number of bank accounts created and provide a unique account number for each account.

class BankAccount:
    total_accounts = 0

    def __init__(self, owner, balance):
        self.owner = owner
        self.balance = balance
        BankAccount.total_accounts += 1

    def deposit(self, amount):
        self.balance += amount

    def withdraw(self, amount):
        if self.balance &gt;= amount:
            self.balance -= amount
        else:
            print("Insufficient balance")

    def get_balance(self):
        return self.balance

    @classmethod
    def get_total_accounts(cls):
        return cls.total_accounts

    @classmethod
    def create_account(cls, owner, balance):
        return cls(owner, balance)

# Usage
account1 = BankAccount("John", 1000)
account2 = BankAccount("Jane", 5000)

print(BankAccount.get_total_accounts())  # Output: 2

account3 = BankAccount.create_account("Alice", 2000)
print(BankAccount.get_total_accounts())  # Output: 3



#--------------------------------------
#instancemethod vs classmethod

#first argument of instance method is self
#first argument of class method    is cls
#first argument of static method   is nothing

#example-2
import datetime
class Person:
    def __init__(self,name,height,age):
        self.name = name
        self.height = height
        self.age = age

    def show(self):     #instancemethod / regularmethod
        print(f"{self.name} is {self.height} and born in {self.age} ")

    @classmethod
    def from_birth(cls,name,height, age):
        return cls(name, height, datetime.datetime.now().year - age)

    @staticmethod
    def is_adult(yearsold):
        if yearsold > 18 :
            print("yes")
        else:
            print("No")    


p1 = Person("ali",170,1998) #instancemethod - instance point to method
p1.show()   #--->  ali is 170 and born in 1998

p2 = Person.from_birth("hasan", 178,1990)   #classmethod - class point to method
p2.show()   #--->  hasan is 178 and born in 33 

Person.is_adult(19) #--->  yes 
#staticmethod is kind of method which related to class object but is independ 



#-------------------------------------------------------------------
#inheritance
class Parandeh2(Heyvoon) :
    def pSound (self):
        return "JICK JICK !!!"

jessie = Parandeh("Jessie")
print(jessie.pSound())  #--->  JICK JICK !!!  
print(jessie.legs)      #--->  4        (because its default value in Heyvoon is 4)
print(jessie.talk())    #--->  Meow


#example2



class Animal():
    def __init__(self, size):
        self.size = size

class AnimalFly:
    def fly(self):
        return f"{self.name} is fly..."

class Bird(Animal):
    def __init__(self, name, age, color):   #override init of animal
        super().__init__()                  #point to father class
        self.name = name
        self.age = age
        self.color = color

    def run(self, mode):
        return f"{self.name} is running {self.mode}"    

class Parrot(Bird):
    def nation(self):
        return f"{self.name} is from africa"

    def run(self):
        return "running slowly..."    

class Eagle(Bird, AnimalFly):
    def dave(self):
        return f"{self.name} daving..."

    def sing(self, song):
        return f"{self.name} is signing {self.song}"    

parrot1 = Parrto("pirro", 6, "green")
print(parrot1.nation())



penguin = Bird()
penguin.color = "red"
penguin.name = "pingu"
penguin.age = 3

chiko = Bird("chikoo", 5)


#///////////////////////////////////////////////////////////////////
#two_layer_init
class Animal:
    def __init__(self, size):
        self.size = size
        

class AnimalFly:
    def fly(self):
        return f"{self.name} is fly..."

class Bird(Animal):
    def __init__(self, name, age, color):   #override init of animal
        super().__init__()                  #point to father class
        self.name = name
        self.age = age
        self.color = color

    def run(self, mode):
        return f"{self.name} is running {self.mode}"    

class Parrot(Bird):
    def nation(self):
        return f"{self.name} is from africa"

    def run(self):
        return "running slowly..."    

class Eagle(Bird, AnimalFly):
    def dave(self):
        return f"{self.name} daving..."

    def sing(self, song):
        return f"{self.name} is signing {self.song}"    

parrot1 = Parrot(name="pirro", age=6, color="green" )
print(parrot1.nation())



#penguin = Bird()
#penguin.color = "red"
#penguin.name = "pingu"
#penguin.age = 3

#chiko = Bird("chikoo", 5)

#///////////////////////////////////////////////////////////////////

#-------------------------------------------------------------------
#Method Overriding
#you may want special or different functionality in your subclass
class Parent: 
   def myMethod(self):
      print ('Calling parent method')

class Child(Parent): 
   def myMethod(self):
      print ('Calling child overrided method')

c = Child() 
c.myMethod()  #--->  Calling child overrided method   (child calls overridden method)

#example
class Employee:
    def __init__(self,nm, sal):
        self.name   = nm
        self.salary = sal
    def getName(self):
        return self.name
    def getSalary(self):
        return self.salary
    
class SalesOfficer(Employee):
    def __init__(self,nm, sal, inc):
        super().__init__(nm,sal)    #add parent arguments to child
        self.incnt = inc
    def getSalary(self):        #this method is overrided
        return self.salary + self.incnt
    
e1=Employee("Rambo", 9000)
print ("Total salary for {} is {}$".format(e1.getName(),e1.getSalary()))   #--->  Total salary for Rambo is 9000 $
s1=SalesOfficer('arnold', 10000, 1000)
print ("Total salary for {} is {}$".format(s1.getName(),s1.getSalary()))   #--->  Total salary for arnold is 11000 $


#Base Overridable Methods
#these are methods which are inside of our class defultly and you can ovverride and change them for yourself

#__init__ ( self [,args...] )       Constructor (with any optional arguments)   
#                                   Sample Call : obj = className(args)

#__del__( self )                    Destructor, deletes an object
#                                   Sample Call : del obj

#__repr__( self )                   Evaluatable string representation
#                                   Sample Call : repr(obj)

#__str__( self )                    Printable string representation
#                                   Sample Call : str(obj)


#-------------------------------------------------------------------
#The __init__() Function 


class Person:
  def __init__(self, fname, lname):
    self.firstname = fname
    self.lastname = lname

  def printname(self):
    print(self.firstname, self.lastname)

class Student(Person):
  def __init__(self, fname, lname):
    Person.__init__(self, fname, lname)
    #or
    super().__init__(fname, lname)

x = Student("Mike", "Olsen")
x.printname()





#-------------------------------------------------------------------
#Method Overloading
#Python doesn't support overloading
class example:
   def add(self, a, b):
      x = a+b
      return x
   def add(self, a, b, c):
      x = a+b+c
      return x

obj = example()

print (obj.add(10,20,30))   
print (obj.add(10,20))      #--->  TypeError: example.add() missing 1 required positional argument: 'c'

#we can use a workaround by defining default value to method arguments as None
class example:
    def add(self, a = None, b = None, c = None):
        x=0
        if a !=None and b != None and c != None:
            x = a+b+c
        elif a !=None and b != None and c == None:
            x = a+b
        return x

obj = example()

print (obj.add(10,20,30))   #--->  60
print (obj.add(10,20))      #--->  30    


#a better way is that defining default values to method arguments as 0 for this example
#as you see the solution is defining default values to method arguments


#-------------------------------------------------------------------
#Abstraction
from abc import ABC, abstractmethod
class democlass(ABC):
   @abstractmethod
   def method1(self):
      print ("abstract method")
      return
   def method2(self):
      print ("concrete method")

class concreteclass(democlass):
   def method1(self):
      super().method1()
      return
      
obj = concreteclass()
obj.method1()   #--->  abstract method
obj.method2()   #--->  concrete method


#-------------------------------------------------------------------
#Interface
#An abstract class and interface appear similar in Python
#The only difference in two is that: 
#   the abstract class may have some non-abstract methods, 
#while :
#   all methods in interface must be abstract, and the implementing class must override all the abstract methods.
from abc import ABC, abstractmethod

class demoInterface(ABC):
   @abstractmethod
   def method1(self):
      print ("Abstract method1")
      return

   @abstractmethod
   def method2(self):
      print ("Abstract method1")
      return

obj = demoInterface()   #--->  TypeError: Can't instantiate abstract class demoInterface with abstract methods method1, method2

class concreteclass(demoInterface):
   def method1(self):
      print ("This is method1")
      return
   
   def method2(self):
      print ("This is method2")
      return
      
obj = concreteclass()
obj.method1()   #--->  This is method1
obj.method2()   #--->  This is method2






        
#-------------------------------------------------------------------
#Polymorphism
#Polymorphism is often used in Class methods, where we can have multiple classes with the same method name.
class Car:
    def __init__(self, brand, model):
        self.brand = brand
        self.model = model

    def move(self):
        print("Drive!")

class Boat:
    def __init__(self, brand, model):
        self.brand = brand
        self.model = model

    def move(self):
        print("Sail!")

class Plane:
    def __init__(self, brand, model):
        self.brand = brand
        self.model = model

    def move(self):
        print("Fly!")

car1   = Car("Ford", "Mustang")       #Create a Car class
boat1  = Boat("Ibiza", "Touring 20")  #Create a Boat class
plane1 = Plane("Boeing", "747")       #Create a Plane class

for x in (car1, boat1, plane1):
  x.move()  #--->  ???




#Inheritance Class Polymorphism
class Vehicle:
    def __init__(self, brand, model):
        self.brand = brand
        self.model = model

    def move(self):
        print("Move!")

class Car(Vehicle):
    pass

class Boat(Vehicle):
    def move(self):
        print("Sail!")

class Plane(Vehicle):
    def move(self):
        print("Fly!")

car1   = Car("Ford", "Mustang") #Create a Car object
boat1  = Boat("Ibiza", "Touring 20") #Create a Boat object
plane1 = Plane("Boeing", "747") #Create a Plane object

for x in (car1, boat1, plane1):
    print(x.brand)
    print(x.model)
    x.move()
    #--->  ???


#-------------------------------------------------------------------
#Dynamic Binding
#dynamic binding is the process of resolving a method or attribute at runtime, instead of at compile time.
#According to the polymorphism feature, different objects respond differently to the same method call based on their individual implementations. This behavior is achieved through method overriding, where a subclass provides its own implementation of a method defined in its superclass.
class shape:
   def draw(self):
      print ("draw method")
      return

class circle(shape):
   def draw(self):
      print ("Draw a circle")
      return

class rectangle(shape):
   def draw(self):
      print ("Draw a rectangle")
      return

shapes = [circle(), rectangle()]
for shp in shapes:
   shp.draw()   #--->  Draw a circle
                #      Draw a rectangle



#-------------------------------------------------------------------
#Duck Typing
#Duck typing is an important feature of dynamic typing languages like Python (Perl, Ruby, PHP, Javascript, etc.) that focuses on an object's behavior rather than its specific type. According to the "duck typing" concept, "If it walks like a duck and quacks like a duck, then it must be a duck."
#Duck typing allows objects of different types to be used interchangeably as long as they have the required methods or attributes. The goal is to promote flexibility and code reuse. It is a broader concept that emphasizes on object behavior and interface rather than formal types.
class circle:
   def draw(self):
      print ("Draw a circle")
      return

class rectangle:
   def draw(self):
      print ("Draw a rectangle")
      return

class area:
   def area(self):
      print ("calculate area")
      return

def duck_function(obj):
   obj.draw()

objects = [circle(), rectangle(), area()]
for obj in objects:
   duck_function(obj)   #--->  Draw a circle
                        #      Draw a rectangle
                        #      AttributeError - 'area' object has no attribute 'draw'

#-------------------------------------------------------------------
#Inner Classes
#A class defined inside another class is known as an inner class in Python
#Sometimes inner class is also called nested class.
class student:
    def __init__(self):
        self.name = "Ashish"
        self.subs = self.subjects()
        return
    def show(self):
        print ("Name:", self.name)
        self.subs.display()

    class subjects:
        def __init__(self):
            self.sub1 = "Phy"
            self.sub2 = "Che"
            return
        def display(self):
            print ("Subjects:",self.sub1, self.sub2)
         
s1 = student()
s1.show()   #--->  Name: Ashish
            #      Subjects: Phy Che

sub = student().subjects().display()    #--->  ???

#-------------------------------------------------------------------
#Nested Class

class One:
    def show1(self):
        print("I am outer class")
        t = self.Two()
        t.show2()

    class Two:
        def show2(self):
            print("I am inner class")    

o1 = One()
o1.show1()

o2 = One().Two()
o2.show1()          #---> Error - AttributeError
o2.show2()

#Very few of them are used in real projects
#These classes must be very related to each other
#for example:

class Person:

    class Heart:
        pass

#I want to make sure that I never need to access the internal class directly in the future

#class meta in django models is one of best example for nested classes

#-------------------------------------------------------------------
#Anonymous Class and Objects (Type Class)
#In Python, a class, both a built-in class or a user-defined class are objects of type class.
class myclass:
   def __init__(self):
      self.myvar=10
      return
      
obj = myclass()


print ('class of myclass', type(myclass))   #--->  <class 'type'>
print ('class of obj', type(obj))       #--->  <class 'type'>

print ('class of int', type(int))       #--->  <class 'type'>
print ('class of list', type(list))     #--->  <class 'type'>
print ('class of dict', type(dict))     #--->  <class 'type'>

#We can create an anonymous class with the above version of type() function
#<classname> = type(<name>, <bases>, <dict>)

anon = type('', (object, ), {})

obj  = anon()
print ("type of obj:", type(obj))   #--->  <class '__main__.'>

#We can also add instance variables and instance methods dynamically
#example
def getA(self):
   return self.a
obj = type('',(object,),{'a':5,'b':6,'c':7,'getA':getA,'getB':lambda self : self.b})()
print (obj.getA(), obj.getB())  #--->  5


#-------------------------------------------------------------------
#Reflection
#reflection refers to the ability to extract information about any object in use
#You can get to know the type of object, is it a subclass of any other class, what are its attributes and much more.

#The type() Function
#We have used this function many times. It tells you which class does an object belong to.

print (type(10))                 #--->  <class 'int'>
print (type(2.56))               #--->  <class 'float'>
print (type(2+3j))               #--->  <class 'complex'>
print (type("Hello World"))      #--->  <class 'str'>
print (type([1,2,3]))            #--->  <class 'list'>
print (type({1:'one', 2:'two'})) #--->  <class 'dict'>


#type of an object of a user-defined class
class test:
    pass
obj = test()
print (type(obj))   #--->  <class '__main__.test'>


#The isinstance() Function
#ascertains if an object is an instance of the given class
print (isinstance(10, int))                 #--->  True
print (isinstance(2.56, float))             #--->  True
print (isinstance(2+3j, complex))           #--->  True
print (isinstance("Hello World", str))      #--->  True
print (isinstance([1,2,3], tuple))          #--->  False
print (isinstance({1:'one', 2:'two'}, set)) #--->  False

#You can also perform check with a user defined class
class test:
    pass
obj = test()
print (isinstance(obj, test))   #--->  True

#In Python, even the classes are objects. All classes are objects of object class.
class test:
    pass   
print (isinstance(int, object))  #--->  True
print (isinstance(str, object))  #--->  True
print (isinstance(test, object)) #--->  True


#The issubclass() Function
#all Python classes are subclassed from object class.
class test:
    pass
   
print (issubclass(int, object))  #--->  True 
print (issubclass(str, object))  #--->  True
print (issubclass(test, object)) #--->  True


#-------------------------------------------------------------------
#The callable() Function
#An object is callable if it invokes a certain process
#A Python function, which performs a certain process, is a callable object.

def test():
    pass
   
print (callable("Hello"))           #--->  ???
print (callable(abs))               #--->  ???
print (callable(list.clear([1,2]))) #--->  ???
print (callable(test))              #--->  ???


class test:
    def __init__(self):
        pass
    def __call__(self):
        print ("Hello")
      
obj = test()
obj()       #--->  Hello
print ("obj is callable?", callable(obj))   #--->  True



#-------------------------------------------------------------------
#The dir() Function
#it returns a list the attributes of the given object, and of attributes reachable from it.

#For a module object :    the function returns the module's attributes.
#For a class object :     the function returns its attributes, and recursively the attributes of its bases.
#For any other object :   its attributes, its class's attributes, and recursively the attributes of its class's base classes.

print ("dir(int):", dir(int))   #--->  dir(int): ['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__getstate__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'as_integer_ratio', 'bit_count', 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'numerator', 'real', 'to_bytes']
print ("dir(dict):", dir(dict)) #--->  dir(dict): ['__class__', '__class_getitem__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__ior__', '__iter__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__or__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__ror__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values']

class test:
    def __init__(self):
        self.name = "Manav"

obj = test()
print ("dir(obj):", dir(obj))   #--->  dir(obj): ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'name']



#-------------------------------------------------------------------
#initialier of child will replace to parent 
class Parandeh(Heyvoon) :
    def __init__(self) :    #this will replace to Heyvoon initializer
        self.sound = "Juruh Juruh"
        
    def talk(self):
        return self.sound
    
jey = Parandeh("Jey")
print(jey.legs)     #--->  AttributeError - 'Parandeh' object has no attribute 'legs'    

#-------------------------------------------------------------------        
#use initializer of parent manually
class Parandeh(Heyvoon) :
    def __init__() :
        Heyvoon.__init__()

#-------------------------------------------------------------------        
#use initializer of parent manually with changes
class Parandeh(Heyvoon) :
    def __init__(self, name, *, legs = 4) :
        #Heyvoon.__init__(self, name, legs = legs)  
        super().__init__(name, legs = legs)     #we can use super() inplace of parent initializer     
        self.sound = "Hop"
        

#-------------------------------------------------------------------
#multiple inheritance
class division:
    def __init__(self, a,b):
        self.n=a
        self.d=b
    def divide(self):
        return self.n/self.d
class modulus:
    def __init__(self, a,b):
        self.n=a
        self.d=b
    def mod_divide(self):
        return self.n%self.d
      
class div_mod(division,modulus):
    def __init__(self, a,b):
        self.n=a
        self.d=b
    def div_and_mod(self):
        divval=division.divide(self)
        modval=modulus.mod_divide(self)
        return (divval, modval)


#???
class Heyparand(Heyvoon,Parandeh) :
    def __init__(self, name , legs) :
        #Heyvoon.__init__(self, name, legs = legs)
        #Parandeh.__init__(self, name, legs = legs)
        super().__init__(name, legs = legs)   #no need tp self as first parameter
        
    
#heyparand will get every thing from Heyvoon because writed first then if there is something which is not in 
#Heyvoon will get from Parandeh second

#-------------------------------------------------------------------    
#hierarchy of multiple inheritance
help(Heyparand)     #--->  ???    
heyparand.issubclass(Parandeh)  #--->  ???    
    



#-------------------------------------------------------------------
#MULTI_INHERITANCE
#-------------------------------------------------------------------
#It will create many problems and complications for our code.

class A:
    def show(self):
        return 'show method ...'

class B:
    def say(self):
        return 'say method ...'

class C(B, A):
    pass

c1 = C()            # you can access to methods of class A & B from C
print(c1.show())
print(c1.say())



#example2
class Vehicle:
    def __init__(self, name, )
        self.name = name
        self.speed = speed

    def show(self):
        return f'{self.name} top speed is {self.speed}'

class Car:
    def joy(self):
        return f'Driving {self.name} is awesome...'

class Motor:
    def joy(self):
        return f'Riding {self.name} is awesome...'

class Sedan(Car, Vehicle):
    pass

class Retro(Motor, Vehicle):
    pass

s1 = Sedan('pride', 180)
print(s1.show())
print(s1.joy())

#---------------
#Diamond Problem
#example-3
class A:
    a_calls = 0
    def call(self):
        print('Calling A class... ')
        A.a_calls += 1

class B(A):
    b_calls = 0
    def call(self):
        print('Calling B class... ')
        B.b_calls += 1
        super().call()

class C(A):
    c_calls = 0
    def call(self):
        print('Calling C class... ')
        C.c_calls += 1
        super().call()

class D(C, B):  # wil affect on MRO (first C then B)
    d_calls = 0
    def call(self):
        print('Calling C class... ')
        C.c_calls += 1
        super().call()

d1 = D()
d1.call()
print(d1.d_calls)
print(d1.c_calls)
print(d1.b_calls)
print(d1.a_calls)  
help(d1)    #---> Method Resolution Order (MRO) ---> { D -> C -> B -> A}                                  

#       A
#    .      .
#  .          .
# B             C   
#  .          .
#    .      .
#       D



#example-4
class A:
    def call(self, a=''):
    print(f'Class A=> {a}')

class B:
    def call(self, b='', a='', **kwargs):
        print(f'Class B => {b} {a}')
        kwargs['a'] = a
        super().call(**kwargs)

class C(B, A):
    def call(self, c='', **kwargs):
        print(f'Class C => {c}')
        super().call(**kwargs)

c1 = C()
c1.call(a='aaaa', b='bbbb', c='cccc')        

#-------------------------------------------------------------------
#inheriting built-in objects

#used for Personalization a built-in object like list, dict, ...

class StringList(list):
    def append(self, element):
        if not isinstance(element, str):
            raise TypeError('this list only accepts strings')
        return super().append(element)
        #or
        #self.append(element)

a = StringList()
a.append('a')
a.append('b')

print(a)    #--->  ['a','b']

a.append(34)
print(a)    #--->  Error - TypeError 'this list only accepts strings'

#-------------------------------------------------------------------
#Queue And Stack in Class
class Queue (list) :
    def ad(self, obj) :
        self.append(obj)
    def rm (self) :
        self.pop(0)
    
class Stack (list) :
    def ad(self, obj) :
        self.append(obj)
    def rm (self) :
        self.pop()    


q1 = Queue()
q1.ad(5)
q1.ad(7)
q1.rm()
print(q1)

s1 = Stack()
s1.ad(5)
s1.ad(7)
s1.rm()
print(s1)

#-------------------------------------------------------------------
#MIXIN
#-------------------------------------------------------------------
#mixin class
#Classes that do not do anything special by themselves are called mixins.
#for reduce number of code inside of classes we seperated them but send mixin class as a parent
#mixins add some funcs to all classes which use them on mixin as parent
#we never use mixin classes directly we always use mixin classes as parent for other classes

class ReprintMixin:
    def reprint(self, price_up_percent):
        self.price += self.price * (price_up_percent / 100)

#-------------------------------------------------------------------
#Singleton Class
#A Singleton class is a class of which only one object can be created
#When an instance of a Python class declared, it internally calls the __new__() method
#We override the __new__() method that is called internally by Python when you create an object of a class.
#If the instance variable is None, it creates a new object and call the super()

class SingletonClass:
    _instance = None
   
    def __new__(cls):
        if cls._instance is None:
            print('Creating the object')
            cls._instance = super(SingletonClass, cls).__new__(cls)
        return cls._instance
      

obj1 = SingletonClass()
print(obj1)     #--->  Creating the object
                #--->  <__main__.SingletonClass object at 0x000002A5293A6B50>
#If multiple objects are created, it becomes clear that the object is only created the first time; after that, the same object instance is returned.
obj2 = SingletonClass()
print(obj2)     #--->  <__main__.SingletonClass object at 0x000002A5293A6B50>



#-------------------------------------------------------------------
#Constructor is Compilation of __new__ & __init__
#if we want to speak detailly __new__ is constructor and __init__ is initialized
#example2
class Library:
    """
    doc string for singleton class
    """
    __instance = None
    def __new__(cls):
        if cls.__instance is None:
            cls.__instance = super().__new__(cls)   #super is type(built in parent)(metaclass)
                                                    #make an instance for cls from built
        return cls.__instance    

   # def __init__(self):
        """
        doc string for init
        """
        #self.books = []

    def add_book(self, book):
        """
        doc string for add_book
        """
        try:    
            self.books.append(book)
        except AttributeError:
            self.books = [book]



lib1 = Library()
print(lib1)     #--->  <__main__.Library object at 0x5812545ef5>
lib1.add_book("physics")
print(lib1.books)   #--->  physics
lib2 = Library()
print(lib2)     #--->  <__main__.Library object at 0x5812545ef5>
                # it puted two object in on place of memory . in fact we just have one object
print(lib2.books)   #--->  physics
print()




##########################################################################################################
#DUNDER_METHODS
##########################################################################################################
#its also called special methods (SPECIAL_METHODS), magic methods (MAGIC_METHODS) and (dunder)

#methods which are have _ in their names like "__init__()"
#python provide these methods for us to use in our codes in classes
# _ is called underscore
#if a name had two _ at left and two _ at right (before and after name) it called dunder
#for example:
#  fullname()   --->  called fullname method
#__fullname__() --->  called dunder fullname


#------------------------------------------------
#__str__()

class Car:
    def __init__(self,name,price):  #initializer
        self.name  = name
        self.price = price

    def show(self):
        print(f"i have a {self.name}")

a = Car("pride", 2000)
b = Car("samand", 4000)

print(a)    #--->  <__main__.Car object at 0x7fc2c5392f10>

#for change this description about your object you can use __str__() method

class Car:
    def __init__(self,name,price):  #initializer
        self.name  = name
        self.price = price

    def show(self):
        print(f"i have a {self.name}")

    def __str__(self):
        return f"{self.name} is a car which you have with {self.price}$ price"
    
a = Car("pride", 2000)
b = Car("samand", 4000)

print(a) #--->  pride is a car which you have with 2000$ price




#example-1
class Person:
  def __init__(self, name, age):
    self.name = name
    self.age = age

p1 = Person("John", 36)

print(p1)   #--->  <__main__.Person object at 0x15039e602100>

#example-2
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __str__(self):
        return f"name is : {self.name} | age is : {self.age}" 

p1 = Person("John", 36)

print(p1)   #--->  name is : John | age is : 36



#------------------------------------------------
#__repr__()


class Person:
    def __init__(self, name, age):
        self.name = name
        self.age  = age

    def __str__(self):
        return "Person STR"
        #return f"{self.name!s} is {self.age!s} years old."    #best way to write str result to user

    def __repr__(self):
        return "Person REPR"
        #return f"{self.__class__.__name}({self.name!r}, {self.age!r})"     #best way to write

p = Person("ali", 23)

print(p)    #if __str__ was comment --->  Person REPR
            #else                   --->  Person STR

print(str(p))   #--->  Person STR
print(repr(p))  #--->  Person REPR

#inside of python command line:

#>>p        --->  Person REPR
#>>str(p)   --->  Person STR
#>>repr(p)  --->  Person REPR            


#__str__()      for result and show it to user 
#__repr__()     for debug and show result to other coder


#example-2
import datetime
now = datetime.datetime.now()
#>>str(now)   --->  '2019-04-28 10:29:22.782219'                            #for result
#>>repr(now)  --->  'datetime.datetime(2019, 4, 28, 10, 29, 22, 782219)'    #for debug and show result to other coder





#------------------------------------------------
#__add__()

class Car:
    def __init__(self,name,price):  
        self.name  = name
        self.price = price

    def show(self):
        print(f"i have a {self.name}")

a = Car("pride", 2000)
b = Car("samand", 4000)

print(a + b)    #--->  Error - TypeError: unsupported operand type(s)

#python dont know how it should add two object of same class we must say it by __add__() method
#in __add__() method we say to python how it should add to object of same class
 
class Car:
    def __init__(self,name,price):  
        self.name  = name
        self.price = price

    def show(self):
        print(f"i have a {self.name}")

    def __add__(self, other):   #self is first object and other is second object
        return self.price + other.price 

a = Car("pride", 2000)
b = Car("samand", 4000)

print(a + b)    #--->  6000




#------------------------------------------------
#__len__()

class Car:
    def __init__(self,name,price):  
        self.name  = name
        self.price = price

    def show(self):
        print(f"i have a {self.name}")

    def __len__(self):
        return len(self.name)

a = Car("pride", 2000)
b = Car("samand", 4000)

print(len(a))   #before __len__() --->  Error - TypeError: object of type car has no len()
                #after  __len__() --->  5




#------------------------------------------------
#__reversed__()

L1 = [2, 4, 6, 8]
print(list(reversed(L1))) #--->  [8, 6, 4, 2]
L2 = "amir"
print(reversed(L2)) #--->  ['r', 'i', 'm', 'a']

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age  = age

    def __reversed__(self):
        return self.name[::-1]
a = Person("amir", 29)        

print(reversed(a))  #before __reversed__() ---> Error - TypeError: 'Person' object is not reversible
                    #after  __reversed__() --->  rima








#------------------------------------------------
#__slots__()
#__dict__()
#it desable dynamic attributes


class Person:
    def __init__(self):
        self.name   = "amir"
        self.age    = 20
        self.height = 180

p1 = Person()
p2 = Person()

print(p1.__dict__)  #--->  {name : amir , age : 20 , height : 180}
print(p2.__dict__)  #--->  {name : amir , age : 20 , height : 180}

print(p1.__dict__ is p2.__dict__)   #--->  False
print(p1.__dict__['name'] is p2.__dict__['name'])   #--->  True

#the problem is that...
#whenever we make an object from class python will produce this dicts and will save them on memory
#this will take memory size
#if we use __slots__ then dicts will be disable

class Person:
    __slots__ = ['name', 'age', 'height']
    def __init__(self):
        self.name   = "amir"
        self.age    = 20
        self.height = 180

p1 = Person()
p2 = Person()

print(p1.__dict__)  #--->  Error - AttributeError
print(p2.__dict__)  #--->  Error - AttributeError   

print(p1.__dict__ is p2.__dict__)   #--->  False


print(p1.__slots__)  #--->  ['name', 'age', 'height']
print(p2.__slots__)  #--->  ['name', 'age', 'height']   

print(p1.__slots__ is p2.__slots__)   #--->  True

#you cant add attribute to class
p1.number = 299 #--->  Error


#__dict__()
class Person:
    def __init__(self,name):
        self.name = name

p = Person("Amir")

print(p.__dict__)       #--->  ???
print(Person.__dict__)  #--->  ???




#------------------------------------------------
#__container__()
#container object
nums = [1, 2, 3, 4, 5]
print(5 in nums)        #--->  True
print(4 not in nums)    #--->  False


class Person:
    def __init__(self,name,country):
        self.name    = name
        self.country = country

    def __contains__(self, item):
        if item in self.country :
            return True

p1 = Person("amir", "Iran")
p2 = Person("jack", "Canada")

print("Iran" in p1)     #--->  True
print("Iran" not in p2) #--->  True


#example
from collections.abc import Container
class One:
    def __str__(self):
        pass

print(issubclass(One, Container))   #--->  False    

class One:
    def __str__(self):
        pass
    def __contains__(self,item):
        pass

print(issubclass(One, Container))    #--->  True
a = One()
print(issubclass(a, Container))    #--->  False




#------------------------------------------------
#__next__() and __iter__()

#iteration , iterator , iterable => iterate
for i in range(10):
    print(i)       

#we do iterate    
#this operation called "iteration"
#rage() is an iterable object
# i is iterator


#YIELD
#yield has two property:
#   1) like return but let us to give output in dynamic way
#   2) make object iterable and let us to iterate on an object    


#commands after 'retrun' are unreachable 


#way-1
class Friends:
    def __init__(self):
        self.names = ["alexa", "roberto", "eliza", "marko", "vladmir"]

    def __iter__(self):
        return iter(self.names)   
        #or
        #return self.names__iter__()
        #or
        #for name in self.names:
        #   yield name      
    def __next__(self):
        names_copy = self.names
        if names_copy:
            return names_copy.pop()
        else:
            raise StopIteration


f = Friends()
for x in f:
    print(x, end=' ')    #--->  alexa roberto eliza marko vladmir

print(next(f))  #--->  alexa
print(next(f))  #--->  roberto
print(next(f))  #--->  eliza
print(next(f))
print(next(f))
print(next(f))  #--->  Error - StopIteration



#way-2
class Friends:
    def __init__(self):
        self.names = ["alexa", "roberto", "eliza", "marko", "vladmir"]

    def __iter__(self):
        self.names_copy = self.names

    def __next__(self):
        if self.names_copy:
            return self.names_copy.pop()
        else:
            raise StopIteration        



f = Friends()
x = iter(f)
print(next(x))  #--->  vladmir
print(next(x))  #--->  marko
print(next(x))  #--->  eliza
print(next(x))
print(next(x))
print(next(x))

#-------------------------------------------------------------------
#Create an Iterator
class MyNumbers:
    def __iter__(self):
        self.a = 1
        return self

    def __next__(self):
        if self.a <= 20:
            x = self.a
            self.a += 1
            return x
        else:
            raise StopIteration
    
myclass = MyNumbers()
myiter = iter(myclass)

print(next(myiter)) #--->  ???
print(next(myiter)) #--->  ???
print(next(myiter)) #--->  ???
print(next(myiter)) #--->  ???
print(next(myiter)) #--->  ???

for x in myiter:
    print(x)  #--->  ???


#------------------------------------------------
#comparison methods
#python comparison methods to compare between objects of class

"""
    __eq__      equal               x == y
    __ne__      not equal           x != y or x <> y
    __lt__      lower than          x < y
    __le__      lower than equal    x <= y
    __gt__      greater than        x > y
    __ge__      greater than equal  x >= y
"""

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age  = age

p1 = Person("jack", 20)
p2 = Person("jack", 20)

print(id(p1))   #--->  139675004813072 
print(id(p2))   #--->  139675004813216

print(p1 == p2)     #--->  False
                    #      by default python check id  


#to correct this...

class Human:
    def __init__(self, name, age):
        self.name = name
        self.age  = age
    
    def __eq__(self, other):
        if isinstance(other, self__class__):
            return self.name == other.name and self.age == other.age
        else:
            return False

    def __ne__(self, other):
        if isinstance(other, self__class__):
            return self.name != other.name or self.age != other.age
        else:
            return False

class Alien:
    def __init__(self, name, age):
        self.name = name
        self.age  = age


h1 = Human("jack", 20)
a1 = Alien("jack", 20)

print(h1 == a1) #python will go to __eq__() in Human
print(a1 == h1) #because a does not have __eq__() python will go to __eq__() in Human




#------------------------------------------------
#__hash__
#mostly use with __eq__ in classes

#without use __hash__ and __eq__
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age  = age

p1 = Person("amir", 34)
p2 = Person("amir", 17)

print(hash(p1)) #--->  8772260206833
print(hash(p2)) #--->  8772260206842


#with use __hash__ and __eq__
from collections.abc import Hashable
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age  = age

    def __hash__(self):
        return hash(self.name)

    def __eq__(self, other):
        if self.name == other.name:
            return True


p1 = Person("amir", 34)
p2 = Person("amir", 17)

print(hash(p1)) #--->  -8660708913508619158
print(hash(p2)) #--->  -8660708913508619158

print(isinstance(p1, Hashable)) #--->  True


#------------------------------------------------
#__call__()
#when we call an object of class like function
class Person:
    def __call__(self, name = "nameless", *args, **kwargs):
        print(name)

p1 = Person()
p1("amir")  #--->  amir
p1()        #--->  nameless

#------------------------------------------------
#__new__()

class Person:
    def __init__(self, name): # initializer
        self.name = name

    def __new__(cls, name, *args, **kwargs): # constructor
        if name == 'john':
            return None
        else :
            return super().__new__(cls, *arg, **kwargs)    

p1 = Person("john")
p1 = Person("amir")

print(p1)
print(p2)



#------------------------------------------------
#__init__()

#before python version 3.3 __init__.py file must be exist (even an empty file) if you want to use a package
#other side you cant use a directory as package
#after python version 3.3 there no problem

#when we import a package from outside automatically __init__.py will execute 
#and if we import all methods of modules inside __init__.py we dont need to call module name in package
#for example:
#import requests
#requests.api.get()  =>  requests.get()
#if 
#inside of __init__.py file we had this line:
#from api import get,set





#------------------------------------------------
#__all__()

#inside of a module we define methods which we want be available for users of module with __all__()
#inside of a module we define classes with _ to users cant see them and just used inside of pack

#for example:
#in collection module :
#__all__ = ['deque', 'UserList', 'UserDict', 'Counter', 'Chainmap'] 

#__all__ just activated when we import module with * :
#for example:
#from collections import *



#in big scale projects like django we use __all__ to provide quick access to methods
#for example:
#from django import forms
#forms.widgets.Media() 

#if we add all methods inside __init__.py
#like:
#from django.forms.widgets import *

#and
#add __all__ inside of all modules (inside of widgets.py)
#now  you can do:
#forms.Media() 
#instead of:
#forms.widgets.media()


#------------------------------------------------
#__missing__


class MyDict(dict):
    def __missing__(self, key):
        return 'default-value'  #or any other thing

users = MyDict({"amir":12, 'jack':23})
print(users['bob']) #--->  default-value         


#------------------------------------------------
#__name__
#one of special variables which python automaticly fill it when you run a .py file

#if we run this code inside of first.py
print(f"__name__ => {__name__}")    #--->  __name__ => __main__


#but if it runs from other module (.py file) like second.py it will print name of module
#for example:
#if we run this code inside of second.py
import first
#--->  __name__ => __first__


#usecase of __name__ :

if __name__ == "__main__" :
    main()      # if we were inside of current module run main func of module

#------------------------------------------------
#__context__ & __cause__
#when occured an exception inside of other exception
#python will save status of first exception inside of 'context'
#'cause' is explicit and used           (we use)        (assigned by ourselves)
#'context' is implicit and not used     (python use)    (assigned by python)
    #if 'cause' used then 'context' will be empty
    #if 'context' used then 'cause' will be empty

#__cause__ just accept 'Exception' or 'None'


#try:
#    raise ValueError('value error')
#except Exception:
#    raise TypeError('type error')    
#--->
"""
Traceback (most recent call last):
  File "main.py", line 4, in <module>
    raise ValueError('value error')
ValueError: value error
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "main.py", line 6, in <module>
    raise TypeError('type error') 
TypeError: type error
"""
#example-1
try:
    try:
        raise ValueError('value error')
    except Exception:
        raise TypeError('type error')   
except Exception as two:
    print(two)              #--->  type error
    print(two.__context__)  #--->  value error
    print(two.__cause__)    #--->  None

#example-2
try:
    try:
        raise ValueError('value error')
    except Exception:
        raise TypeError('type error')  from ImportError('import error')  
except Exception as two:
    print(two)              #--->  type error
    print(two.__context__)  #--->  value error
    print(two.__cause__)    #--->  import error







#show an error as another error
#example
class DatabaseError(Exception):
    pass

class FileDatabase(Database):
    def __init__(self, filename):
        try:
            self.fie = open(filename)
        except IOError, exc:
            raise DatabaseError("failed to open") from exc    



##########################################################################################################
#GETTER_&_SETTER
##########################################################################################################
#Encapsulation (getter & setter)
#it is about public and private vars inside initializer
#we should use private to encapsulate our class data
#to control accessibility of our class data   

#content list :    
    #Manual Getter & Setter
    #Attribute Functions
    #Dunder Getter & Setter
    #Item Getter & Setter
    #PROPERTY decorator
    #Descriptors


#what is the problem?
class Student:

    def __init__(self, name="Rajaram", marks=50):
        self.__name  = name
        self.__marks = marks

    def studentdata(self):
        print ("Name: {} marks: {}".format(self.__name, self.__marks))
    
s1 = Student()
s2 = Student("Bharat", 25)

s1.studentdata()   #--->  Name: Rajaram marks: 50
s2.studentdata()   #--->  Name: Bharat marks: 25

print ("Name:  {}".format(s1.__name )) #--->  AttributeError: 'Student' object has no attribute '__name'
print ("Marks: {}".format(s1.__marks)) #--->  AttributeError: 'Student' object has no attribute '__marks'

print ("Name:  {}".format(s2.__name )) #--->  AttributeError: 'Student' object has no attribute '__name'
print ("Marks: {}".format(__s2.marks)) #--->  NameError: name '__s2' is not defined
print (s1._Student__marks)             #--->  50




#solution is making getter setter deletter methods inside of class




#############################
#Manual Getter & Setter
#############################
#this is not a standard way for python
#this suit for java 
#Using property() Method 

class Student:

    def __init__(self, name="Rajaram", mark=50):
        self.__name  = name
        self.__mark  = mark

    def studentdata(self):
        print ("Name: {} marks: {}".format(self.__name, self.__mark))
    
    def setter_mark (self, newmark):
        self.__mark = newmark

    def deletter_mark (self):
        del self.__mark

s1 = Student()
s2 = Student("Bharat", 25)
s2.setter_mark(32)
s2.studentdata()    #--->  Name: Bharat marks: 32

#Manual Getters and Setter Methods 
class Employee:
    def __init__(self, name, age):
        self.__name = name
        self.__age = age

    def get_name(self):
        return self.__name
    def get_age(self):
        return self.__age
    def set_name(self, name):
        self.__name = name
        return
    def set_age(self, age):
        self.__age=age
        return
   
    name = property(get_name, set_name, "name")
    age  = property(get_age,  set_age,  "age" )

e1=Employee("Bhavana", 24)
print ("Name:", e1.name, "age:", e1.age)    #--->  Name: Bhavana age: 24

e1.name = "Archana"
e1.age = 23
print ("Name:", e1.name, "age:", e1.age)    #--->  Name: Archana age: 23

e2=Employee("Bhavana", 24)
print ("Name:", e2.get_name(), "age:", e2.get_age())    #--->  Name: Bhavana age: 24
e2.set_name("Archana")
e2.set_age(21)
print ("Name:", e2.get_name(), "age:", e2.get_age())    #--->  Name: Archana age: 21


#example
class Alphabet:
    def __init__(self, value):
        self._value = value
 
    # getting the values
    def getValue(self):
        print('Getting value')
        return self._value
 
    # setting the values
    def setValue(self, value):
        print('Setting value to ' + value)
        self._value = value
 
    # deleting the values
    def delValue(self):
        print('Deleting value')
        del self._value
 
    value = property(getValue, setValue, 
                     delValue, )
 
 
x = Alphabet('GeeksforGeeks')
print(x.value)
 
x.value = 'GfG'
 
del x.value



#example
class Foo():
    def __init__(self, name = ""):
        self._name = name
    
    def getName(self):
        return self._name
    
    def setName(self, name):
        self._name = name

    def delName(self):
        del self._name
        print("Name successfully deleted")

person = Foo("Mike")
print("Name before change: ", person.getName())

person.setName("Jason")
print("Name after change: ", person.getName())

person.delName()

print("Calling the person after deletion:")
print(person.getName()) # will throw an Attribute Error since we've already deleted _name


#############################
#Attribute Functions
#############################
#attribute functions (getattr()-setattr()-hasattr()-delattr())
#getattr()
class test:
    def __init__(self):
        self.name = "Manav"
      
obj = test()
print (getattr(obj, "name"))    #--->  Manav
print (getattr(obj, "city"))    #--->  Error - AttributeError



#setattr()
class test:
    def __init__(self):
        self.name = "Manav"
      
obj = test()
setattr(obj, "age", 20)
setattr(obj, "name", "Madhav")
print (obj.name, obj.age)   #--->  Madhav 20


#hasattr()
class Test:
    def __init__(self):
        self.name = "Manav"
      
obj = Test()
print (hasattr(obj, "age"))  #--->  False
print (hasattr(obj, "name")) #--->  True
print (hasattr(Test, "name")) #--->  True


#delattr()
class Test:
    def __init__(self):
        self.name = "Manav"

obj = Test()
delattr(obj, "name")
print(obj.name) #--->  AttributeError: 'Test' object has no attribute 'name'






#############################
#Dunder Getter & Setter
#############################
#__getattr__()

class Person:
    name = "amir"

p = Person()
print(p.name)   #--->  amir
print(p.age)    #--->  Error - AttributeError: 'Person' object has no attribute 'age'    

#if we wanna print unknown attribute then python will give us an error
#we can handle it by ourself 

class Person:
    name = "amir"

    def __getattr__(self, item):    #just enable when attribute does not exist #if exist then this will be disable
        return f"{item} does not exist"

p = Person()
print(p.name)   #--->  amir
print(p.age)    #--->  age does not exist

#------------------------------------------------
#__getattribute__()
#__getattribute__ has a upper priority than __getattr__ and has a control on all attributes even does not exist

#__getattribute__() vs __getattr__()

class Person:
    name = "amir"
    age  = 99

    def __getattr__(self, item):    #just enable when attribute does not exist #if exist then this will be disable
        return f"{item} does not exist"

    def __getattribute__(self, item):  #will enable if attribute exist ... 
        if item == 'name':
            return 'you cant access name'
        else:
            return super().__getattribute__(item)


p = Person()
print(p.name)   #--->  you cant access name
print(p.age)    #--->  99
print(p.salary) #--->  salary does not exist


#------------------------------------------------
#__setattr__()


class Person:
    pass

p = Person()
p.name = "amir" #set attribute manual
print(p.name)   #--->  amir

#we want to had a control on set attributes 

class Person:
    def __setattr__(self, key, value):
        if key == 'name':
            print("you cant set name")
        else :
            return super().__setattr__(key, value)

p = Person()
p.name = "amir" #--->  you cant set name
p.salary = 5000
print(p.salary) #--->  5000

#----------------------------------------
#__delattr__()

class Person:
    pass

p = Person()
p.name = "amir"
del p.name
print(p.name)  #--->  Error - AttributeError

#we want to had a control on delete attributes

class Person:
    if item == 'name':
        print("you cant delete name")
    else :
        return super().__delattr__(item)

p = Person
p.name = "amir"
del p.name      #--->  you cant delete name
print(p.name)   #--->  amir

p.age = 20      
del p.age
print(p.age)    #--->  Error - AttributeError





#############################
#Item Getter & Setter
#############################
#__getitem__()
#__setitem__()
#__delitem__()


class MyList:
    def __init__(self, element = 1):
        self.my_list = [None] * element

    def __str__(self):
        return str(list(self.my_list))

    def __setitem__(self, index, value):
        self.my_list[index] = value

    def __getitem__(self, index):
        return self.my_list[index]

    def __delitem__(self, index):
        self.my_list[index] = None

m = MyList(5)
m[0] = 00
m[1] = 11
m[2] = 22
m[3] = 33
m[4] = 44

print(m[2]) #--->  22

del m[2]    

print(m)    #--->  [00,11,None,33,44]







#############################
#PROPERTY decorator
#############################
#Using @property Decorator

class Person:
    def __init__(self, fname, lname):
        self.fname = fname
        self.lname = lname
        self.email = f"{fname + lname}@yahoo.com"

    def full_name(self, fname, lname):
        return f"{fname} {lname}"

P1 = Person("Hamid","Mohammadi")

print(P1.fname) #--->  Hamid
print(P1.lname) #--->  Mohammadi            
print(P1.email) #--->  HamidMohammadi@yahoo.com

#if we change person name we will see that email is not correct
P1.fname = "Ali"
print(P1.fname) #--->  Ali
print(P1.lname) #--->  Mohammadi            
print(P1.email) #--->  HamidMohammadi@yahoo.com

#we should define email as a method for class

class Person2:
    def __init__(self, fname, lname):
        self.fname = fname
        self.lname = lname
        
    def full_name(self):
        return f"{self.fname} {self.lname}"

    def email(self):
        return f"{self.fname}_{self.lname}@yahoo.com"


P2 = Person2("Hamid","Mohammadi")
#if we change person name we will see that email is not correct
P2.fname = "Ali"
print(P2.fname) #--->  Ali
print(P2.lname) #--->  Mohammadi    
print(P2.full_name())#--->  Ali Mohammadi
print(P2.email()) #--->  Ali_Mohammadi@yahoo.com

#now it work correct but we need to change P1.email to P1.email() in whole of our codes 
#in big projects it is very hard to change all of them

#if we dont want to change every ".email" code we can use @property decorator to change email method beahavior
#to do like as property in class and use it without need to insert "()" at the end of email

#if we use @property just before a method in class thas method will do as property whenever we want to use it
#@property decorator gives us this possibility to use it like property instead of method  

#standard way for python is this ...

class Student:

    def __init__(self):
        self.__mark  = 0

    @property
    def mark (self):
        return self.__mark

    @mark.setter
    def mark(self, m):
        self.__mark = m

    @mark.deleter
    def mark(self):
        del self.__mark

s1 = Student()
print(s1.mark)  #--->  0
s1.mark = 43
print(s1.mark)  #--->  43
del s1.mark
print(s1.mark)  #--->  AttributeError: 'Student' object has no attribute '_Student__mark'      


#------------------------------------------------
#example
#getter
#if you add @property before start of a func that func will be a getter
@property
def idViewer(self):
    return self.__id    #no need to define id with __ because we have property for it we behavior with it like privates

@idViewer.getter
def sadasd(self):
    self.__id = 8

#setter
@idViewer.setter
def dsfs(self,id_value):
    self.__id = id_value    

#------------------------------------------------------------------
#Setter Method of Python Property Decorator 
#example
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):
        return self._radius

    @radius.setter
    def radius(self, value):
        if value < 0:
            raise ValueError("Radius cannot be negative")
        self._radius = value

# Usage
circle = Circle(5)
print(circle.radius)  # Accessing the property
circle.radius = 7  # Modifying the property
print(circle.radius)
circle.radius = -2  # This will raise a ValueError




#Python Property Decorator without Setter
#example
class Rectangle:
    def __init__(self, width, height):
        self._width = width
        self._height = height

    @property
    def area(self):
        return self._width * self._height

rectangle = Rectangle(4, 5)
print(rectangle.area)  # Accessing the read-only property
# rectangle.area = 20  # This will raise an AttributeError



#Python Property Decorator with Arguments
#example-2
class Temperature:
    def __init__(self, celsius):
        self._celsius = celsius

    @property
    def fahrenheit(self):
        return (self._celsius * 9/5) + 32

    @fahrenheit.setter
    def fahrenheit(self, value):
        print(f"this is value: {value}")
        self._celsius = (value - 32) * 5/9
        print(f"this is new celsius: {self._celsius}")

temp = Temperature(25)
print(temp.fahrenheit)  # Accessing the property with a unit conversion
temp.fahrenheit = 90  # Modifying the property with a unit conversion
print(temp.fahrenheit)
"""
77.0
this is value: 90
this is new celsius: 32.22222222222222
90.0
"""




#example
class Alphabet:
    def __init__(self, value):
        self._value = value
 
    # getting the values
    @property
    def value(self):
        print('Getting value')
        return self._value
 
    # setting the values
    @value.setter
    def value(self, value):
        print('Setting value to ' + value)
        self._value = value
 
    # deleting the values
    @value.deleter
    def value(self):
        print('Deleting value')
        del self._value
 
 
# passing the value
x = Alphabet('Peter')
print(x.value)
 
x.value = 'Diesel'
 
del x.value



#example
class Person:
    def __init__(self, firstName, middleName, lastName):
        self.firstName  = firstName
        self.middleName = middleName
        self.lastName   = lastName

    @property
    def fullname(self):
        return self.firstName + ' ' + self.middleName + ' ' + self.lastName
    
    @fullname.setter
    def fullname(self, fullname):
        firstName, middleName, lastName = fullname.split(' ')
        self.firstName = firstName
        self.middleName = middleName
        self.lastName = lastName
        
    @fullname.deleter
    def fullname(self):
        del self.firstName, self.middleName, self.lastName

person1 = Person('Ravi', 'Ashok', 'Ganeshan')
person1.firstName = 'Siddharth'

print("Printing the Full Name individually")
print(person1.firstName)  # Siddharth
print(person1.middleName) # Ashok
print(person1.lastName)   # Ganeshan

print("Printing the full name attribute: ", person1.fullname) # Siddharth Ashok Ganeshan (this is correct)



#example
class Rectangle:
    def __init__(self, a, b):
        self.a = a
        self.b = b

    @property
    def area(self):
        return self.a * self.b

rect = Rectangle(5, 6)
print(rect.area)
# 30

#------------------------------------------------
#as you see we can create a getter setter system with @property decorator for easch of attributes
#but in big projects we dont have only just one atrribute we have many of them
#with this system we must write 3 method for each of attributes thats not logical
#we must use #DESCRIPTORS  
#------------------------------------------------

# if you use property you cant get-set-del from outside of decorators
# you cant just use get property then set from other place
# if you use get property you must do your set or del operations from decorator not anything else 




#############################
#Descriptors
#############################
# *Best Solution*
#DESCRIPTORS (__get__ , __set__ , __delete__ , __set_name__)

class One:

    def __init__(self, attr_name):
        self.attr_name = attr_name

    def __get__(self, instance, owner):
        print("#######__get__#########")
        print(self)
        print(instance)
        print(owner)
        print(f"self.attr_name = {self.attr_name}")
        print("################")
        return instance.__dict__[self.attr_name]

    def __set__(self, instance, value):
        print("#######__set__#########")
        print(self)
        print(instance)
        print(value)
        print(f"self.attr_name = {self.attr_name}")
        print("################")
        if not isinstance(value, str):
            raise ValueError("value must be string")
        instance.__dict__[self.attr_name] = value

    def __delete__(self, instance):
        instance.__dict__[self.attr_name] = None


class Person:
    name = One('name')
    car = One('car')

    def __init__(self, name, car):
        self.name = name
        self.car = car

print("-----------p1-----------------")
p1 = Person("amir", "pride")
print("-----------get-----------------")
print(p1.name)
print(p1.car)
print("-----------set-----------------")
p1.name = "ali"
p1.car = "bmw"

#--->
"""
-----------p1-----------------
#######__set__#########
<__main__.One object at 0x7f40818b3fd0>
<__main__.Person object at 0x7f40818b3dc0>
amir
self.attr_name = name
################
#######__set__#########
<__main__.One object at 0x7f40818b3e20>
<__main__.Person object at 0x7f40818b3dc0>
pride
self.attr_name = car
################
-----------get-----------------
#######__get__#########
<__main__.One object at 0x7f40818b3fd0>
<__main__.Person object at 0x7f40818b3dc0>
<class '__main__.Person'>
self.attr_name = name
################
amir
#######__get__#########
<__main__.One object at 0x7f40818b3e20>
<__main__.Person object at 0x7f40818b3dc0>
<class '__main__.Person'>
self.attr_name = car
################
pride
-----------set-----------------
#######__set__#########
<__main__.One object at 0x7f40818b3fd0>
<__main__.Person object at 0x7f40818b3dc0>
ali
self.attr_name = name
################
#######__set__#########
<__main__.One object at 0x7f40818b3e20>
<__main__.Person object at 0x7f40818b3dc0>
bmw
self.attr_name = car
################
"""


#we can change initializer of class One with __set_name__ to make it improved

class One:

    def __set_name__(self, owner, attr_name):
        self.attr_name = attr_name

    def __get__(self, instance, owner):
        print("#######__get__#########")
        print(self)
        print(instance)
        print(owner)
        print(f"self.attr_name = {self.attr_name}")
        print("################")
        return instance.__dict__[self.attr_name]

    def __set__(self, instance, value):
        print("#######__set__#########")
        print(self)
        print(instance)
        print(value)
        print(f"self.attr_name = {self.attr_name}")
        print("################")
        if not isinstance(value, str):
            raise ValueError("value must be string")
        instance.__dict__[self.attr_name] = value

    def __delete__(self, instance):
        instance.__dict__[self.attr_name] = None


class Person:
    name = One()
    car = One()

    def __init__(self, name, car):
        self.name = name
        self.car = car

print("-----------p1------------------")
p1 = Person("amir", "pride")
print("-----------get-----------------")
print(p1.name)
print(p1.car)
print("-----------set-----------------")
p1.name = "ali"
p1.car = "bmw"


##########################################################################################################
#ENUM
##########################################################################################################
#https://docs.python.org/3/library/enum.html
#An enumeration:
#   is a set of symbolic names (members) bound to unique values
#   can be iterated over to return its canonical (i.e. non-alias) members in definition order
#   uses call syntax to return members by value
#   uses index syntax to return members by name


#syntax of enum
from enum import Enum

# class syntax
class Color(Enum):
    RED = 1
    GREEN = 2
    BLUE = 3
   #BLUE = 9    #--->  Error (keys must be unique)
    XXXX = 3    #auto recognition with @unique decorator 

#XXXX is not a new variable just point to BLUE
print(id(Color.BLUE))   #--->  140421708943216
print(id(Color.XXXX))   #--->  140421708943216

print(Color.XXXX is Color.BLUE) #--->  True

# functional syntax
Color = Enum('Color', ['RED', 'GREEN', 'BLUE'])
#            <name>      1       2       3

print(Color(3)) #--->  BLUE
print(Color.RED.value)  #--->  1
print(repr(Color.RED))  #--->  <Color.RED: 1>

print(isinstance(Color.RED,Color))  #--->  True

Color.GREEN = 8 #--->  Error - Cannot reassign members  (eums are constants)

for c in Color:
    print(c)
    print(c.name)
    print(c.value)
    #--->  Color.RED
    #      RED
    #      1
    #      Color.GREEN
    #      GREEN
    #      2
    #      Color.BLUE
    #      BLUE
    #      3












#enumeration class
#process of assigning fixed constant values to a set of strings, so that each string can be identified by the value bound to it.
#The Enum class included in enum module is used as the parent class to define enumeration of a set of identifiers
#conventionally written in upper case.
from enum import Enum

class subjects(Enum):
    ENGLISH = 1
    MATHS = 2
    SCIENCE = 3
    SANSKRIT = 4

#"subjects" is the enumeration
#It has different enumeration members
#Each member is ab object of the enumeration class subjects, and has name and value attributes.
obj = subjects.MATHS
print (type(obj), obj.value)    #--->  <enum 'subjects'>   2


#Value bound to the enum member need not always be an integer, it can be a string as well
from enum import Enum
class subjects(Enum):
   ENGLISH   = "E"
   MATHS     = "M"
   GEOGRAPHY = "G"
   SANSKRIT  = "S"
   
obj = subjects.SANSKRIT
print (type(obj), obj.name, obj.value)  #--->  <enum 'subjects'>   SANSKRIT   S
print (subjects["ENGLISH"])     #--->  ???

for sub in subjects:
   print (sub.name, sub.value)  #--->  ENGLISH E
                                #      MATHS M
                                #      GEOGRAPHY G
                                #      SANSKRIT S



#------------------------------------------------
#unique decorator
   
#An enum class cannot have same member appearing twice,
#however, more than one members may be assigned same value.
#To ensure that each member has a unique value bound to it, use the @unique decorator.
# @unique will show you an error whenever see not unique values assigned
#example

from enum import Enum, unique

@unique
class subjects(Enum):
    ENGLISH   = 1
    MATHS     = 2
    GEOGRAPHY = 3
    SANSKRIT  = 2

#--->  @unique
#       ^^^^^^
#       raise ValueError('duplicate values found in %r: %s' %
#       ValueError: duplicate values found in <enum 'subjects'>: SANSKRIT -> MATHS    



#alternative method of defining enumeration
from enum import Enum
subjects = Enum("subjects", "ENGLISH MATHS SCIENCE SANSKRIT")
#how to assign values in this method ???
print(subjects)     #--->  ???


#Enum uset to :
#   increse readibility
#   cause to extendibility
#   cause to a better maintenance


#example
from enum import Enum
class Days(Enum):
    MONDAY    = 1
    TUESDAY   = 2
    WEDNESDAY = 3
    THURSDAY  = 4
    FRIDAY    = 5
    SATURDAY  = 6
    SUNDAY    = 7

print(Days.FRIDAY.value)    #--->  ???    

#------------------------------------------------
#auto value
#if values of enum keys arent very important we can assign them auto values
from enum import auto

class Color(Enum):
    RED   = auto()
    GREEN = auto()
    BLUE  = auto()
  
for c in Color:
    print(Color.name, Color.value)
    #--->  RED 1
    #      GREEN 2
    #      BLUE 3

for c, v in Color.__members__.items():
    print(c, v, v.value)
    #--->  RED   Color.RED   1
    #      GREEN Color.GREEN 2
    #      BLUE  Color.BLUE  3

#--------------------------------------
#comparison
class Color(Enum):
    RED   = 1
    GREEN = 2
    BLUE  = 3
   
print(Color.RED == Color.GREEN) #--->  False
print(Color.RED > Color.GREEN) #--->  Error    


#to solve this problem
from enum import IntEnum
class Color(IntEnum):
    RED   = 1
    GREEN = 2
    BLUE  = 3
print(Color.RED > Color.GREEN) #--->  False 



##########################################################################################################
#META_CLASS
##########################################################################################################
#https://www.mongard.ir/one_part/28/meta-classes-python/
#???


#are classes which let you to change behavior of the other classes
class A:
    pass

a1 = A()
print(a1.__class__.__class__) #--->  <class 'type'>

a2 = type('Person', (), {})
print(a2) #--->  <class '__main__.Person'>
#we create a class with type()

#type() is greatest meta class in python 
#type() is meta class of all classes in our code

#meta classes mostly used in singleton design pattern


#--------------------------------------
#Create a metaclass

class Singleton(type):
    _instance = None
    def __call__(self, *args, **kwargs):
        if self._instance in None:
            self._instance = super().__call__()
        return self._instance

class db(metaclass = Singleton):
    pass

d1 = db()
d2 = db()

print(id(d1))
print(id(d2))
#are equal

##########################################################################################################
#CLASS_DECORATOR
##########################################################################################################
#In Python, class decorators are similar to function decorators, but they apply to classes instead of functions.
#are functions that take a class as input and return a new class with modified behavior.

def add_method(cls):
    def new_method(self, value): #newly added method for our class
        self.value = value
    cls.new_method = new_method
    return cls

@add_method     #decorator name
class MyClass:
    def __init__(self):
        self.value = 0

my_object = MyClass()
my_object.new_method(5)
print(my_object.value)


#decorators are used in Python to modify the behavior of functions or classes
#Decorators are typically used to add new functionality to existing code without changing the implementation,
#making the code more usable and modular.


#some common uses of decorators in Python:
#   entering the system
#   timing
#   saving
#   authentication
#   error handling


#In general, the decorator in Python is considered a powerful and versatile feature that can be used to 
#improve the performance and modularity of our code.

#advantages of using decorators :
#   Code reusability
#   Improve code readability and performance
#   flexibility
#   Improved code readability
#   Saving time
#   Easy implementation

#--------------------------------------
#decorator package
#we can use a decorator as a package and reuse it whenever we want
#then import to our project

#example
#from decorator import do_twice  


#-------------------------------------------------------------------
#Wrapper Classes
#A function in Python is a first-order object. A function can have another function as its argument and wrap another function definition inside it. This helps in modifying a function without actually changing it. Such functions are called decorators.
#This feature is also available for wrapping a class. This technique is used to manage the class after it is instantiated by wrapping its logic inside a decorator.

def decorator_function(Wrapped):
    class Wrapper:
        def __init__(self,x):
            self.wrap = Wrapped(x)

        def print_name(self):
            return self.wrap.name
    s    
    return Wrapper
   
@decorator_function
class Wrapped:
    def __init__(self,x):
        self.name = x
      
obj = Wrapped('TutorialsPoint')
print(obj.print_name())

#???

#------------------------------------------------
#PARTIAL_CLASS

class MarchMadness:
    def __init__(self):
        self._is_spectator = False

    @property
    def is_spectator(self):
        return self._is_spectator

    def set_spectator(self, is_fan):
        self._is_spectator = bool(is_fan)

    set_fan = partialmethod(set_spectator, True)
    unset_fan = partialmethod(set_spectator, False)

mm = MarchMadness()
print(mm.is_spectator) #---> False
mm.set_fan()
print(mm.is_spectator) #---> True


#example-2
class Cell:
    def __init__(self):
        self._alive = False
    @property
    def alive(self):
        return self._alive
    def set_state(self, state):
        self._alive = bool(state)
    set_alive = partialmethod(set_state, True)
    set_dead = partialmethod(set_state, False)

c = Cell()
c.alive     #--->  False
c.set_alive()
c.alive     #--->  True


##########################################################################################################
#DATA_CLASS
##########################################################################################################
#Dataclasses are python classes, 
#   but are suited for storing data objects
#   This module provides a decorator and functions 
#   for automatically adding generated special methods such as __init__() and __repr__() to user-defined classes.

#features:
# 1- They store data and represent a certain data type.
#       Ex: A number. For people familiar with ORMs, a model instance is a data object. It represents a specific kind of entity. It holds attributes that define or represent the entity.
# 2- They can be compared to other objects of the same type. 
#       Ex: A number can be greater than, less than, or equal to another number.

#it is like an alternative of structure in python 

#a normal class:
class Person:
    def __init__(self, name, age = 0):
        self.name = name
        self.age  = age

    def __repr__(self):
        return f'{self.__class__.__name__}(name={self.name}, age={self.age})'

    def __eq__(self, other):
        if other.__class__ is not self.__class__:
            return NotImplemented
        return self.age == other.age    

#a dataclass:
from dataclasses import dataclass, field
from Typing import List, Any
                                               # init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False, match_args=True, kw_only=False, slots=False, weakref_slot=False 
@dataclass(order=True, frozen=True, repr=True) # order (add full compare methods) | frozen (do not let to change class variables ) 
class Person:
                                                  # default=MISSING, default_factory=MISSING, init=True, repr=True, hash=None, compare=True, metadata=None, kw_only=MISSING  
    name:    str = field(compare=False)           # Do Not use to compare
    age:     int = field(compare=False)           # Do Not use to compare
    height : int = field(repr=False, default=160) # use to compare                # Do Not Show in repr
    adminstration : bool = False                  # default value

    def __post_init__(self):        # second init (will act after first init)
        if self.name == 'admin':
            self.administration = True

    def mymethod(self):
        return True        

a = Person('admin', 20, 180)
b = Person('jack', 30, 170)

a.name = 'kevin'        #---> FrozenInstanceError - you cant change name because frozen is True
print(a < b)            #---> False (because compare will act on height)
print(a)                #---> Person(name=admin, age=20, administration=True) repr
print(a.administration) #---> True
help(Person)            #---> is equal to help(a)
#--->
"""
???
"""



#----------------------------
#dataclass inheritance
#----------------------------
from dataclasses import dataclass, field

@dataclass
class Person:
    name: str
    age: int = 0

@dataclass
class Male(Person):
    height: int

a = Male('amir', 20, 180)   #---> TypeError - non-default argument follows default argument
                            # because in python (name, age=0, height) is wrong and default must be last 


#example
from dataclasses import dataclass, field

@dataclass
class Person:
    name: str
    age: int

@dataclass
class Male(Person):
    height: int

a = Male('amir', 20, 180)













##########################################################################################################
#ATEXIT_MODULE
##########################################################################################################
#is a exit handler
#The atexit module defines functions to register and unregister cleanup functions
#Functions thus registered are automatically executed upon normal interpreter termination
#atexit runs these functions in the reverse order in which they were registered:
#   if you register A, B, and C, at interpreter termination time they will be run in the order C, B, A.

#functions you registered just will run when python handle exit process of program (not by os like os._exit() or internal fatal errors) 

import atexit
import time

def goodbye(name="user"):
    print(f"GoodBye {name}..!")

atexit.register(goodbye, name = "amir")

print("Hello user ... !")
time.sleep(5)

#run:
#--->  Hello user ... !
#      //waiting for 5 seconds
#      Goodbye amir..!



#you can use unregister to disable registered func
atexit.unregister(goodbye)


#example-1
try:
    with open('counterfile') as infile:
        _count = int(infile.read())
except FileNotFoundError:
    _count = 0

def incrcounter(n):
    global _count
    _count = _count + n

def savecounter():
    with open('counterfile', 'w') as outfile:
        outfile.write('%d' % _count)

import atexit

atexit.register(savecounter)


#example-2
def goodbye(name, adjective):
    print('Goodbye %s, it was %s to meet you.' % (name, adjective))

import atexit

atexit.register(goodbye, 'Donny', 'nice')
# or:
atexit.register(goodbye, adjective='nice', name='Donny')


#--------------------------------------
#atexit decorator
#This only works with functions that can be called without arguments.
import atexit

@atexit.register
def goodbye():
    print('You are now leaving the Python sector.')




##########################################################################################################
#PLATFORM_MODULE
##########################################################################################################
import platform

print(platform.uname()) #--->
print(platform.system())
print(platform.processor())

#related to python
print(platform.python_version())
platform.python_build()
platform.python_compiler()
platform.python_branch()
platform.python_implementation()
platform.python_revision()
platform.python_version()
platform.python_version_tuple()


#related to java
platform.java_ver(release='', vendor='', vminfo=('', '', ''), osinfo=('', '', ''))

#related to windows
platform.win32_ver(release='', version='', csd='', ptype='')
platform.win32_edition()
platform.win32_is_iot()


#related to macos
platform.mac_ver(release='', versioninfo=('', '', ''), machine='')

#related to unix
platform.libc_ver(executable=sys.executable, lib='', version='', chunksize=16384)

#related to linux
platform.freedesktop_os_release()




platform.machine()
platform.node()
platform.platform(aliased=False, terse=False)
platform.processor()

platform.release()
platform.system()
platform.system_alias(system, release, version)
platform.version()

platform.uname()




##########################################################################################################
#OS
##########################################################################################################  
#OS Module
#You can use the mkdir() method of the os module to create directories in the current directory
import os
os.mkdir("test")            # Create a directory "test"
if os.path.exists('test'):  # check for existance of a folder or file
    pass  


#change the current directory
#Following is an example to go into "/home/newdir" directory −
os.chdir("/home/newdir")        # Changing a directory to "/home/newdir"

#displays the current working directory.
os.getcwd()     #would give location of the current directory

#Delete the Directory
os.rmdir( "/tmp/test" )     #would remove "/tmp/test" directory.

#current path
os.getcwd()

#current os name
print(os.name)   #--->  ???

#it returns a file object which is connected to a pipe.
os.popen()
file = os.popen(fd, 'w') 

#closes the associated file with descriptor fr
os.close()
os.close(file)  
#example
fr = "Python1.txt"    
file = open(fr, 'r')     
text = file.read()     
print(text)     
os.close(file)       

#Renaming Files
os.rename( "test1.txt", "test2.txt" )   # Rename a file from test1.txt to test2.txt

#Deleting Files
os.remove("text2.txt")      # Delete file test2.txt

#send our message to system (like bash)
os.system("mkdir mypython")

#go to mypython directory
os.chdir("mypython")

#go to back directory
os.chdir("..")

#give me a list of content
os.system("ls")

#to show list of content in folder
os.listdir("myfolder")

#This function uses real uid/gid to test if the invoking user has access to the path.
os.access()
#example
import os     
import sys    
path1 = os.access("Python.txt", os.F_OK)     
print("Exist path:", path1)     #--->  Exist path: False    
# Checking access with os.R_OK     
path2 = os.access("Python.txt", os.R_OK)     
print("It access to read the file:", path2) #--->  It access to read the file: False    
# Checking access with os.W_OK     
path3 = os.access("Python.txt", os.W_OK)     
print("It access to write the file:", path3)  #--->  It access to write the file: False   
# Checking access with os.X_OK     
path4 = os.access("Python.txt", os.X_OK)     
print("Check if path can be executed:", path4)  #--->  Check if path can be executed: False  


#--------------------------------------
#clear Python shell
#Sometimes when working with the Python shell want to clear the screen for some other reason
#The "cls" and "clear" commands are used to clear a terminal (terminal window). If, you are using the shell within IDLE, which won't be affected by such things.

#   In Linux :
os.system('clear')  
#   In Windows :  
os.system('CLS')  

#clear func : 
from os import system, name   
from time import sleep   # sleep module to display output for some time period    
def clear():   
    # for windows   
    if name == 'nt':   
        _ = system('cls')   
    # for mac and linux(here, os.name is 'posix')   
    else:   
        _ = system('clear')   
  


# do something   
print('Hello\n'*10)   
sleep(5)   # sleep time 2 seconds after printing output 
clear()   # now call function we defined above   





#--------------------------------------
#SHUTIL

#copy files 
import shutil
shutil.copy2("/Users/mehrdad/abc.txt", "/Users/mehrdad/abc_copy.txt")

# testcompare.py file will be copied in the folder  
shutil.copy('testcompare.py', 'myfolder')  

#copy file with shutil
shutil.copyfile("/Users/mehrdad/abc.txt", "/Users/mehrdad/abc_copyfile.txt")
shutil.copyfile("calc.py" , "myfolder/calc.py")

#copy
source = r'D:\Python Project\javatpoint\hello.txt'  
destination = r'D:\Python Project\NewFile' # In the newly created foloder  
dest = shutil.copy(source, destination) # Storing the new path of hello.txt file   
# Print the new path  
print(dest) #--->  D:\Python Project\NewFile\hello.txt 

#copytree
# importing shutil module  
import shutil  
src = r'D:\Python Project\javatpoint'  # It is source path  
dest = r'D:\Python Project\NewFolder'  # It is destination path  
dest1 = shutil.copytree(src, dest)   # Copy the content of source to destination  
print("Destination path:", dest1)  #--->  D:\Python Project\NewFolder

#move file
shutil.move("calc.py" , "myfolder/calc.py")

#Delete files 
import shutil
import os
shutil.os.remove("/Users/mehrdad/abc_copy2.txt")
#another way to remove a file
os.remove("/Users/mehrdad/abc_copy2.txt")

#list all of files and directories and etc
import glob
print(glob.glob("*.py"))        #--->  is equal to ls *.py in terminal
print(glob.glob("*.py")[2::2])  #--->  the same but print content of list one after two
   
   
#arguments   
import sys
a1 = sys.argv[0]
a2 = sys.argv[1:]
print(f"the app name is: {a1} ")   
print(f"the arguments are: {a2} ")   

#if you run this code in terminal of linux : 
#>>argum.py ali 12.5 true  
#--->  argum.py
#--->  ali 12.5 true

#example
#add.py
from sys import argv
def main(argv) :
    print( int(sys.argv[0]) + int(sys.argv[1]) )

if __name__ == "__main__" :
    main(argv)    
    
#add.py 5 7     --->  12


#remove tree
import shutil  
import os  
location_dir = r"D:\Python Project\NewFile"  
directory = r"D:\Python Project\javatpoint"  
path1 = os.path.join(location_dir, directory)   
shutil.rmtree(path1)  # removing directory 


#Which
import shutil  
cmd = 'python'  # search the file 
locating = shutil.which(cmd)   
print(locating) #--->  C:\Python\python.EXE


#Error handling while using copy method
import shutil  
source = r"D:\Python Project\NewFolder"   # It is a source path  
destination = r"D:\Python Project\NewFolder"  # It is a destination path  
  
try:  
    shutil.copy(source, destination)  
    print("File copied successfully.")  
except shutil.SameFileError:  # If the given source and path are same  
    print("Source and destination represents the same file.")  
except PermissionError:   # If there is no permission to write  
    print("Permission denied.")  
except:   # For other errors  
    print("Error occurred while copying file.")  


#--------------------------------------
#ARGPARSE
#is recommended to work with the command line argument. 
#This module was released as a part of the standard library with Python on 20th February 2011.
#alternative for big projects is 'click' package
#https://click.palletsprojects.com/en/
 

#example-1 Simple Calculator Program using argparse 
import argparse  
parser = argparse.ArgumentParser()  

# creating two variables using the add_argument method  
parser.add_argument("num1", help = "first number")  
parser.add_argument("num2", help = "second number")
#parser.add_argument("num2", help = "second number", type = int)  #you can define data type
#parser.add_argument("-num2", help = "second number")             #you can make input optional (if user want can send input else can ignore)
#parser.add_argument('-n',"--num2", help = "second number")       #you can define two type of input which both do the same  #>>python -n 20
parser.add_argument("operation", help = "operation")  
parser.add_argument('-v', '--verbose', action = 'store_true')  #get -v as input without any otherthing (single) to do 'action'

args = parser.parse_args()  

print(type(args.num2))  #--->  <class 'str'>
print(args.num1)        #--->  
print(args.num2)        #--->
print(args.operation)   #--->   
  
n1 = int(args.num1)  
n2 = int(args.num2)

if args.verbose:
    print("will do action")  

if args.operation == "add":  
    result = n1 + n2  
    print("The Result is : ",result)  
elif args.operation == "sub":  
    result = n1 - n2  
elif args.operation == "mul":  
    result = n1 * n2  
elif args.operation == "div":  
    result = n1 / n2  
else:  
    print("Unmatched Argument")  
  
print("result is : ",result)


#input type in argparse
#example-2
import argparse  
parser = argparse.ArgumentParser()  
parser.add_argument('num', help="Enter nmber to get square")  #By default, it treats input number as string  
args = parser.parse_args()  
print(args.num**2)  #--->  1515
#example-3
import argparse  
parser = argparse.ArgumentParser()  
parser.add_argument('num', help="Enter number to get square of it.", type = int)  
args = parser.parse_args()  
print(args.num**2)  #--->  225 


#Using Short Name for Optional Argument
import argparse  
parser = argparse.ArgumentParser()  
parser.add_argument('-tut', '--tutorial', help="Best Tutorial ")  
parser.add_argument('-w', '--writer', help="Technical Content")  
args = parser.parse_args()    
if args.tutorial == 'Javatpoint':  
    print('Congratulation|| You made it!')  
if args.writer == 'Devansh':  
    print('Technical Writer.')  

#>>python code.py -w Devansh
#--->  Technical Writer.



#Combining Optional and Positional Arguments with argparse
import argparse  
parser = argparse.ArgumentParser()  
# positionl Argument  
parser.add_argument('tutorial', help="Best Tutorial ")  
# optional argument   
parser.add_argument('-w', '--writer', help="Technical Content")  
args = parser.parse_args()  
if args.tutorial == 'Javatpoint':  
    print('You made it!')  
if args.writer == 'Devansh':  
    print('Technical Writer.')

#>>python code.py Javatpoint -w Devansh
#--->  You made it!
#      Technical Writer.

#--------------------------------------
#GETOP MODULE
#https://www.javatpoint.com/getopt-module-in-python
#???


#--------------------------------------
#DOCOPT MODULE
#???

#--------------------------------------
#FIRE MODULE
#???


#--------------------------------------
#OPTPARSE MODULE
#???

#--------------------------------------
#SYS_MODULE

import sys
sys.stderr.write("This is an error\n") #???
 
#SYS Module
import sys

#sys.modules            This function provides the name of the existing python modules which have been imported.
#sys.argv               This function returns a list of command line arguments passed to a Python script. The name of the script is always the item at index 0, and the rest of the arguments are stored at subsequent indices.
#sys.base_exec_prefix   This function provides an efficient way to the same value as exec_prefix. If not running a virtual environment, the value will remain the same.
#sys.base_prefix        It is set up during Python startup, before site.py is run, to the same value as prefix.
#sys.byteorder          It is an indication of the native byteorder that provides an efficient way to do something.
#sys.maxsize            This function returns the largest integer of a variable.
#sys.path               This function shows the PYTHONPATH set in the current system. It is an environment variable that is a search path for all the python modules.
#sys.stdin              It is an object that contains the original values of stdin at the start of the program and used during finalization. It can restore the files.
#sys.getrefcount        This function returns the reference count of an object.
#sys.exit               This function is used to exit from either the Python console or command prompt, and also used to exit from the program in case of an exception.
#sys executable         The value of this function is the absolute path to a Python interpreter. It is useful for knowing where python is installed on someone else machine.
#sys.platform           This value of this function is used to identify the platform on which we are working.



##########################################################################################################
#SUBPROCESS_MODULE
##########################################################################################################

import subprocess

#we can run commands which we can run in terminal 
subprocess.run('ls')    #ls in linux
subprocess.run('ls -l', shell=True)    #ls -l in linux
#the better way is:
subprocess.run(['ls','-l']) #---> will show result in terminal



result = subprocess.run(['ls','-l'], capture_output= True, text = True)  #---> will not show result in terminal   
print(result)
print(result.stdout)    #---> in default way b' ' but because of text=true will give normal text
#representing a process that has finished (returnCode = 0  <= successful)

subprocess.run('atom')  #will open atom application on my linux 

##########################################################################################################    
#MULTI_THREADING
##########################################################################################################
#Multithreading refers to the mechanism of dividing the main task in more than one sub-tasks and executing
#them in an overlapping manner. This makes the execution faster as compared to single thread.
#The operating system is capable of handling multiple processes concurrently. It allocates a separate memory space to each process
#Multiple threads within a process share the same data space with the main thread and can therefore share 
#information or communicate with each other more easily than if they were separate processes.
#As they are light-weight, do not require much memory overhead

#A process always starts with a single thread (main thread). As and when required, a new thread can be started and sub task is delegated to it

#-------------------
#Thread Life cycle :
#When a new thread object is created, it must be started. This calls the run() method of thread class. This method contains the logic of the process to be performed by the new thread. The thread completes its task as the run() method is over, and the newly created thread merges with the main thread.

#Python's standard library has two modules, "_thread" and "threading", that include the functionality to handle threads.


#-------------------
#Creating a Thread :
#_thread.start_new_thread ( function, args[, kwargs] )


#_thread module
#example 
import _thread
import time

def thread_task( threadName, delay): # Define a function for the thread
    for count in range(1, 6):
        time.sleep(delay)
        print ("Thread name: {} Count: {}".format ( threadName, count ))


try:                          # Create two threads as follows
    _thread.start_new_thread( thread_task, ("Thread-1", 2, ) )
    _thread.start_new_thread( thread_task, ("Thread-2", 4, ) )
except:
    print ("Error: unable to start thread")

#while True:
#    pass

#--->   Thread name: Thread-1 Count: 1
#       Thread name: Thread-2 Count: 1
#       Thread name: Thread-1 Count: 2
#       Thread name: Thread-1 Count: 3
#       Thread name: Thread-2 Count: 2
#       Thread name: Thread-1 Count: 4
#       Thread name: Thread-1 Count: 5
#       Thread name: Thread-2 Count: 3
#       Thread name: Thread-2 Count: 4
#       Thread name: Thread-2 Count: 5
#       ...


#The run() Method
#???

#is_alive() method
#???


#threading module
#example
import threading
import time

class myThread (threading.Thread):
   def __init__(self, name):
      threading.Thread.__init__(self)
      self.name = name

   def run(self):
      print ("Starting " + self.name)
      for count in range(1,6):
         time.sleep(5)
         print ("Thread name: {} Count: {}".format ( self.name, count ))
      print ("Exiting " + self.name)

# Create new threads
thread1 = myThread("Thread-1")
thread2 = myThread("Thread-2")

# Start new Threads
thread1.start()
thread2.start()
thread1.join()  #???
thread2.join()
print ("Exiting Main Thread")


#--->   Starting Thread-1
#       Starting Thread-2
#       Thread name: Thread-1 Count: 1
#       Thread name: Thread-2 Count: 1
#       Thread name: Thread-1 Count: 2
#       Thread name: Thread-2 Count: 2
#       Thread name: Thread-1 Count: 3
#       Thread name: Thread-2 Count: 3
#       Thread name: Thread-1 Count: 4
#       Thread name: Thread-2 Count: 4
#       Thread name: Thread-1 Count: 5
#       Exiting Thread-1
#       Thread name: Thread-2 Count: 5
#       Exiting Thread-2
#       Exiting Main Thread




#multiprocessing module
from multiprocessing import Process  
def disp():  
    print ('Hello !! Welcome to Python Tutorial')     
if __name__ == '__main__':  
    p = Process(target=disp)  
    p.start()  
    p.join()  


#example-2
import multiprocessing  
def cube(n):  
    print("The Cube is: {}".format(n * n * n))  
def square(n):   
    print("The Square is: {}".format(n * n))  
if __name__ == "__main__":  
    process1 = multiprocessing.Process(target= square, args=(5, )) # creating two processes    
    process2 = multiprocessing.Process(target= cube, args=(5, ))   #The first argument is a target that represents the function to be executed, and the second argument is args that represents the argument to be passed within the function. 
    process1.start()     # start process 1  
    process2.start()     # start process 2  
    process1.join()  # The join() method is used to wait for process 1 to complete  
    process2.join()  # It is used to wait for process 1 to complete   
    print("Both processes are finished")  
#--->
'''
The Cube is: 125
The Square is: 25
Both processes are finished
'''

#example-3
#get number of CPUs currently in the system.
import multiprocessing  
print("The number of CPU currently working in system : ", multiprocessing.cpu_count()) #--->  32 

#Methods of Multiprocessing :
#   pipe()	            returns a pair of connection objects.
#   run()	            is used to represent the process activities.
#   start()	            is used to start the process.
#   join([timeout])	    is used to block the process until the process whose join() method is called terminates. The timeout is optional argument.
#   is_alive()	        It returns if process is alive.
#   terminate()	        As the name suggests, it is used to terminate the process. Always remember - the terminate() method is used in Linux, for Windows, we use TerminateProcess() method.
#   kill()	            This method is similar to the terminate() but using the SIGKILL signal on Unix.
#   close()	            This method is used to close the Process object and releases all resources associated with it.
#   qsize()	            It returns the approximate size of the queue.
#   empty()	            If queue is empty, it returns True.
#   full()	            It returns True, if queue is full.
#   get_await()	        This method is equivalent get(False).
#   get()	            This method is used to get elements from the queue. It removes and returns an element from queue.
#   put()	            This method is used to insert an element into the queue.
#   cpu_count()	        It returns the number of working CPU within the system.
#   current_process()	It returns the Process object corresponding to the current process.
#   parent_process()	It returns the parent Process object corresponding to the current process.
#   task_done()	        This function is used indicate that an enqueued task is completed.
#   join_thread()	    This method is used to join the background thread



#-------------------
#Thread Scheduling :
#A multi-threaded program can execute multiple sub-tasks independently, which allows the parallel execution of tasks.
#Python interpreter maps Python thread requests to either POSIX/pthreads, or Windows threads
#Python threads are handled by the host operating system.
#thread priority, scheduling schemes, and thread pre-emption is not possible with the Python interpreter
#Python does have some support for task scheduling in the form of sched module as the standard library. It can be used in the creation of bots and other monitoring and automation applications.
#The sched module implements a generic event scheduler for running tasks at specific times. It provides similar tools like task scheduler in windows or Linux.

#scheduler.enter()              - Events can be scheduled to run after a delay, or at a specific time. To schedule them with a delay, enter() method is used.
#scheduler.cancel()             - Remove the event from the queue. If the event is not an event currently in the queue, this method will raise a ValueError.
#scheduler.run(blocking=True)   - Run all scheduled events.


import sched    #built-in
import time

#scheduler(timefunc=time.monotonic, delayfunc=time.sleep)
scheduler = sched.scheduler(time.time, time.sleep)

def schedule_event(name, start):
   now = time.time()
   elapsed = int(now - start)
   print('elapsed=',elapsed, 'name=', name)

start = time.time()
print('START:', time.ctime(start))
scheduler.enter(2, 1, schedule_event, ('EVENT_1', start))
scheduler.enter(5, 1, schedule_event, ('EVENT_2', start))

scheduler.run()
#--->   START: Mon Jun 5 15:37:29 2023
#       elapsed= 2 name= EVENT_1
#       elapsed= 5 name= EVENT_2




#example-2
import sched
from datetime import datetime
import time

def addition(a,b):
    print("Performing Addition : ", datetime.now())
    print("Time : ", time.monotonic())      #monotonic is a time system which will never let us to change time to ack ... and cause to time just flow forward
    print("Result : ", a+b)                 # but normal clocks can change to 1 houer flow back becuase of season change

s = sched.scheduler()

print("Start Time : ", datetime.now())

event1 = s.enter(10, 1, addition, argument = (5,6))
print("Event Created : ", event1)
s.run()
print("End Time : ", datetime.now())


#--->   Start Time : 2023-06-05 15:49:49.508400
#       Event Created : Event(time=774087.453, priority=1, sequence=0, action=<function addition at 0x000001FFE71A1080>, argument=(5, 6), kwargs={})
#       Performing Addition : 2023-06-05 15:49:59.512213
#       Time : 774087.484
#       Result : 11
#       End Time : 2023-06-05 15:49:59.559659




#example-3
#QUEUE with multiprocessing module
from multiprocessing import Queue  
fruits = ['Apple', 'Orange', 'Guava', 'Papaya', 'Banana']  
count = 1  
queue = Queue() # creating a queue object    
print('pushing items to the queue:')  
for fr in fruits:  
    print('item no: ', count, ' ', fr)  
    queue.put(fr)  
    count += 1  
print('\n popping items from the queue:')  
count = 1  
while not queue.empty():  
    print('item no: ', count, ' ', queue.get())  
    count += 1  
#--->
'''
pushing items to the queue:
('item no: ', 1, ' ', 'Apple')
('item no: ', 2, ' ', 'Orange')
('item no: ', 3, ' ', 'Guava')
('item no: ', 4, ' ', 'Papaya')
('item no: ', 5, ' ', 'Banana')

popping items from the queue:
('item no: ', 1, ' ', 'Apple')
('item no: ', 2, ' ', 'Orange')
('item no: ', 3, ' ', 'Guava')
('item no: ', 4, ' ', 'Papaya')
('item no: ', 5, ' ', 'Banana')
'''

#--------------
#Thread Pools :
#A thread pool is a mechanism that automatically manages a pool of worker threads. 
#Each thread in the pool is called a worker or a worker thread. 
#Worker threads can be re-used once the task is completed. 
#A single thread is able to execute a single task once.

#A thread pool controls when the threads are created, and what threads should do when they are not being used.

#The Future Class
#The concurrent.futures.Future class is responsible for handling asynchronous execution of any callable 
#such as a function. To obtain an object of Future class, you should call the submit() method on any 
#Executor object. It should not be created directly by its constructor.

#Important methods in the Future class are :

#   result(timeout=None)   This method returns the value returned by the call. If the call hasn't yet completed, then this method will wait up to timeout seconds. If the call hasn't completed in timeout seconds, then a TimeoutError will be raised. If timeout is not specified, there is no limit to the wait time.
#   cancel()               This method makes attempt to cancel the call. If the call is currently being executed or finished running and cannot be cancelled then the method will return False, otherwise the call will be cancelled and the method will return True.
#   cancelled()            This method returns True if the call was successfully cancelled.
#   running()              This method returns True if the call is currently being executed and cannot be cancelled.
#   done()                 This method returns True if the call was successfully cancelled or finished running.


#example-1
from concurrent.futures import ThreadPoolExecutor
from time import sleep

def square(numbers):
    for val in numbers:
        ret = val*val
        sleep(1)
        print("Number:{} Square:{}".format(val, ret))

def cube(numbers):
    for val in numbers:
        ret = val*val*val
        sleep(1)
        print("Number:{} Cube:{}".format(val, ret))

if __name__ == '__main__':
    numbers = [1,2,3,4,5]
    executor = ThreadPoolExecutor(4)
    thread1 = executor.submit(square, (numbers))
    thread2 = executor.submit(cube, (numbers))
    print("Thread 1 executed ? :",thread1.done())
    print("Thread 2 executed ? :",thread2.done())
    sleep(2)
    print("Thread 1 executed ? :",thread1.done())
    print("Thread 2 executed ? :",thread2.done())



#--->   Thread 1 executed ? : False
#       Thread 2 executed ? : False
#       Number:1 Square:1
#       Number:1 Cube:1
#       Number:2 Square:4
#       Number:2 Cube:8
#       Thread 1 executed ? : False
#       Thread 2 executed ? : False
#       Number:3 Square:9
#       Number:3 Cube:27
#       Number:4 Square:16
#       Number:4 Cube:64
#       Number:5 Square:25
#       Number:5 Cube:125
#       Thread 1 executed ? : True
#       Thread 2 executed ? : True


#example-2
from multiprocessing import Pool  
import time  
w = (["V", 5], ["X", 2], ["Y", 1], ["Z", 3])  
def work_log(data_for_work):  
    print(" Process name is %s waiting time is %s seconds" % (data_for_work[0], data_for_work[1]))  
    time.sleep(int(data_for_work[1]))  
    print(" Process %s Executed." % data_for_work[0])  
def handler():  
    p = Pool(2)  
    p.map(work_log, w)  
if __name__ == '__main__':  
    handler()  
#--->  
'''
Process name is V waiting time is 5 seconds
Process V Executed.
Process name is X waiting time is 2 seconds
Process X Executed.
Process name is Y waiting time is 1 seconds
Process Y Executed.
Process name is Z waiting time is 3 seconds
Process Z Executed.
'''    

#-------------
#Main Thread :
#Every Python program has at least one thread of execution called the main thread.
#The main thread by default is a non-daemon thread.


#example-1
from time import sleep
from threading import current_thread
from threading import Thread

# function to be executed by a new thread
def run():
   # get the current thread
   thread = current_thread()
   # is it a daemon thread?
   print(f'Daemon thread: {thread.daemon}')

# create a new thread
thread = Thread(target=run)

# start the new thread
thread.start()

# block for a 0.5 sec
sleep(0.5)

t1 = threading.Thread(target=run)
#???



#-----------------
#Thread Priority :
#With a priority queue, the entries are kept sorted (using the heapq module) and the lowest valued entry is retrieved first

from time import sleep
from random import random, randint
from threading import Thread
from queue import PriorityQueue

queue = PriorityQueue()

def producer(queue):
    print('Producer: Running')
    for i in range(5):
        # create item with priority
        value = random()
        priority = randint(0, 5)
        item = (priority, value)
        queue.put(item)
   # wait for all items to be processed
   queue.join()
   queue.put(None)
   print('Producer: Done')

def consumer(queue):
    print('Consumer: Running')

    while True:
        # get a unit of work
        item = queue.get()
        if item is None:
            break
        sleep(item[1])
        print(item)
        queue.task_done()
    print('Consumer: Done')

producer = Thread(target=producer, args=(queue,))
producer.start()

consumer = Thread(target=consumer, args=(queue,))
consumer.start()

producer.join()
consumer.join()

#--->   Producer: Running
#       Consumer: Running
#       (0, 0.15332707626852804)
#       (2, 0.4730737391435892)
#       (2, 0.8679231358257962)
#       (3, 0.051924220435665025)
#       (4, 0.23945882716108446)
#       Producer: Done
#       Consumer: Done




#--------------------------------------
#Daemon Threads
#Sometimes, it is necessary to execute a task in the background.
#A special type of thread is used for background tasks, called a daemon thread. 
#daemon threads execute tasks in the background.

#Also, a daemon thread will not have control over when it is terminated.
#The program will terminate once all non-daemon threads finish, even if there are daemon threads still
#running at that point of time

#The process will exit if only daemon threads are running, whereas it cannot exit if at least one non-daemon thread is running.

#A process will exit if only daemon threads are running (or if no threads are running).
#A process will not exit if at least one non-daemon thread is running.



#Creating a Daemon Thread
#To create a daemon thread, you need to set the daemon property to True.
t1=threading.Thread(daemon=True)
#If a thread object is created without any parameter, its daemon property can also be set to True,
#before calling the start() method.
t1=threading.Thread()
t1.daemon=True

#example-1
from time import sleep
from threading import current_thread
from threading import Thread

# function to be executed in a new thread
def run():
   # get the current thread
   thread = current_thread()
   # is it a daemon thread?
   print(f'Daemon thread: {thread.daemon}')
    
# create a new thread
thread = Thread(target=run, daemon=True)

# start the new thread
thread.start()

# block for a 0.5 sec for daemon thread to run
sleep(0.5)

#Daemon threads can perform executing tasks that support non-daemon threads in the program.
#For example :
#   Create a file that stores Log information in the background.
#   Perform web scraping in the background.
#   Save the data automatically into a database in the background.


#cannot thread daemon property set to True, after calling start
from time import sleep
from threading import current_thread
from threading import Thread

# function to be executed in a new thread
def run():
   # get the current thread
   thread = current_thread()
   # is it a daemon thread?
   print(f'Daemon thread: {thread.daemon}')
   thread.daemon = True     #--->  raise RuntimeError("cannot set daemon status of active thread")
                            #      RuntimeError: cannot set daemon status of active thread
   
# create a new thread
thread = Thread(target=run)

# start the new thread
thread.start()

# block for a 0.5 sec for daemon thread to run
sleep(0.5)





#--------------------------------------
#Synchronizing Threads
#you can use lock() method to lock some threads and use it again



import threading
import time

class myThread (threading.Thread):
    def __init__(self, threadID, name, counter):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.counter = counter

    def run(self):
        print ("Starting " + self.name)
        # Get lock to synchronize threads
        threadLock.acquire()
        print_time(self.name, self.counter, 3)
        # Free lock to release next thread
        threadLock.release()
      
def print_time(threadName, delay, counter):
   while counter:
      time.sleep(delay)
      print ("%s: %s" % (threadName, time.ctime(time.time())))
      counter -= 1
      
threadLock = threading.Lock()
threads = []



# Create new threads
thread1 = myThread(1, "Thread-1", 1)
thread2 = myThread(2, "Thread-2", 2)

# Start new Threads
thread1.start()
thread2.start()

# Add threads to thread list    #why???
threads.append(thread1)
threads.append(thread2)

# Wait for all threads to complete
for t in threads:
   t.join()         #what is join? when we start them before
print ("Exiting Main Thread")

#--->   Starting Thread-1
#       Starting Thread-2
#       Thread-1: Thu Jul 13 21:10:11 2023
#       Thread-1: Thu Jul 13 21:10:12 2023
#       Thread-1: Thu Jul 13 21:10:13 2023
#       Thread-2: Thu Jul 13 21:10:15 2023
#       Thread-2: Thu Jul 13 21:10:17 2023
#       Thread-2: Thu Jul 13 21:10:19 2023
#       Exiting Main Thread



#Lock in multiprocessing module
from multiprocessing import Lock, Process, Queue, current_process  
import time  
import queue   
def jobTodo(tasks_to_perform, complete_tasks):  
    while True:  
        try:   # The try block to catch task from the queue.  
            task = tasks_to_perform.get_nowait()  # The get_nowait() function is used to raise queue.Empty exception if the queue is empty.  
        except queue.Empty:  
            break  
        else:  # if no exception has been raised, the else block will execute add the task completion 
            print(task)  
            complete_tasks.put(task + ' is done by ' + current_process().name)  
            time.sleep(.5)  
    return True  
def main():  
    total_task = 8  
    total_number_of_processes = 3  
    tasks_to_perform = Queue()  
    complete_tasks   = Queue()  
    number_of_processes = []  
    for i in range(total_task):  
        tasks_to_perform.put("Task no " + str(i))  
    for w in range(total_number_of_processes):      # defining number of processes  
        p = Process(target=jobTodo, args=(tasks_to_perform, complete_tasks))  
        number_of_processes.append(p)  
        p.start()  
    for p in number_of_processes:  # completing process  
        p.join()  
    while not complete_tasks.empty():   # print the output  
        print(complete_tasks.get())  
    return True  
if __name__ == '__main__':  
    main()  
#--->  
'''
Task no 2
Task no 5
Task no 0
Task no 3
Task no 6
Task no 1
Task no 4
Task no 7
Task no 0 is done by Process-1
Task no 1 is done by Process-3
Task no 2 is done by Process-2
Task no 3 is done by Process-1
Task no 4 is done by Process-3
Task no 5 is done by Process-2
Task no 6 is done by Process-1
Task no 7 is done by Process-3
'''



#--------------------------------------
#Inter-Thread Communication

#EVENT Object
#threads in the same process can communicate with each other.
#An Event object manages the state of an internal flag.
#work based on an internal flag (internal flag is inside of memory )

#is_set()               Return True if and only if the internal flag is true
#set()                  Set the internal flag to true
#clear()                Reset the internal flag to false
#wait(timeout=None)     Block until the internal flag is true

from threading import *
import time

def signal_state():
    while True:
        time.sleep(5)
        print("Traffic Police Giving GREEN Signal")
        event.set()
        time.sleep(10)
        print("Traffic Police Giving RED Signal")
        event.clear()

def traffic_flow():
    num=0
    while num<10:
        print("Waiting for GREEN Signal")
        event.wait()
        print("GREEN Signal ... Traffic can move")
        while event.is_set():
            num=num+1
            print("Vehicle No:", num," Crossing the Signal")
            time.sleep(2)
        print("RED Signal ... Traffic has to wait")

event = Event()

t1 = Thread( target = signal_state )
t2 = Thread( target = traffic_flow )

t1.start()
t2.start()

#--->  
'''
Waiting for GREEN Signal
Traffic Police Giving GREEN Signal
GREEN Signal ... Traffic can move
Vehicle No: 1 Crossing the Signal
Vehicle No: 2 Crossing the Signal
Vehicle No: 3 Crossing the Signal
Vehicle No: 4 Crossing the Signal
Vehicle No: 5 Crossing the Signal
Signal is RED
RED Signal ... Traffic has to wait
Waiting for GREEN Signal
Traffic Police Giving GREEN Signal
GREEN Signal ... Traffic can move
Vehicle No: 6 Crossing the Signal
Vehicle No: 7 Crossing the Signal
Vehicle No: 8 Crossing the Signal
Vehicle No: 9 Crossing the Signal
Vehicle No: 10 Crossing the Signal
'''


#CONDITION Object
#Condition object forces one or more threads to wait until notified by another thread.
#acquire(*args)         This method calls the corresponding method on the underlying lock; the return value is whatever that method returns.
#release()              This method calls the corresponding method on the underlying lock; there is no return value.
#wait(timeout=None)     This method releases the underlying lock, and then 
#                       blocks until it is awakened by a notify() or notify_all() 
#wait_for(predicate, timeout=None)
#                       call wait() repeatedly until the predicate is satisfied, or until a timeout occurs. 
#notify(n=1)            This method wakes up at most n of the threads waiting for the condition variable; 
#notify_all()           Wake up all threads waiting on this condition. 

from threading import *
import time
import random

numbers=[]

def taskA(c):
    while True:
        c.acquire()
        num=random.randint(1,10)
        print("Generated random number:", num)
        numbers.append(num)
        print("Notification issued")
        c.notify()
        c.release()
        time.sleep(5)

def taskB(c):
    while True:
        c.acquire()
        print("waiting for update")
        c.wait()
        print("Obtained random number", numbers.pop())
        c.release()
        time.sleep(5)

c = Condition()
t1 = Thread( target = taskB, args=(c,) )
t2 = Thread( target = taskA, args=(c,) )
t1.start()
t2.start()

#---> 
'''
waiting for update
Generated random number: 4
Notification issued
Obtained random number 4
waiting for update
Generated random number: 6
Notification issued
Obtained random number 6
waiting for update
Generated random number: 10
Notification issued
Obtained random number 10
waiting for update
'''

#Proxy Objects
from multiprocessing import Manager  
manager = Manager()  
l = manager.list([i*i for i in range(10)])  
print(l)  #--->  [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
print(repr(l))  #--->  <ListProxy object, typeid 'list' at 0x7f063621ea10>
print(l[4])     #--->  16
print(l[2:5])   #--->  [4, 9, 16]








#--------------------------------------
#Thread Deadlock
#A deadlock may be described as a concurrency failure mode
#It is a situation in a program where one or more threads wait for a condition that never occurs.
#As a result, the threads are unable to progress and the program is stuck or frozen and must be terminated manually.
#Deadlocks are in fact a side effect or bug in the code.

#Common causes of thread deadlocks are:
#   A thread that attempts to acquire the same mutex lock twice.
#   Threads that wait on each other (e.g. A waits on B, B waits on A).
#   When a thread that fails to release a resource such as lock, semaphore, condition, event, etc.
#   Threads that acquire mutex locks in different orders (e.g. fail to perform lock ordering).

#If more than one threads in a multi-threaded application try to gain access to same resource, such as performing read/write operation on same file, it may cause data inconsistency


#The Lock Object
#An object of Lock class has two possible states − locked or unlocked, initially in unlocked state when first created.

#acquire()      When the state is unlocked, this method changes the state to locked and returns immediately. The method takes an optional blocking argument.
#release()      When the state is locked, this method in another thread changes it to unlocked. This can be called from any thread, not only the thread which has acquired the lock

#Lock.acquire(blocking, timeout)
#blocking - If set to False, it means do not block. If a call with blocking set to True would block, return False immediately; otherwise, set the lock to locked and return True.


#example
from threading import Thread, Lock
import time

lock = Lock()
threads = []

class myThread(Thread):
    def __init__(self,name):
        Thread.__init__(self)
        self.name=name

    def run(self):
        lock.acquire()
        synchronized(self.name)
        lock.release()

def synchronized(threadName):
    print ("{} has acquired lock and is running synchronized method".format(threadName))
    counter=5
    while counter:
        print ('**', end='')
        time.sleep(2)
        counter = counter-1
    print('\nlock released for', threadName)

t1 = myThread('Thread1')
t2 = myThread('Thread2')

t1.start()
threads.append(t1)

t2.start()
threads.append(t2)

for t in threads:
   t.join()
print ("end of main thread")

#--->  
'''
Thread1 has acquired lock and is running synchronized method
**********
lock released for Thread1
Thread2 has acquired lock and is running synchronized method
**********
lock released for Thread2
end of main thread
'''


#--------------------------------------
#Semaphore Object
#Python supports thread synchronization with another mechanism called semaphore.
#It is one of the oldest synchronization techniques invented by computer scientist, Edsger W. Dijkstra.

#The basic concept of semaphore is to use an internal counter which is decremented by each acquire() call and incremented by each release() call. The counter can never go below zero; when acquire() finds that it is zero, it blocks, waiting until some other thread calls release().



#acquire()       If the internal counter is larger than zero on entry, decrement it by one and return True immediately.
#release()       Release a semaphore, incrementing the internal counter by 1.


#example
from threading import *
import time

lock = Semaphore(4) # creating thread instance where count = 3

def synchronized(name): # creating instance
   
    lock.acquire()  # calling acquire method

    for n in range(3):
        print('Hello! ', end = '')
        time.sleep(1)

        print( name)

        lock.release() # calling release method

# creating multiple thread
thread_1 = Thread(target = synchronized , args = ('Thread 1',))
thread_2 = Thread(target = synchronized , args = ('Thread 2',))
thread_3 = Thread(target = synchronized , args = ('Thread 3',))

# calling the threads
thread_1.start()
thread_2.start()
thread_3.start()


#--->  
'''
Hello! Hello! Hello! Thread 1
Thread 2
Hello! Thread 3
Hello! Hello! Thread 1
Thread 2
Thread 3
Hello! Hello! Hello! Thread 1
Thread 2
Thread 3
'''



#--------------------------------------
#Interrupting a Thread

#In a multi-threaded program, a task in a new thread, may be required to be stopped.
#This may be for many reasons, such as: 
# (a) The result from the task is no longer required or 
# (b) outcome from the task has gone astray or 
# (c) The application is shutting down.

#A thread can be stopped using a threading.Event object. An Event object manages the state of an internal flag that can be either set or not set.
#Till the event is detected, loop in the run() method continues. As soon as the event is detected, the loop terminates.

#example
from time import sleep
from threading import Thread
from threading import Event

class MyThread(Thread):
    def __init__(self, event):
        super(MyThread, self).__init__()
        self.event = event

    def run(self):
        i=0
        while True:
            i+=1
            print ('Child thread running...',i)
            sleep(0.5)
            if self.event.is_set():
                break
            print()

        print('Child Thread Interrupted')

event = Event()
thread1 = MyThread(event)
thread1.start()

sleep(3)
print('Main thread stopping child thread')
event.set()
thread1.join()

#--->  
'''
Child thread running... 1
Child thread running... 2
Child thread running... 3
Child thread running... 4
Child thread running... 5
Child thread running... 6
Main thread stopping child thread
Child Thread Interrupted
'''







##########################################################################################################
#GLOB_MODULE
##########################################################################################################
#Search in files and directories
#https://docs.python.org/3/library/glob.html

import glob
#relative
result = glob.glob("../*")  #desktop folder
result = glob.glob("????")  #show me all which has 4 character
result = glob.glob("[a-f]*")  #show me all which their names start with a-f
result = glob.glob("**", recursive = True)       #also search inside of directories and show me all
result = glob.glob("**/*.py", recursive = True)  #show me all .py files
#absolute
result = glob.glob("/home/amir/Desktop/*") 
result = glob.glob("*", root_dir = "/home/amir/Desktop/")  #set root to search from there


#iglob
result = glob.iglob("*")  #iterative glob
print(result)       #--->  <generator object _iglob at 0x7f7bdf62f190>
print(next(result)) #--->  main.py


##########################################################################################################
#GC_MODULE
##########################################################################################################
#when python want to save an obkect use heap memory type
#cpython    is python which made with c 
#ironpython is python which made with c#
#jython     is python which made with java for java platforms

#c => malloc  free
#malloc for memory allocation
#free for make memory free

##########################################################################################################
#FILE_HANDLING
##########################################################################################################    

#read
#reads bytes from a standard input stream device i.e. keyboard.
#read input from the user
#way-1
name = input()
#way-2
import sys
name = sys.stdin.readline()


#write
#sends the data towards standard output stream device, i.e., the display monitor
#way-1
print (name)
#way-2
import sys
sys.stdout.write(name)


#creates a file object
#file object = open(file_name [, access_mode][, buffering])
try:  
    with open('file1.txt', 'w') as f:  
        f.write('Here we create a new file')  
except FileNotFoundError:  
    print("The file is does not exist") 

#Create a New File
#To create a new file in Python, use the open() method, with one of the following parameters:
#       "x" - Create -  will create a file, returns an error if the file exist
#       "a" - Append -  will create a file if the specified file does not exist
#       "w" - Write  -  will create a file if the specified file does not exist

#File Opening Modes
'''
r       Opens a file for reading only. The file pointer is placed at the beginning of the file. This is the default mode.
rb      Opens a file for reading only in binary format. The file pointer is placed at the beginning of the file. This is the default mode.	
r+      Opens a file for both reading and writing. The file pointer placed at the beginning of the file.
rb+     Opens a file for both reading and writing in binary format. The file pointer placed at the beginning of the file.
w       Opens a file for writing only. Overwrites the file if the file exists. If the file does not exist, creates a new file for writing.
b       Opens the file in binary mode
t       Opens the file in text mode (default)
+       open file for updating (reading and writing)
wb      Opens a file for writing only in binary format. Overwrites the file if the file exists. If the file does not exist, creates a new file for writing.
w+      Opens a file for both writing and reading. Overwrites the existing file if the file exists. If the file does not exist, creates a new file for reading and writing.
wb+     Opens a file for both writing and reading in binary format. Overwrites the existing file if the file exists. If the file does not exist, creates a new file for reading and writing.	
a       Opens a file for appending. The file pointer is at the end of the file if the file exists. That is, the file is in the append mode. If the file does not exist, it creates a new file for writing.
ab      Opens a file for appending in binary format. The file pointer is at the end of the file if the file exists. That is, the file is in the append mode. If the file does not exist, it creates a new file for writing.
a+      Opens a file for both appending and reading. The file pointer is at the end of the file if the file exists. The file opens in the append mode. If the file does not exist, it creates a new file for reading and writing.
ab+     Opens a file for both appending and reading in binary format. The file pointer is at the end of the file if the file exists. The file opens in the append mode. If the file does not exist, it creates a new file for reading and writing.
x       Creates the specified file, returns an error if the file exists

w+      open a file just in empty or make it empty and open
a+      open file or make an empty file

when we open a file with 'w' or 'a' pointer will go to end of content and if we print we will see nothing
when we open a file with 'r'        pointer will go to start of content and if we print we will see anything
after opening of file if you write something in file the pointer will move and you can use seek() to change it position
seek() give an offset to find where it want to be. Zero offset is the first of file   (seek(0))  
'''



#Open a file
fo = open("foo.txt", "wb")
print ("Name of the file: ", fo.name)   #--->  foo.txt
print ("Closed or not: ", fo.closed)    #--->  False
print ("Opening mode: ", fo.mode)       #--->  wb
fo.close()

#in new versions of python you should say encoding mode when want to open
fo = open("myfile.txt", 'r', encoding = "utf-8")    #default mode is 'r' read


#safe way to open a file
with open("myfile.txt", 'r', encoding = "utf-8") as fo:
    fo.read()
    print(" ")
    #...

#check file health   
fileptr = open("file.txt","r")     
if fileptr:    
    print("The existing file is opened successfully in Python")    


#error handling when open file
try:  
   fileptr = open("file.txt")  
   # perform file operations  
finally:  
   fileptr.close()  
   
   
#Write to File
fo.write( "Python is a great language.\nYeah its great!!\n")

#Write to an Existing File
#To write to an existing file, you must add a parameter to the open() function:
#       "a" - Append - will append to the end of the file
#       "w" - Write  - will overwrite any existing content (in the first time it made file, empty then write new and from second time when you use f.write just write addition)



#Writing in Binary Mode
data=b"Hello World"                 #Conversion of text string to bytes
#or
data="Hello World".encode('utf-8')  #Conversion of text string to bytes
f.write(data)


#Appending to a File
fo = open("foo.txt", "a")       # Open a file in append mode
text = "TutorialsPoint has a fabulous Python tutorial"
fo.write(text)


#Using w+ Mode
#When a file is opened for writing (with 'w' or 'a'), it is not possible to perform write operation at any 
#earlier byte position in the file. Th 'w+' mode enables using write() as well as read() methods without 
#closing a file.
fo=open("foo.txt","w+")     #Open a file in read-write mode
fo.write("This is a rat race")
fo.seek(10,0)               #to rewind the stream to any desired byte position.
data=fo.read(3)             #read and get from file
fo.seek(10,0)
fo.write('cat')
fo.close()

# Open a file in read-write mode
fo=open("foo.txt","w+")
fo.write("This is a rat race")
fo.seek(10,0)
data=fo.read(3)
print(data)         #---> rat
fo.seek(10,0)
fo.write('cat')
fo.seek(0,0)
data=fo.read()
print (data)        #--->  This is a cat race
fo.close()

#if the file is opened for appending using either 'a' or 'a+', any seek() operations will be undone at the next write.

#When a file is opened for writing (with 'w' or 'a'), We need to close the file before doing other operation.
#In order to perform both operations simultaneously, we have to add '+' character in the mode parameter. Hence 'w+' or 'r+' mode enables using write() as well as read() methods without closing a file. 


#Read Files
fo = open("foo.txt", "r")
#or
fo = open("foo.txt")
#To programmatically read data from a file using Python, it must be opened first.
print(fo.read())
#or
text = fo.read()
print (text)

print(fo.read(30))  # read just 30 character


#Reading in Binary Mode
#If we want to handle files of different other types such as media (mp3), executables (exe), pictures (jpg) 
#etc., we need to add 'b' prefix to read/write mode.
f=open('test.bin', 'wb')
data=b"Hello World"
f.write(data)       #written with binary mode.
f.close()
#We need to use 'rb' mode to read binary file
f=open('test.bin', 'rb')
data=f.read()
print (data.decode(encoding='utf-8'))       #--->  Hello World


#Read Integer Data
#write integer data in a binary file
n=25
n.to_bytes(8,'big')         #the integer object should be converted to bytes
f=open('test.bin', 'wb')
data=n.to_bytes(8,'big')
f.write(data)
#read back from a binary file
f=open('test.bin', 'rb')
data=f.read()
n=int.from_bytes(data, 'big')   #convert the output of read() function to integer
print (n)



#Read Float Data from File
#write float
import struct
x=23.50
data=struct.pack('f',x)     #'f' For floating point data
f=open('test.bin', 'wb')
f.write(data)
#read from binary file.
f=open('test.bin', 'rb')
data=f.read()
x=struct.unpack('f', data)
print (x)


#Read Line
f = open("demofile.txt", "r")
print(f.readline())
print(f.readline())

#Read Lines
f = open("demofile.txt", "r")
print(f.readlines())        #---> a list of readed data (iterable by for loop)


#example
# Open a file in read/write mode
fo = open("abc.txt", "r+")
print ("Name of the file: ", fo.name)
str = "This is 6th line"
fo.seek(0, 2)           # Write a line at the end of the file.
line = fo.write( str )
fo.seek(0,0)            # Now read complete file from beginning.
for index in range(6):
   line = next(fo)
   print ("Line No %d - %s" % (index, line))
fo.close()              #--->  Line No 0 - This is 1st line
                        #      Line No 1 - This is 2nd line
                        #      Line No 2 - This is 3rd line
                        #      Line No 3 - This is 4th line
                        #      Line No 4 - This is 5th line
                        #      Line No 5 - This is 6th line


#Using the r+ Mode
#When a file is opened for reading (with 'r' or 'rb'), it is not possible to write data in it. We need to close
#the file before doing other operation. In order to perform both operations simultaneously, we have to add '+'
#character in the mode parameter. Hence 'w+' or 'r+' mode enables using write() as well as read() methods
#without closing a file.
fo=open("foo.txt","r+")
fo.seek(10,0)
data=fo.read(3)
print (data)
fo.close()

#with statement
with open("file.txt",'r') as f: 
    A = f.write("Hello Coders") 
    print(A)                #print what you write in file  
    content = f.read()
    print(content)          #print what you read from file
    


#loop in file
for i in fileptr:    
    print(i)                # i contains each line of the file     


#Close file
fo.close()

#read line by line
with open('Zen.txt', 'r', encoding = "utf-8") as f:
    for x in f:
        print(x)
        print("---------------")
        
#find end of file
data = fo.read()
if data =="" :
    print("end of file (eof)")

if data == None :
    print("end of file (eof)")

if not data :
    print("end of file (eof)")

while data :
    #do something
    pass

#write line by line 
fo.writelines(data)




#check for the special characters
fhand = open('daffodils.txt')
for line in fhand:
    print(repr(line))   #--->  ???
    
    
#Reading CSV Files
import csv
with open('chocolate.csv') as f:
    reader = csv.reader(f, delimiter=',')
    for row in reader:
        print(row)     
        #--->   ['A. Morin', 'Kpime', '1676', '2015', '70%', 'France', '2.75', 'Â\xa0', 'Togo']
        #       ['Acalli', 'Chulucanas, El Platanal', '1462', '2015', '70%', 'U.S.A.', '3.75', 'Â\xa0', 'Peru']
        #       ['Aequare (Gianduja)', 'Los Rios, Quevedo, Arriba', '370', '2009', '55%', 'Ecuador', '2.75', 'Forastero (Arriba)', 'Ecuador']
        #       ["Akesson's (Pralus)", 'Madagascar, Ambolikapiky P.', '502', '2010', '75%', 'Switzerland', '2.75', 'Criollo', 'Madagascar']
        

import csv
with open('chocolate.csv') as f:
    reader = csv.reader(f, delimiter=',')
    for row in reader:
        print("The {} company is located in {}.".format(row[0], row[5]))
        #--->   The A. Morin company is located in France.
        #       The Acalli company is located in U.S.A..
        #       The Aequare (Gianduja) company is located in Ecuador.
        #       The Akesson's (Pralus) company is located in Switzerland.
        




#Array To File
#writes all items (as machine values) in the array to the file object f.
import array as arr
f = open('list.txt','wb')
arr.array("i", [10, 20, 30, 40, 50]).tofile(f)
f.close()


#Array from File
#reads a binary file and appends specified number of items to the array object.
array.fromfile(f, n)
#f − The file object referring to a disk file opened in rb mode
#n − number of items to be appended
import array as arr
a = arr.array('i', [1, 2, 3, 4, 5])
f = open("list.txt", "rb")
a.fromfile(f, 5)
print (a)       #--->  array('i', [1, 2, 3, 4, 5, 10, 20, 30, 40, 50])


#Writing Python output to the files:
#   file1.py
temperatures=[10,-20,-289,100]    
def c_to_f(c):    
    if c< -273.15:    
        return "That temperature doesn't make sense!"    
    else:    
        f=c*9/5+32    
        return f    
for t in temperatures:    
    print(c_to_f(t))   

#file.py
import subprocess    
with open("output.txt", "wb") as f:    
    subprocess.check_call(["python", "file.py"], stdout=f)  #--->  ???
    
    
 
##########################################################################################################
#FILE_METHODS
##########################################################################################################
#file.flush()                    
#Flush the internal buffer, like stdio's fflush. This may be a no-op on some file-like objects.
#The method flush() flushes the internal buffer, like stdio's fflush. This may be a no-op on some file-like objects.
#Python automatically flushes the files when closing them. But you may want to flush the data before closing any file.
fo = open("foo.txt", "wb")
fo.flush()      # Here it does nothing, but you can call it with read operation.
fo.close()


#file_fileno()                   
#Returns the integer file descriptor that is used by the underlying implementation to request I/O operations
#from the operating system.
fo = open("foo.txt", "wb")
fid = fo.fileno()
print ("File Descriptor: ", fid)        #--->  3
fo.close()


#file.isatty()                   
#Returns True if the file is connected to a tty(-like) device, else False.
fo = open("foo.txt", "wb")
print ("Name of the file: ", fo.name)
ret = fo.isatty()
print ("Return value : ", ret)
fo.close()


#next(file)                      
#Returns the next line from the file each time it is being called.
#This method can be used to read the next input line, from the file object.
f=open("foo.txt","r")
while True:
    try:
        line = next(f)
        print (line)    #--->  C++
    except:             #      Java
        StopIteration   #      Python
        break           #      Perl
f.close()               #      PHP


#file.read([size])               
#Reads at most size bytes from the file (less if the read hits EOF before obtaining size bytes).
#size − This is the number of bytes to be read from the file.
fo = open("foo.txt", "r+")
print ("Name of the file: ", fo.name)
line = fo.read(10)
print ("Read Line: %s" % (line))
fo.close()

'''
foo.txt :
This is 1st line
This is 2nd line
This is 3rd line
This is 4th line
This is 5th line
'''


#file.readline([size])           
#Reads one entire line from the file. A trailing newline character is kept in the string.
#If the size argument is present and non-negative, it is a maximum byte count including the trailing newline and an incomplete line may be returned.
fo = open("foo.txt", "r+")
line = fo.readline()
print ("Read Line: %s" % (line))        #--->  This is 1st line
line = fo.readline(5)
print ("Read Line: %s" % (line))        #--->  This
fo.close()


#file.readlines([sizehint])      
#Reads until EOF using readline() and return a list containing the lines. If the optional sizehint argument is present, instead of reading up to EOF, whole lines totalling approximately sizehint bytes (possibly after rounding up to an internal buffer size) are read.
fo = open("foo.txt", "r+")
line = fo.readlines()
print ("Read Line: %s" % (line))        #--->  ['This is 1st line\n', 'This is 2nd line\n',
                                        #'This is 3rd line\n', 'This is 4th line\n',
                                        #'This is 5th line\n']  ???
line = fo.readlines(2)
print ("Read Line: %s" % (line))
fo.close()


#file.seek(offset[, whence])     
#Sets the file's current position	
fo = open("foo.txt", "rw+")
line = fo.readlines()
print ("Read Line: %s" % (line))    #--->  ['This is 1st line\n', 'This is 2nd line\n', 'This is 3rd line\n', 'This is 4th line\n', 'This is 5th line']
fo.seek(0, 0)                       # Again set the pointer to the beginning
line = fo.readline()
print ("Read Line: %s" % (line))    #--->  This is 1st line
fo.close()


#file.tell()                     
#Returns the file's current position
#returns the current position of the file read/write pointer within the file.
fo = open("foo.txt", "r+")
line = fo.readline()    
print ("Read Line: %s" % (line))    #--->  This is 1st line
pos=fo.tell()
print ("current position : ",pos)   #--->  18
fo.close()


#file.truncate([size])           
#Truncates the file's size. If the optional size argument is present, the file is truncated to (at most) that size.
fo = open("foo.txt", "r+")
line = fo.readline()
print ("Read Line: %s" % (line))    #--->  This is 1s   ???
fo.truncate()
line = fo.readlines()
print ("Read Line: %s" % (line))    #--->   []  ???
fo.close()


#file.writelines(sequence)       
#Writes a sequence of strings to the file. The sequence can be any iterable object producing strings, typically a list of strings.
fo=open("foo.txt","r+")
seq = ["This is 6th line\n", "This is 7th line"]
fo.seek(0, 2)                # Write sequence of lines at the end of the file.
line = fo.writelines( seq )
fo.seek(0,0)                 # go to first line to print all
while True:
   try:
      line = next(fo)
      print (line)
   except:
      StopIteration
      break
fo.close()

#############################
##  os File/Directory Methods
#############################
#os.close(fd)                        Close file descriptor fd.
#???

#os.closerange(fd_low, fd_high)      
#Close all file descriptors from fd_low (inclusive) to fd_high (exclusive), ignoring errors.
#This method is introduced in Python version 2.6.
#fd_low  − This is the Lowest file descriptor to be closed.
#fd_high − This is the Highest file descriptor to be closed.
import os, sys
fd = os.open( "foo.txt", os.O_RDWR|os.O_CREAT )
line="this is test" 
b=str.encode(line)
os.write(fd, b)
os.closerange( fd, fd)      # Close a single opened file
print ("Closed all the files successfully!!")


#os.dup(fd)                          
#Return a duplicate of file descriptor fd which can be used in place of original descriptor.
import os, sys
fd = os.open( "foo.txt", os.O_RDWR|os.O_CREAT )
d_fd = os.dup( fd )     # Get one duplicate file descriptor
line="this is test" 
b=str.encode(line)
os.write(d_fd, b)
os.closerange( fd, d_fd)
print ("Closed all the files successfully!!")


#os.fdatasync(fd)                    
#Force write of file with file descriptor fd to disk.
#If you want to flush your buffer then you can use this method.
import os, sys
fd = os.open( "foo.txt", os.O_RDWR|os.O_CREAT )
line="this is test"
b=str.encode(line)
os.write(fd, b)
os.fdatasync(fd)
os.lseek(fd, 0, 0)      # Now read this file from the beginning.
str = os.read(fd, 100)
line = os.read(fd, 100)
str=line.decode()
print ("Read String is : ", str)
os.close( fd )      # Close opened file
print ("Closed the file successfully!!")



#os.fdopen(fd[, mode[, bufsize]])    
#Return an open file object connected to the file descriptor fd.
import os, sys
fd = os.open( "foo.txt", os.O_RDWR|os.O_CREAT )
fo = os.fdopen(fd, "w+")                                      # Now get a file object for the above file.
print ("Current I/O pointer position :%d" % fo.tell())        # Tell the current position  0
fo.write( "Python is a great language.\nYeah its great!!\n"); # Write one string
os.lseek(fd, 0, 0)                                            # Now read this file from the beginning.
str = os.read(fd, 100)
print ("Read String is : ", str)                              #--->  This is testPython is a great language.
                                                              #      Yeah its great!!
print ("Current I/O pointer position :%d" % fo.tell())        # Tell the current position   45
fo.close()
print ("Closed the file successfully!!")


#os.fsync(fd)                        
#Force write of file with file descriptor fd to disk.
#If you're starting with a Python file object f, first do f.flush(), and then do os.fsync(f.fileno()), to
#ensure that all internal buffers associated with f are written to disk.
fd = os.open( "foo.txt", os.O_RDWR|os.O_CREAT )
os.fsync(fd)



#os.ftruncate(fd, length)            
#Truncate the file corresponding to file descriptor fd, so that it is at most length bytes in size.
import os, sys
fd = os.open( "foo.txt", os.O_RDWR|os.O_CREAT )
os.write(fd, "This is test - This is test")
os.ftruncate(fd, 10)
os.lseek(fd, 0, 0)      # Now read this file from the beginning.
str = os.read(fd, 100)
print ("Read String is : ", str)
os.close( fd )
print ("Closed the file successfully!!")



#os.lseek(fd, pos, how)              
#Set the current position of file descriptor fd to position pos, modified by how.
#pos − This is the position in the file with respect to given parameter how. 
#       os.SEEK_SET or 0 to set the position relative to the beginning of the file,
#       os.SEEK_CUR or 1 to set it relative to the current position; 
#       os.SEEK_END or 2 to set it relative to the end of the file.
#how − This is the reference point with-in the file. 
#       os.SEEK_SET or 0 means beginning of the file, 
#       os.SEEK_CUR or 1 means the current position and 
#       os.SEEK_END or 2 means end of the file.
os.lseek(fd, 0, 0)      # Now read this file from the beginning
line = os.read(fd, 100)
print ("Read String is : ", line.decode())



#os.open(file, flags[, mode])        
#Open the file file and set various flags according to flags and possibly its mode according to mode.
#This method returns the file descriptor for the newly opened file
#parameters :
#file   − File name to be opened.
#flags  − The following constants are options for the flags. They can be combined using the bitwise OR operator |. Some of them are not available on all platforms.
#       os.O_RDONLY:    open for reading only
#       os.O_WRONLY:    open for writing only
#       os.O_RDWR :     open for reading and writing
#       os.O_NONBLOCK:  do not block on open
#       os.O_APPEND:    append on each write
#       os.O_CREAT:     create file if it does not exist
#       os.O_TRUNC:     truncate size to 0
#       os.O_EXCL:      error if create and file exists
#       os.O_SHLOCK:    atomically obtain a shared lock
#       os.O_EXLOCK:    atomically obtain an exclusive lock
#       os.O_DIRECT:    eliminate or reduce cache effects
#       os.O_FSYNC :    synchronous writes
#       os.O_NOFOLLOW:  do not follow symlinks
#mode   − This work in similar way as it works for chmod() method.
import os, sys
fd = os.open( "foo.txt", os.O_RDWR|os.O_CREAT )     # Open a file



#os.read(fd, n)                      
#Read at most n bytes from file descriptor fd. Return a string containing the bytes read. If the end of 
#the file referred to by fd has been reached, an empty string is returned.
import os, sys
fd = os.open("foo.txt",os.O_RDWR)       # Open a file
ret = os.read(fd,12)                    # Reading text
print (ret.decode())


#os.tmpfile()                        
#Return a new file object opened in update mode (w+b).
#???


#os.write(fd, str)                   
#Write the string str to file descriptor fd. Return the number of bytes actually written.
import os, sys
fd = os.open( "f1.txt", os.O_RDWR|os.O_CREAT )
line="this is test"
b=str.encode(line)
ret=os.write(fd, b)
print ("the number of bytes written: ", ret)        # ret consists of number of bytes written to f1.txt


#os.getcwd()
#This method returns the current working directory which have absolute value. The getcwd() method returns 
#the string value which represents the working dictionary in Python. In getcwd() method, do not require any 
#parameter.
import os  
os.getcwd()     #--->  'C:\\Users\\DEVANSH SHARMA'          print The working directory


#Changing the current working directory
#is used to change the current working directory to a specified directory.
#takes a single argument for the new dictionary path. 
#does not return any kind of value.
import os   
os.chdir("C:\\Users\\DEVANSH SHARMA\\Documents")    #Changing current directory with the new directory  
os.getcwd()                                         #It will display the current working directory   


#os.rmdir()
#To delete an entire folder
#To delete a file from folder use os.remove()
import os
os.rmdir("myfolder")


#ZIP
#zip
import zlib
sen = "ali has four books and two balls"
bsen = b"ali has four books and two balls"
print(len(sen))     #--->  32
print(len(bsen))    #--->  32
zsen = zlib.compress(bsen)
print(len(zsen))    #--->  40



##########################################################################################################
#STUB_FILES
##########################################################################################################

#ANNOTATIONS
#TYPING
#STUB


#------------------
#annotations
#------------------
#a guide for other programmers

def show(name:str, age:int):
    return f"{name} is {age} years old"

def show(name:'your name', age:'your age') -> str:
    return f"{name} is {age} years old"

def show(name:'your name', age:'your age') -> 'this function returns string':
    return f"{name} is {age} years old"




class home(APIView):

    def setup(self, request, id):  
        self.album: Album = Album.objects.get(id=id)
        return super().setup(self, request, id)


from rest_framework.request import Request
a(request: Request) # request is from type of Request with 'request' name

#------------------
#typing
#------------------
import typing
#   typing.Dict
#   typing.Set
#   typing.List
#   typing.Tuple

def show(names:typing.Dict[str, int]):
    for name in names:
        print(name)


point = typing.Dict[str, int]
def show(names:point):
    for name in names:
        print(name)

#------------------
#stub
#------------------
#files for save annotations

#a type stub is a file with a .pyi extension that describe a module's types 
#while omitting implementation details

#for example:
#---------------
#in two.py file:

def show(name, age):
    return f"{name} is {age} years old"

#----------------
#in two.pyi file:                   (file names must be same)


def show(name: str, age: int) -> str:       # this is a stub for show func in two.py
    ...     #ellipsis object

#this is a stub for function in two.py 
#two.pyi is a stub file for two.py file



#we can add multiple cases with @overload inside of .pyi file
#for using to declare one function with multiple faces
from typing import overload
@overload
def minmax():
    pass
@overload 
def minmax():
    pass

#never write annotations inside of main code
#we just will write annotations inside of .pyi file 



#------------------
#Stub files
#are files containing type hints that are only for use by the type checker, not at runtime. 
#There are several use cases for stub files:
#   -Extension modules
#   -Third-party modules whose authors have not yet added type hints
#   -Standard library modules for which type hints have not yet been written
#   -Modules that must be compatible with Python 2 and 3
#   -Modules that use annotations for other purposes

#It is recommended that function bodies in stub files just be a single ellipsis (...)

#------------------
#overload
from typing import overload

class bytes:
    @overload
    def __getitem__(self, i: int) -> int: ...
    @overload
    def __getitem__(self, s: slice) -> bytes: ...

#------------------
#union
from typing import Union

class bytes:
    def __getitem__(self, a: Union[int, slice]) -> Union[int, bytes]: ...


#------------------
#class
class myClass(parent):  # no need annotations for classes
    pass    

#example-2
class Logged:
    def __init__(self, value: int, name: str, logger: byte) -> None:
        ...

    def set(self, new: T) -> None:
        ...

    def get(self) -> T:
        ...

    def log(self, message: str) -> None:
        ...



#------------------------------------------------
#ellipsis(...)

#as input argument
#i dont want to change it (if i use 'None' in place of ... it says my argument will change to 'None' )


def show():
    pass

#is equal to 

def show():
    ...


#if you want to specify a field that can take a None value while still being required you can use Optional with ...
#hamechiz hamintor ke hast bagi bemanad

#------------------------------------------------
#Function Annotations
#------------------------------------------------
def func(a: <expression>, b: <expression>) -> <expression>:
    pass
    
def func1(num1: "1st param", num2: "2nd param") -> "return type":
    return num1 + num2

def func2(num1: int, num2: int) -> int:
    return num1 + num2

def func3(num1: int, num2: int=10) -> int :
    return num1 + num2

#How to access annotations
def func(num1: int, num2: int=10) -> int :
    return num1 + num2

print(func.__annotations__) #---> {'num1': int, 'num2': int, 'return': int}


#------------------------------------------------
#Variable Annotations
#------------------------------------------------

my_var: int=10

# Example 1
name: str
print(__annotations__)  #--->  {'name': <class 'str'>}

# Example 2
city: str = 'Mysore'
print(__annotations__)  #--->  {'city': <class 'str'>}

# Example 3
age: int = 35
print(__annotations__)  #--->  {'age': 35}





#------------------------------------------------
#example
from typing import List

squares: List[int] = []

def square(num: int) -> List[int]:
    for i in range(num):
        squares.append(i**2)
    return squares

#Local annotations:
print(square.__annotations__)   #--->  {'num': int, 'return': typing.List[int]}

#Global annotations:
print(__annotations__)  #--->  {'squares': typing.List[int]}




##########################################################################################################
#CSV_FILE
##########################################################################################################
#A csv stands for "comma separated values", which is defined as a simple file format that uses specific structuring to arrange tabular data
#example of csv file
'''
--------------------------
Name	    Age	      City
--------------------------
Mehrdad	    27	      Tehran
Ali	        29	      Tabriz
Mehdi	    23	      Mashhad
'''

#Reading
import csv  
def main():  
    # To Open the CSV file  
    with open(' python.csv ', newline = '') as csv_file:  
        csv_read = csv.reader( csv_file, delimiter = ',')  
  
        # To Read and display each row  
        for row in csv_read:  
            print(row)  #--->  [ 'Name', 'Age', 'City' ]
                        #      [ 'Mehrdad', '27', 'Tehran' ]
                        #      [ 'Ali',     '29', 'Tabriz' ]
                        #      [ 'Mehdi',   '23', 'Mashhad']
if __name__ == '__main__':  
    main()  

#Read into Dictionary
import csv  
with open('python.csv', mode='r') as csv_file:  
    csv_reader = csv.DictReader(csv_file)  
    line_count = 0  
  
    for row in csv_reader:  
        if line_count == 0:  
            print( f'The column names are as follows : {", ".join(row)}' )  
            line_count += 1  
  
        print(  f'\t{row[ " Name " ]} lives in {row[" City "]} department and is {row[" Age "]} years old. ')  
        line_count += 1  
  
    print(f'Processed {line_count} lines.')   
'''
The column names are as follows : Name, Age, City
    Ram lives in Mumbai department and is 27 years old.
    Bheem lives in Pune department and is 29 years old.
    Sita lives in Delhi department and is 23 years old.
Processed 4 lines. 
'''


#Reading with Pandas
'''
Name, Hire Date, Salary, Leaves Remaining
John Idle, 08/15/14, 50000.00, 10
Smith Gilliam, 04/07/15, 65000.00, 8
Parker Chapman, 02/21/14,45000.00, 10
Jones Palin, 10/14/13, 70000.00, 3
Terry Gilliam, 07/22/14, 48000.00, 7
Michael Palin, 06/28/13, 66000.00, 8
'''
import pandas as pd  
df = pd.read_csv(' hrdata.csv ')  # Read the CSV file into a DataFrame   
print(df)  # Print the DataFrame  
'''
         Name                Hire Date     Salary      Leaves Remaining
0     John Idle              03/15/14      50000.0       10
1     Smith Gilliam          06/01/15      65000.0       8
2     Parker Chapman         05/12/14      45000.0       10
3     Jones Palin            11/01/13      70000.0       3
4     Terry Gilliam          08/12/14      48000.0       7
5     Michael Palin          05/23/13      66000.0       8
'''

#csv Module Functions:
#   csv.reader	                It reads the data from a csv file
#   csv.writer	                It writes the data to a csv file
#   csv.field_size_limit	    It returns the current maximum field size allowed by the parser.
#   csv.get_dialect	        It returns the dialect associated with a name.
#   csv.list_dialects	        It returns the names of all registered dialects.
#   csv.register_dialect	    It associates dialect with a name. The name must be a string or a Unicode object.
#   csv.unregister_dialect	    It deletes the dialect which is associated with the name from the dialect registry. If a name is not a registered dialect name, then an error is being raised.
#   csv.QUOTE_ALL	            It instructs the writer objects to quote all fields.
#   csv.QUOTE_MINIMAL	        It instructs the writer objects to quote only those fields which contain special characters such as quote char, delimiter, etc.
#   csv.QUOTE_NONNUMERIC	    It instructs the writer objects to quote all the non-numeric fields.
#   csv.QUOTE_NONE	            It instructs the writer object never to quote the fields.


#writing

data = [{'Rank': 'B', 'first_name': 'Parker', 'last_name': 'Brian'    },     
        {'Rank': 'A', 'first_name': 'Smith',  'last_name': 'Rodriguez'},    
        {'Rank': 'C', 'first_name': 'Tom',    'last_name': 'smith'    },    
        {'Rank': 'B', 'first_name': 'Jane',   'last_name': 'Oscar'    },     
        {'Rank': 'A', 'first_name': 'Alex',   'last_name': 'Tim'      }]    

import csv    
     
with open('Python.csv', 'w') as csvfile:    
    fieldnames = ['first_name', 'last_name', 'Rank']    
    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)    
     
    writer.writeheader()    
    writer.writerow({'Rank': 'B', 'first_name': 'Parker', 'last_name': 'Brian'})    
    writer.writerow({'Rank': 'A', 'first_name': 'Smith',    
                     'last_name': 'Rodriguez'})    
    writer.writerow({'Rank': 'B', 'first_name': 'Jane', 'last_name': 'Oscar'})    
    writer.writerow({'Rank': 'B', 'first_name': 'Jane', 'last_name': 'Loive'})    
     
print("Writing complete")   


#write with dictionary
import csv    
with open('python.csv', mode='w') as csv_file:    
    fieldnames = ['emp_name', 'dept', 'birth_month']    
    writer = csv.DictWriter(csv_file, fieldnames=fieldnames)    
    writer.writeheader()    
    writer.writerow({'emp_name': 'Parker', 'dept': 'Accounting', 'birth_month': 'November'})    
    writer.writerow({'emp_name': 'Smith', 'dept': 'IT', 'birth_month': 'October'})    
'''
emp_name,dept,birth_month
Parker,Accounting,November
Smith,IT,October    
'''



#Writing with Pandas
#hrdata.csv
'''
Name,Hire Date,Salary,Leaves Remaining    
John Idle,08/15/14,50000.00,10    
Smith Gilliam,04/07/15,65000.00,8    
Parker Chapman,02/21/14,45000.00,10    
Jones Palin,10/14/13,70000.00,3    
Terry Gilliam,07/22/14,48000.00,7    
Michael Palin,06/28/13,66000.00,8    
'''
import pandas    
df = pandas.read_csv('hrdata.csv',     
            index_col='Employee',     
            parse_dates=['Hired'],    
            header=0,     
            names=['Employee', 'Hired', 'Salary', 'Sick Days'])    
df.to_csv('hrdata_modified.csv')

#hrdata_modified.csv
'''
Employee, Hired, Salary, Sick Days
John Idle, 2014-03-15, 50000.0,10
Smith Gilliam, 2015-06-01, 65000.0,8
Parker Chapman, 2014-05-12, 45000.0,10
Jones Palin, 2013-11-01, 70000.0,3
Terry Gilliam, 2014-08-12 , 48000.0,7
Michael Palin, 2013-05-23, 66000.0,8
'''






##########################################################################################################
#EXCEL_FILE
##########################################################################################################
#An Excel spreadsheet document is called a workbook which is saved in a file with .xlsx extension. 
#The first row of the spreadsheet is mainly reserved for the header, while the first column identifies 
#the sampling unit. Each workbook can contain multiple sheets that are also called a worksheets. 
#A box at a particular column and row is called a cell, and each cell can include a number or text value. 
#The grid of cells with data forms a sheet.

#First, you need to write a command to install the xlrd module.
#>>pip install xlrd
#or
#>>sudo apt install xlrd     


#Reading   
import xlrd     
loc = ("path of file")  # Define the location of the file           
wb = xlrd.open_workbook(loc)     
sheet = wb.sheet_by_index(0)     
        
# For row 0 and column 0     
sheet.cell_value(0, 0)  


#Reading with Pandas
import pandas as pd    
data = pd.read_csv(".csv", low_memory=False)    # Read the file     
print("Total rows: {0}".format(len(data)))    
# See which headers are available    
print(list(data))  

#Reading with openpyxl
import openpyxl    
my_wb = openpyxl.Workbook()    
my_sheet = my_wb.active    
my_sheet_title = my_sheet.title    
print("My sheet title: " + my_sheet_title)  



#Writing with xlwt

#Writing with xlsxwriter
import xlsxwriter     
book = xlsxwriter.Book('Example2.xlsx')     
sheet = book.add_sheet()     
row = 0    # Rows and columns are zero indexed.    
column = 0    
content = ["Parker", "Smith", "John"]        
for item in content :         
    sheet.write(row, column, item)        
    row += 1    
          
book.close()     
#output is an excel file:
'''
    A1
--------------------
1 | Parker
2 | Smith
3 | John

'''




#Writing with openpyxl

#Writing with pyexcel



##########################################################################################################
#PDF_FILE
##########################################################################################################
#https://www.javatpoint.com/pdf-handling-in-python
#https://www.javatpoint.com/working-with-pdf-files-in-python
#https://www.javatpoint.com/best-python-pdf-library
#???



##########################################################################################################
#RAR_FILE
##########################################################################################################
#https://www.javatpoint.com/rarfile-module-in-python
#???


##########################################################################################################
#NETWORK
##########################################################################################################
#Python's standard library consists of various built-in modules that support interprocess communication 
#and networking.

#Python provides two levels of access to the network services. 
#   -At a low level, you can access the basic socket support in the underlying operating system, 
#       -which allows you to implement clients and servers for both connection-oriented and connectionless protocols.
#   -At higher-level access to specific application-level network protocols, 
#       -such as FTP, HTTP, and so on.

Protocol	Common function	Port No	Python module
HTTP	Web pages	80	httplib, urllib, xmlrpclib
NNTP	Usenet news	119	nntplib
FTP	File transfers	20	ftplib, urllib
SMTP	Sending email	25	smtplib
POP3	Fetching email	110	poplib
IMAP4	Fetching email	143	imaplib
Telnet	Command lines	23	telnetlib
Gopher	Document transfers	70	gopherlib, urllib



Socket programming is a technique in which we communicate between two nodes connected in a network where the server node listens to the incoming requests from the client nodes.


In Python, the socket module is used for socket programming. The socket module in the standard library included functionality required for communication between server and client at hardware level.

This module provides access to the BSD socket interface. It is available on all operating systems such as Linux, Windows, MacOS.

Sockets are the endpoints of a bidirectional communications channel. Sockets may communicate within a process, between processes on the same machine, or between processes on different continents.

A socket is identified by the combination of IP address and the port number. It should be properly configured at both ends to begin communication

server port ----------> client port


Python socket Module
The socket module is used for creating and managing socket programming for the connected nodes in a network. The socket module provides a socket class. You need to create a socket using the socket.socket() constructor.

An object of the socket class represents the pair of host name and the port numbers.

# socket.socket (socket_family, socket_type, protocol=0)      #--->  This method returns a socket object

#To create a socket on a server, use the following snippet:
import socket
server = socket.socket()
server.bind(('localhost',12345))
server.listen()
client, addr = server.accept()
print ("connection request from: " + str(addr))


#Client Socket Methods:
#   -connect() method
#       This method takes a two-item tuple object as argument. 
#       The two items are IP address and port number of the server.

obj=socket.socket()
obj.connect((host,port))

#   -send() method
#       The server sends data to client by using the address it has intercepted.

client.send(bytes)
Client socket sends data to socket it has established connection with.


#   -sendall() method
#       similar to send(). However, unlike send(),this method continues to send data from bytes until either all data has been sent or an error occurs. None is returned on success.

#   -sendto() method
#       This method is to be used in case of UDP protocol only.

#   -recv() method
#       This method is used to retrieve data sent to the client. In case of server, it uses the remote socket whose request has been accepted.

client.recv(bytes)

#   -recvfrom() method
#       This method is used in case of UDP protocol.


#------------------
#Example of Server Socket
import socket
host = "127.0.0.1"
port = 5001
server = socket.socket()
server.bind((host,port))        # to specify a port for your service on the given host.
server.listen()
conn, addr = server.accept()    # This method waits until a client connects to the port you specified, 
                                # and then returns a connection object that represents the connection to 
                                # that client.
                                
print ("Connection from: " + str(addr))
while True:
   data = conn.recv(1024).decode()
   if not data:
      break
   data = str(data).upper()
   print (" from client: " + str(data))
   data = input("type message: ")
   conn.send(data.encode())
conn.close()


#------------------
#Example of Client Socket
The following code is a very simple client that connects to a given host and port, reads any available data from the socket, and then exits when 'q' is entered.

import socket
host = '127.0.0.1'
port = 5001
obj = socket.socket()
obj.connect((host,port))
message = input("type message: ")
while message != 'q':
   obj.send(message.encode())
   data = obj.recv(1024).decode()
   print ('Received from server: ' + data)
   message = input("type message: ")
obj.close()


#run hint:
#   Run Server code first. It starts listening.
#   Then start client code. It sends request.
#   Request accepted. Client address identified
#   Type some text and press Enter.
#   Data received is printed. Send data to client.
#   Data from server is received.
#   Loop terminates when 'q' is input.




#------------------
#example-2
#Python File Transfer with Socket Module

#Server Code
#   -The code for establishing connection is same as before. 
#   -After the connection request is accepted, a file on server is opened in binary mode for reading, 
#   -and bytes are successively read and sent to the client stream till end of file is reached.

import socket
host = "127.0.0.1"
port = 5001
server = socket.socket()
server.bind((host, port))
server.listen()
conn, addr = server.accept()
data = conn.recv(1024).decode()
filename='test.txt'
f = open(filename,'rb')
while True:
   l = f.read(1024)
   if not l:
      break
   conn.send(l)
   print('Sent ',repr(l))
f.close()
print('File transferred')
conn.close()



#Client Code
#   -On the client side, a new file is opened in wb mode. 
#   -The stream of data received from server is written to the file. 
#   -As the stream ends, the output file is closed. 
#   -A new file will be created on the client machine.

import socket

s = socket.socket()
host = "127.0.0.1"
port = 5001

s.connect((host, port))
s.send("Hello server!".encode())

with open('recv.txt', 'wb') as f:
   while True:
      print('receiving data...')
      data = s.recv(1024)
      if not data:
         break
      f.write(data)
      
f.close()
print('Successfully received')
s.close()
print('connection closed')





#----------------------------
# Python socketserver Module
#----------------------------
# 1-Server Code
#   -You must write a RequestHandler class. 
#   -It is instantiated once per connection to the server, 
#   -and must override the handle() method to implement communication to the client.

import socketserver
class MyTCPHandler(socketserver.BaseRequestHandler):
   def handle(self):
      self.data = self.request.recv(1024).strip()
      host,port=self.client_address
      print("{}:{} wrote:".format(host,port))
      print(self.data.decode())
      msg=input("enter text .. ")
      self.request.sendall(msg.encode())

if __name__ == "__main__":
   HOST, PORT = "localhost", 9999
   with socketserver.TCPServer((HOST, PORT), MyTCPHandler) as server:
      server.serve_forever()



# 2-Client Code
import socket
import sys

HOST, PORT = "localhost", 9999

while True:
   with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
      # Connect to server and send data
      sock.connect((HOST, PORT))
      data = input("enter text .. .")
      sock.sendall(bytes(data + "\n", "utf-8"))
      
      # Receive data from the server and shut down
      received = str(sock.recv(1024), "utf-8")
      print("Sent: {}".format(data))
      print("Received: {}".format(received))








##########################################################################################################
#REQUESTS_MODULE
##########################################################################################################

#API (Application Programming Interface)
#   facilitates communication between two pieces of software. 
#   It lets you retrieve and send data using code. 
#   We mostly commonly use APIs to retrieve data,

#API Endpoints
#are the public URLs exposed by the server that a client application uses to access resources and data.

#HTTP METHOD	API ENDPOINT	DESCRIPTION
#GET	    /products	            Get a list of products.
#GET	    /products?limit=x	    Get only 5 products.
#GET	    /products/<product_id>	Get a single product.
#POST	    /products	            Create a new product.
#PUT	    /products/<product_id>	Update a product.
#PATCH	    /products/<product_id>	Partially update a product.
#DELETE	    /products/<product_id>	Delete a product.


#HTTP Methods
#There are various HTTP methods for REST APIs. These methods tell the API what operations need to be performed on the data. While there are many HTTP methods, the five methods listed below are the most commonly used with REST APIs:

# GET	        Retrieve existing data
# POST	        Add new data
# PUT	        Update existing data
# PATCH	        Partially update existing data
# DELETE	    Delete data
 
#Status Codes
#Once a REST API receives and processes an HTTP request, it returns a response with a HTTP status code. This status code provides information about the response and helps the client application know what kind of response it is.

# 1xx	Informational response
# 2xx	Successful operation
# 3xx	Redirection
# 4xx	Client error
# 5xx	Server error


#Installization Requests Module
#in windows:
#>>pip install requests
#in linux:
#>>



#Syntax:
#requests.get(url, params={key: value}, args)



from urllib import request
with request.urlopen("http://worldtimeapi.org/api/timezone/etc/UTC.txt") as r :
    for l in r :
        l = l.decode()
        if l.startswith('datetime'):
            print(l.rstrip())



#------------------
#example-1
import requests

BASE_URL = 'https://fakestoreapi.com'
response = requests.get(f"{BASE_URL}/products")

if response:
    print("Success!")
else:
    raise Exception(f"Non-success status code: {response.status_code}")

if response.status_code == 200:
    print("Success!")
elif response.status_code == 404:
    print("Not Found.")
    
print(response.json())

#--->
"""
[
    {
        "id": 1,
        "title": "Fjallraven - Foldsack No. 1 Backpack, Fits 15 Laptops",
        "price": 109.95,
        "description": "Your perfect pack for everyday use and walks in the forest. Stash your laptop (up to 15 inches) in the padded sleeve, your everyday",
        "category": "men's clothing",
        "image": "https://fakestoreapi.com/img/81fPKd-2AYL._AC_SL1500_.jpg",
        "rating": {
            "rate": 3.9,
            "count": 120
        }
    },
    {
        "id": 2,
        "title": "Mens Casual Premium Slim Fit T-Shirts ",
        "price": 22.3,
        "description": "Slim-fitting style, contrast raglan long sleeve, three-button henley placket, light weight & soft fabric for breathable and comfortable wearing. And Solid stitched shirts with round neck made for durability and a great fit for casual fashion wear and diehard baseball fans. The Henley style round neckline includes a three-button placket.",
        "category": "men's clothing",
        "image": "https://fakestoreapi.com/img/71-3HjGNDUL._AC_SY879._SX._UX._SY._UY_.jpg",
        "rating": {
            "rate": 4.1,
            "count": 259
        }
    }
]
"""

#You can also print other attributes related to the response such as the status code.
print(response.status_code)     #---> 200


#------------------
#example-2
#Since the /products endpoint returns a lot of data, let's limit this data to just 3 products.
#To do this, we have an endpoint /products?limit=x where x is a positive integer. 
#The limit is called query parameter. Let's see how we can add this query parameter in the request.

import requests

BASE_URL = 'https://fakestoreapi.com'

query_params = {
    "limit": 3
}

response = requests.get(f"{BASE_URL}/products", params=query_params)
print(response.json())



#------------------
#example-3
import requests

BASE_URL = 'https://fakestoreapi.com'

response = requests.get(f"{BASE_URL}/products/18")
print(response)

#--->
"""
{
    "id": 18,
    "title": "MBJ Women's Solid Short Sleeve Boat Neck V ",
    "price": 9.85,
    "description": "95% RAYON 5% SPANDEX, Made in USA or Imported, Do Not Bleach, Lightweight fabric with great stretch for comfort, Ribbed on sleeves and neckline / Double stitching on bottom hem",
    "category": "women's clothing",
    "image": "https://fakestoreapi.com/img/71z3kpMAYsL._AC_UY879_.jpg",
    "rating": {
        "rate": 4.7,
        "count": 130
    }
}
"""


#------------------
#example-4
import requests

BASE_URL = 'https://fakestoreapi.com'

new_product = {
    "title": 'test product',
    "price": 13.5,
    "description": 'lorem ipsum set',
    "image": 'https://i.pravatar.cc',
    "category": 'electronic'
}


#way-1 (use json())
#we can pass json data using the json argument
response = requests.post(f"{BASE_URL}/products", json=new_product)
print(response.json())
#--->
"""
{
  "_id": "61b45067e087f30012c45a45",
  "id": 21,
  "title": "test product",
  "price": 13.5,
  "description": "lorem ipsum set",
  "image": "https://i.pravatar.cc",
  "category": "electronic"
}
"""

#way-2 (without json())

headers = {
    "Content-Type": "application/json"
}

response = requests.post(f"{BASE_URL}/products", data=json.dumps(new_product), headers=headers)
print(response.json())




#------------------
#example-5
import requests

BASE_URL = 'https://fakestoreapi.com'

updated_product = {
    "title": 'updated_product',
    "category": 'clothing'
}

response = requests.put(f"{BASE_URL}/products/21", json=updated_product)
print(response.json())
#--->
"""
{
  "id": "21",
  "title": "updated_product",
  "category": "clothing"
}
"""

#------------------
#example-6
import requests

BASE_URL = 'https://fakestoreapi.com'

updated_product = {
    "category": 'electronic'
}

response = requests.patch(f"{BASE_URL}/products/21", json=updated_product)
print(response.json())


#------------------
#example-7
import requests

BASE_URL = 'https://fakestoreapi.com'

response = requests.delete(f"{BASE_URL}/products/21")

response.encoding = "utf-8"  # Optional: Requests infers this.
print(response.text)           #---> '{"current_user_url":"https://api.github.com/user", ...}'
print(response.json())
print(type(response.json()))        #--->  <class 'dict'>
print(response.headers)         #---> ???
print(response.headers["Content-Type"])     #---> 'application/json; charset=utf-8'



#Making a GET Request

import requests
req = requests.get('http://www.edureka.co/')
 
req.encoding        # returns 'utf-8'
req.status_code     # returns 200
req.elapsed         # returns datetime.timedelta(0, 1, 666890)
req.url             # returns 'https://edureka.co/'
req.history         # returns [&lt;Response [301]&gt;, &lt;Response [301]&gt;] 
req.headers['Content-Type']     # returns 'text/html; charset=utf-8'



#Downloading An Image Using Requests Module

import requests
req = requests.get('path/to/forest.jpg', stream=True)
req.raise_for_status()
with open('Forest.jpg', 'wb') as fd:
for chunk in req.iter_content(chunk_size=50000):
print('Received a Chunk')
fd.write(chunk)


#Making a POST Request

import requests
req = requests.post('https://en.wikipedia.org/w/index.php', data = {'search':'Nanotechnology'})
req.raise_for_status()
with open('Nanotechnology.html', 'wb') as fd:
for chunk in req.iter_content(chunk_size=50000):
fd.write(chunk)



#Sending Cookies and Headers

import requests
url = 'http://some-domain.com/set/cookies/headers'
headers = {'user-agent': 'your-own-user-agent/0.0.1'}
cookies = {'visit-month': 'February'}
req = requests.get(url, headers=headers, cookies=cookies)


#Cookies can also be passed in a Cookie Jar. They provide a more complete interface to allow you to use those cookies over multiple paths.

import requests
 
jar = requests.cookies.RequestsCookieJar()
jar.set('first_cookie', 'first', domain='httpbin.org', path='/cookies')
jar.set('second_cookie', 'second', domain='httpbin.org', path='/extra')
jar.set('third_cookie', 'third', domain='httpbin.org', path='/cookies')
 
url = 'http://httpbin.org/cookies'
req = requests.get(url, cookies=jar)
 
print(req.text)   #--->  returns '{ "cookies": { "first_cookie": "first", "third_cookie": "third" }}'


#------------------------------------------------
#Session Objects

import requests
 
ssn = requests.Session()
ssn.cookies.update({'visit-month': 'February'})
 
reqOne = ssn.get('http://httpbin.org/cookies')
print(reqOne.text)
# prints information about "visit-month" cookie
 
reqTwo = ssn.get('http://httpbin.org/cookies', cookies={'visit-year': '2017'})
print(reqTwo.text)
# prints information about "visit-month" and "visit-year" cookie
 
reqThree = ssn.get('http://httpbin.org/cookies')
print(reqThree.text)
# prints information about "visit-month" cookie



#------------------
#example-7
import requests
from requests.exceptions import HTTPError

URLS = ["https://api.github.com", "https://api.github.com/invalid"]

for url in URLS:
    try:
        response = requests.get(url)
        response.raise_for_status()
    except HTTPError as http_err:
        print(f"HTTP error occurred: {http_err}")
    except Exception as err:
        print(f"Other error occurred: {err}")
    else:
        print("Success!")



#------------------------------------------------
#Authentication
#Authentication helps a service understand who you are. 
#Typically, you provide your credentials to a server by passing data through the Authorization header or 
#a custom header defined by the service. 
#All the functions of Requests that you’ve seen to this point provide a parameter called auth, 
#which allows you to pass your credentials

#-----------------------
#example-1
import requests
response = requests.get(
    "https://httpbin.org/basic-auth/user/passwd",
    auth=("user", "passwd")
)
print(response.status_code)     #--->  200
print(response.request.headers["Authorization"])    #---> 'Basic dXNlcjpwYXNzd2Q='

#example-2
from requests.auth import HTTPBasicAuth
requests.get(
    "https://httpbin.org/basic-auth/user/passwd",
    auth=HTTPBasicAuth("user", "passwd")
)
<Response [200]>

#example-3
import requests
token = "<YOUR_GITHUB_PA_TOKEN>"
response = requests.get(
    "https://api.github.com/user",
    auth=("", token)
)
print(response.status_code)     #---> 200



#------------------------------------------------
#TimeOut
#By default, Requests will wait indefinitely on the response, so you should almost always specify a timeout duration to prevent these issues from happening. 

print(requests.get("https://api.github.com", timeout=1))    #--->  <Response [200]>
print(requests.get("https://api.github.com", timeout=3.05))     #--->  <Response [200]>

#You can also pass a tuple to timeout with the following two elements:
#   -Connect timeout:   The time it allows for the client to establish a connection to the server
#   -Read timeout:      The time it’ll wait on a response once your client has established a connection

requests.get("https://api.github.com", timeout=(3.05, 5)) # ConnectTime-ReadTime


##########################################################################################################
#URLLIB_MODULE
##########################################################################################################
#Urllib package is the URL handling module for python. It is used to fetch URLs (Uniform Resource Locators).
#It uses the urlopen function and is able to fetch URLs using a variety of different protocols.

#Urllib is a package that collects several modules for working with URLs, such as:
#   - urllib.request for opening and reading.
#   - urllib.parse for parsing URLs
#   - urllib.error for the exceptions raised
#   - urllib.robotparser for parsing robot.txt files

#install in linux:
#>>pip install urllib


#----------------------------
# urllib.request
#----------------------------
import urllib.request 
request_url = urllib.request.urlopen('https://www.geeksforgeeks.org/') 
print(request_url.read()) 
#---> ???


#example-0
from urllib.request import Request, urlopen
obj = Request("https://www.tutorialspoint.com/")
resp = urlopen(obj)
data = resp.read()
print (data)

#example-1
#Sending Data
#   If you define data argument to the Request constructor, a POST request will be sent to the server. 
#   The data should be any object represented in bytes.

from urllib.request import Request, urlopen
from urllib.parse import urlencode

values = {'name': 'Madhu',
   'location': 'India',
   'language': 'Hindi' }
data = urlencode(values).encode('utf-8')
obj = Request("https://example.com", data)



#example-2
#Sending Headers
#   The Request constructor also accepts header argument to push header information into the request. 
#   It should be in a dictionary object.

headers = {'User-Agent': user_agent}
obj = Request("https://example.com", data, headers)


#example-1
#   The following code uses urlopen() function to read the binary data from an image file, 
#   and writes it to local file. You can open the image file on your computer using any image viewer.

from urllib.request import urlopen
obj = urlopen("https://www.tutorialspoint.com/images/logo.png")
data = obj.read()
img = open("img.jpg", "wb")
img.write(data)     
img.close()
#--->  It will produce the image





#----------------------------
# urllib.parse
#----------------------------
from urllib.parse import * parse_url = urlparse('https://www.geeksforgeeks.org / python-langtons-ant/') 
print(parse_url) 
#---> ???
print("\n") 
unparse_url = urlunparse(parse_url) 
print(unparse_url) 
#---> ???

#   urllib.parse.urlparse	    Separates different components of URL
#   urllib.parse.urlunparse	    Join different components of URL
#   urllib.parse.urlsplit	    It is similar to urlparse() but doesn’t split the params
#   urllib.parse.urlunsplit	    Combines the tuple element returned by urlsplit() to form URL
#   urllib.parse.urldeflag	    If URL contains fragment, then it returns a URL removing the fragment.


#example-2
from urllib.parse import urlparse
url = "https://example.com/employees/name/?salary>=25000"
parsed_url = urlparse(url)
print (type(parsed_url))                    #--->  <class 'urllib.parse.ParseResult'>
print ("Scheme:",parsed_url.scheme)         #--->  Scheme: https
print ("netloc:", parsed_url.netloc)        #--->  netloc: example.com
print ("path:", parsed_url.path)            #--->  path: /employees/name/
print ("params:", parsed_url.params)        #--->  params:
print ("Query string:", parsed_url.query)   #--->  Query string: salary>=25000
print ("Frgment:", parsed_url.fragment)     #--->  Frgment:


#example-3
from urllib.parse import urlparse, parse_qs
url = "https://example.com/employees?name=Anand&salary=25000"
parsed_url = urlparse(url)
dct = parse_qs(parsed_url.query)
print ("Query parameters:", dct)    #--->  Query parameters: {'name': ['Anand'], 'salary': ['25000']}


#example-4
from urllib.parse import urlunparse

lst = ['https', 'example.com', '/employees/name/', '', 'salary>=25000', '']
new_url = urlunparse(lst)
print ("URL:", new_url)     #--->  URL: https://example.com/employees/name/?salary>=25000






#----------------------------
# urllib.error
#----------------------------
#This module defines the classes for exception raised by urllib.request. 
#Whenever there is an error in fetching a URL, this module helps in raising exceptions. 
#The following are the exceptions raised :

#URLError :
#           – It is raised for the errors in URLs, or errors while fetching the URL due to connectivity, and has a ‘reason’ property that tells a user the reason of error.
#HTTPError : 
#           – It is raised for the exotic HTTP errors, such as the authentication request errors. It is a subclass or URLError. Typical errors include ‘404’ (page not found), ‘403’ (request forbidden),
#             and ‘401’ (authentication required).


#example-1) URL Error 
import urllib.request 
import urllib.parse 

try:                # trying to read the URL but with no internet connectivity 
	x = urllib.request.urlopen('https://www.google.com') 
	print(x.read()) 

except Exception as e :     # Catching the exception generated	  
	print(str(e)) 



#example-2) HTTP Error 
import urllib.request 
import urllib.parse 

try:                # trying to read the URL 
	x = urllib.request.urlopen('https://www.google.com / search?q = test') 
	print(x.read()) 

except Exception as e :         # Catching the exception generated	 
	print(str(e)) 



#example
from urllib.request import Request, urlopen
import urllib.error as err

obj = Request("http://www.nosuchserver.com")
try:
   urlopen(obj)
except err.URLError as e:
   print(e)     #--->  HTTP Error 403: Forbidden
   
 
#example-2
from urllib.request import Request, urlopen
import urllib.error as err

obj = Request("http://www.python.org/fish.html")
try:
   urlopen(obj)
except err.HTTPError as e:
   print(e.code)    #--->  404
   
   
      

#----------------------------
# urllib.robotparser
#----------------------------
#This module contains a single class, RobotFileParser. 
#This class answers question about whether or not a particular user can fetch a URL that published robot.txt files. 
#Robots.txt is a text file webmasters create to instruct web robots how to crawl pages on their website. 
#The robot.txt file tells the web scraper about what parts of the server should not be accessed.

# importing robot parser class 
import urllib.robotparser as rb 

bot = rb.RobotFileParser() 

x = bot.set_url('https://www.geeksforgeeks.org / robot.txt')        # checks where the website's robot.txt file reside 
print(x) 

y = bot.read() 
print(y) 


z = bot.can_fetch('*', 'https://www.geeksforgeeks.org/')    # we can crawl the main site 
print(z) 

# but can not crawl the disallowed url 
w = bot.can_fetch('*', 'https://www.geeksforgeeks.org / wp-admin/') 
print(w) 





#----------------------------
# urllib.parse
#----------------------------


##########################################################################################################
#JSON
##########################################################################################################
#json is a syntax for storing and exchanging data.
#json is text, written with JavaScript object notation.

#json data types:
# string
# boolean 
# number  
# object  
# null  
# array
 
#example of json in javascript:
var person: {
    
    "name": "jack", 
    "age": 34, 
    "address": {
        "country": "england"
        "city": "liverpool"
    },
    "is_married": false                
    "phone": null
    "children": ["mark", "jane"]
}



#json.dump() vs json.dumps()
#When we want to serialize Python objects into JSON files, we use the json.dump() function. 
#We also utilize the json.dumps() function to transform JSON data into a string for processing and printing.


import json

print(dir(json))  #--->  ['JSONDecodeError', 'JSONDecoder', 'JSONEncoder', '__all__', '__author__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', '__version__', '_default_decoder', '_default_encoder', 'codecs', 'decoder', 'detect_encoding', 'dump', 'dumps', 'encoder', 'load', 'loads', 'scanner']

#1- Parse json - Convert from json to Python :
# some json:
x =  '{ "name":"John", "age":30, "city":"New York"}'
# parse x:
y = json.loads(x)
# the result is a Python dictionary:
print(y["age"]) #--->  ???


#json.load() vs json.loads()
#json files are loaded using the json.load() function, while strings are loaded using the json.loads() function.


#2- Convert from Python to JSON
# a Python object (dict):
x = {
  "name": "John",
  "age" : 30,
  "city": "New York"
}
# convert into JSON:
y = json.dumps(x)
# the result is a JSON string:
print(y)    #--->  ???


#You can convert Python objects of the following types, into JSON strings:
#dict   list    tuple   string   int    float   True    False   None
import json
print(json.dumps({"name": "John", "age": 30}))  #--->  ???
print(json.dumps(["apple", "bananas"]))         #--->  ???
print(json.dumps(("apple", "bananas")))         #--->  ???
print(json.dumps("hello"))                      #--->  ???
print(json.dumps(42))       #--->  ???
print(json.dumps(31.76))    #--->  ???
print(json.dumps(True))     #--->  ???
print(json.dumps(False))    #--->  ???
print(json.dumps(None))     #--->  ???


#When you convert from Python to JSON, Python objects are converted into the JSON (JavaScript) equivalent:
#JSON Encoder Class :
#--------------------------
#   Python	    JSON
#--------------------------
#   dict	    Object
#   list	    Array
#   tuple	    Array
#   str	        String
#   int	        Number
#   float	    Number
#   Enums	    Number
#   True	    true
#   False	    false
#   None	    null

#methods of json package in python:
# dump          pyfile to json
# dumps         string to json
# load          json to pyfile
# loads         json to string

#Format the Result
#Pretty Print for json
#example
import json
x = {
    "name": "John",
    "age": 30,
    "married": True,
    "divorced": False,
    "children": ("Ann","Billy"),
    "pets": None,
    "cars": [
        {"model": "BMW 230", "mpg": 27.5},
        {"model": "Ford Edge", "mpg": 24.1}
    ]
}

print(json.dumps(x))    
'''
{"name": "John", "age": 30, "married": true, "divorced": false, "children": ["Ann", "Billy"], "pets": null, "cars": [{"model": "BMW 230", "mpg": 27.5}, {"model": "Ford Edge", "mpg": 24.1}]}
'''
print(json.dumps(x, indent=4))
'''
{
    "name": "John",
    "age": 30,
    "married": true,
    "divorced": false,
    "children": [
        "Ann",
        "Billy"
    ],
    "pets": null,
    "cars": [
        {
            "model": "BMW 230",
            "mpg": 27.5
        },
        {
            "model": "Ford Edge",
            "mpg": 24.1
        }
    ]
}
'''

print(json.dumps(x, indent=4, sort_keys=True))
'''
{
    "age": 30,
    "cars": [
        {
            "model": "BMW 230",
            "mpg": 27.5
        },
        {
            "model": "Ford Edge",
            "mpg": 24.1
        }
    ],
    "children": [
        "Ann",
        "Billy"
    ],
    "divorced": false,
    "married": true,
    "name": "John",
    "pets": null
}
'''

#You can also define the separators, default value is (", ", ": "), which means using a comma and a space to
#separate each object, and a colon and a space to separate keys from values:
print(json.dumps(x, indent=4, separators=(". ", " = ")))
'''
{
    "name" = "John".
    "age" = 30.
    "married" = true.
    "divorced" = false.
    "children" = [
        "Ann".
        "Billy"
    ].
    "pets" = null.
    "cars" = [
        {
            "model" = "BMW 230".
            "mpg" = 27.5
        }.
        {
            "model" = "Ford Edge".
            "mpg" = 24.1
        }
    ]
}
'''











#----------------------------
#example-1 (file)
my_list = [1, 3.14, "Ali"]

#sender side
# write data in json file (to send otherwhere) (to sended file)
with open("test.json", "w+", encoding="utf-8") as f:
    json.dump(my_list, f)   # f is json file
    
#receiver side    
# read data from json file (from received file) 
with open("test.json", "", encoding="utf-8") as f:
    retrived_data = json.load(f)


#----------------------------
#example-2 (string)
data = ['Ali', {'marks':(50,60,70)}, 'age':None ]

# write data in json string
s = json.dumps(data)    # s is a json string
#or
json.dumps(data, s)
print (s)           #--->  ["Ali", {"marks": [50, 60, 70]}, "age":null]     # json data (string)
print (type(s))     #--->  <class 'str'>

# read data from json string
data = json.loads(s)
print (data)        #--->  ['Ali', {'marks': [50, 60, 70]}, "age":None]     # python data (string)
print (type(data))  #--->  <class 'list'>


#----------------------------
#example-3 (forloop)
#in my.json:
[
    {"name": "Mehrdad" , "age": 34,"phone": 09148880254},
    {"name": "David" , "age": 21,"phone": 09148800000},
    {"name": "Steven" , "age": 30,"phone": 09148899977}
]
 
#we just want name and phone: 
with open("test.json", "", encoding="utf-8") as f:
    data = json.load(f)

for item in data:
    del item['age']

print(data)     #---> [{"name": "Mehrdad" , "phone": 09148880254}, {"name": "David" , "phone": 09148800000},{"name": "Steven" , "phone": 09148899977}] 


#----------------------------
#example-4 (indent)
#we want to create a new json file from Previous example
with open("test2.json", "w+", encoding="utf-8") as f:
    json.dump(data, f)  

#in test2.json:
[{"name": "Mehrdad" , "phone": 09148880254}, {"name": "David" , "phone": 09148800000},{"name": "Steven" , "phone": 09148899977}] 

with open("test3.json", "w+", encoding="utf-8") as f:
    json.dump(data, f, indent=2)      

#in test3.json:
[
    {
        "name": "Mehrdad" ,
        "phone": 09148880254
    }, 
    {
        "name": "David" ,
        "phone": 09148800000
    },
    {
        "name": "Steven" ,
        "phone": 09148899977
    }
] 
    
    
#----------------------------
#3- dump function
# 1-sort_keys
# The dumps() function can take optional sort_keys argument. By default it is False. If set to True, the dictionary keys appear in sorted order in the JSON string.
s = json.dumps (data, sort_keys=True)
# 2-indent
# It decides length of each segment of formatted representation of json string, similar to pprint output.
s = json.dumps (data, indent = 2) #???



#----------------------------
#example-5 
#get an api from web and save it to a local file
from urllib.request import urlopen
import json

url = 'https://api.exchangeratesapi.io/latest?base=USD'

with urlopen(url) as u:
    jdata = u.read()

pdata = json.loads(jdata)

with open('currency.json', 'w') as c:
    json.dump(pdata, c, indent=2)
     





print(json.dumps(None))   #--->  null

data = ['Ali', {'marks':(50,60,70)}]
e = json.JSONEncoder()
print (e)       #--->  ???
for obj in e.iterencode(data):
    print (obj)     #--->  ["Ali"
                    #      , 
                    #      {
                    #      "marks"
                    #      : 
                    #      [50
                    #      , 60
                    #      , 70
                    #      ]
                    #      }
                    #      ]






# encode
data = ['Ali', {'marks':(50,60,70)}]
e = json.JSONEncoder()
s = e.encode(data)
print (s)    #--->  

# decode
d = json.JSONDecoder()
obj = d.decode(s)
print (obj)         #--->  ['Ali', {'marks': [50, 60, 70]}] 
print (type(obj))   #--->  <class 'list'>



#-------------------------------------------
# DEM JSON
import demjson 

a = [{"Name": 'Peter',"Age":20, "Subject":"Electronics"}]  
d = demjson.encode(a)
print(d)  #--->  [{"Age":20,"Name":"Peter","Subject":"Electronics"}]

print(demjson.decode(d))  #---> ???




##########################################################################################################
#XML
##########################################################################################################
#The Extensible Markup Language (XML) is a markup language much like HTML or SGML. This is recommended by the World Wide Web Consortium and available as an open standard.
#XML is a portable, open-source language that allows programmers to develop applications that can be read by other applications, regardless of operating system and/or developmental language.
#XML Parser Architectures and APIs.

#a simple XML file movies.xml as an input:
'''
<collection shelf="New Arrivals">
<movie title="Enemy Behind">
   <type>War, Thriller</type>
   <format>DVD</format>
   <year>2003</year>
   <rating>PG</rating>
   <stars>10</stars>
   <description>Talk about a US-Japan war</description>
</movie>
<movie title="Transformers">
   <type>Anime, Science Fiction</type>
   <format>DVD</format>
   <year>1989</year>
   <rating>R</rating>
   <stars>8</stars>
   <description>A schientific fiction</description>
</movie>
   <movie title="Trigun">
   <type>Anime, Action</type>
   <format>DVD</format>
   <episodes>4</episodes>
   <rating>PG</rating>
   <stars>10</stars>
   <description>Vash the Stampede!</description>
</movie>
   <movie title="Ishtar">
   <type>Comedy</type>
   <format>VHS</format>
   <rating>PG</rating>
   <stars>2</stars>
   <description>Viewable boredom</description>
</movie>
</collection>
'''

##########################################################################################################
#YAML
##########################################################################################################
#YAML = YAML Aint Markup Language for data saving (like json) in shape of key-value
#https://yaml.org/
#focused on readability and simplity

#yaml file can have two type of extension (both of them are the same):
#   .yaml
#   .yml



#test.yaml
'''

#comment
# a single line comment

# this
# is a multiple
# line comment



#string:
name: "ali"
fulname: >"ali
           hosseini"

           
#number
birthday = 1998           
age: 12.25
age: !!int 12   #number as int
age: !!str 12   #number as str "12"


#boolean:
is_maried = False   #or {No, Off, n} - {True, Yes, On, y}


#list
phone:            
 - 09147584201
 - 09875468722
 - 09378798752
 - 09390688852
#or
phone: [09147584201, 09875468722, 09378798752, 09390688852]
 

#dictionary
email:              
 personal: "qwee@yahoo.com"
 work: "opputwad@yandex.com" 
#or
email: {personal: "qwee@yahoo.com", work: "opputwad@yandex.com" }   must have space after ":"


#null
sigaret: Null  #or ~


#if you want to save a pack of data for special document: (different documents with different data) 
Person1:                    document 1
 name: "ali"
 fulname: >"ali
           hosseini"
 age: 12
 is_maried = False   #or No, Off - True, Yes, On
 phone: [09147584201, 09875468722, 09378798752, 09390688852]
 email: {personal: "qwee@yahoo.com", work: "opputwad@yandex.com" }
 sigaret: Null

Person2:                    document 2
 ... 


#repetetive things (yaml vs json)
#in yaml:
defaults: &defaults
   adapter:  postgres
   host:     localhost
development:
   database: myapp_development
   <<: *defaults                    # to add repetetive parts
test:
   database: myapp_test
   <<: *defaults                    # to add repetetive parts

#in json:
{
   "defaults": {
      "adapter": "postgres",
      "host": "localhost"
   },
   "development": {
      "database": "myapp_development",
      "adapter": "postgres",
      "host": "localhost"
   },
   "test": {
      "database": "myapp_test",
      "adapter": "postgres",
      "host": "localhost"
   }
}






'''







##########################################################################################################
#EMAIL
##########################################################################################################
#Simple Mail Transfer Protocol (SMTP) is used as a protocol to handle the email transfer using Python.
'''
It is used to route emails between email servers. It is an application layer protocol which allows to users
to send mail to another. The receiver retrieves email using the protocols POP(Post Office Protocol) and 
IMAP(Internet Message Access Protocol).

PC1 ----(SMTP)----> SERVER-X ----(SMTP)----> SERVER-Y ----(POP3 or IMAP)----> PC2
    
When the server listens for the TCP connection from a client, it initiates a connection on port 587.
'''
#!/usr/bin/python3    
import smtplib    
sender_mail    =  'sender@fromdomain.com'    
receivers_mail = ['reciever@todomain.com']    
message = """From: From Person %s  
To: To Person %s  
Subject: Sending SMTP e-mail   
This is a test e-mail message.  
"""%(sender_mail,receivers_mail)    
try:    
   smtpObj = smtplib.SMTP('localhost')    #smtpObj = smtplib.SMTP(host, port, local_hostname)  
   smtpObj.sendmail(sender_mail, receivers_mail, message)    
   print("Successfully sent email")    
except Exception:    
   print("Error: unable to send email")  



#Here, we need to login to the Gmail account using Gmail user name and password. For this purpose, 
#the smtplib provide the login() method, which accepts the username and password of the sender.


#!/usr/bin/python3    
import smtplib    
sender_mail = 'sender@gmail.com'    
receivers_mail = ['reciever@gmail.com']    
message = """From: From Person %s  
To: To Person %s  
Subject: Sending SMTP e-mail   
This is a test e-mail message.  
"""%(sender_mail,receivers_mail)    
try:    
   password = input('Enter the password');    
   smtpObj = smtplib.SMTP('gmail.com',587)    
   smtpobj.login(sender_mail,password)    
   smtpObj.sendmail(sender_mail, receivers_mail, message)    
   print("Successfully sent email")    
except Exception:    
   print("Error: unable to send email") 



#Sending HTML in email
#We can format the HTML in the message by specifying the MIME version, content-type, and character set to send the HTML.
#!/usr/bin/python3    
import smtplib    
sender_mail = 'sender@fromdomain.com'    
receivers_mail = ['reciever@todomain.com']    
message = """From: From Person %s  
To: To Person %s  
  
MIME-Version:1.0  
Content-type:text/html  
  
  
Subject: Sending SMTP e-mail   
  
<h3>Python SMTP</h3>  
<strong>This is a test e-mail message.</strong>  
"""%(sender_mail,receivers_mail)    
try:    
   smtpObj = smtplib.SMTP('localhost')    
   smtpObj.sendmail(sender_mail, receivers_mail, message)    
   print("Successfully sent email")    
except Exception:    
   print("Error: unable to send email")    

##########################################################################################################
#GMAIL_API
##########################################################################################################
#https://www.javatpoint.com/gmail-api-in-python
#???



##########################################################################################################
#WIKIPEDIA_MODULE
##########################################################################################################
#https://www.javatpoint.com/wikipedia-module-in-python
#???



##########################################################################################################
#CACHETOOLS_MODULE
##########################################################################################################
#https://www.javatpoint.com/python-cachetools-module
#???


##########################################################################################################
#HASHLIB
##########################################################################################################
#This module implements a common interface to many different secure hash and message digest algorithms:
#FIPS secure hash algorithms (SHA)
#    SHA1, SHA224, SHA256, SHA384, and SHA512 (defined in FIPS 180-2) 
#RSA's algorithm (defined in Internet RFC 1321) (MD5)

import hashlib
print(hashlib.algorithms_available) #algorithms which are exist in whole of python 
#--->  {'md5', 'sha256', 'sm3', 'blake2s', 'sha3_224', 'sha384', 'sha224', 'sha512_256', 'shake_256', 'sha3_512', 'sha512_224', 'sha1', 'sha512', 'blake2b', 'md5-sha1', 'shake_128', 'sha3_256', 'sha3_384'}
print(hashlib.algorithms_guaranteed) #algorithms which are exist in hashlib module
#--->  {'md5', 'blake2b', 'sha256', 'sha3_256', 'shake_256', 'sha224', 'blake2s', 'sha3_224', 'sha384', 'sha3_512', 'shake_128', 'sha1', 'sha512', 'sha3_384'}


import hashlib
name = "this is amir".encode()
h = hashlib.sha256()
h.update(name)
print(h.digest()) #--->  b'# \xb6aW\x15!U\x02z{h\xa8\x1f\x01\xf5\xafcyw\xed\x82o\xd0e\xe4[AL\xea\xf9#'
#or
h = hashlib.sha256()
h.update(b"this is amir")
print(h.digest()) #--->  b'# \xb6aW\x15!U\x02z{h\xa8\x1f\x01\xf5\xafcyw\xed\x82o\xd0e\xe4[AL\xea\xf9#'
#its 'b' and is not good to save in file

print(h.hexdigest()) #--->  2320b66157152155027a7b68a81f01f5af637977ed826fd065e45b414ceaf923    

#we can use them together
hashlib.sha256(b"Nobody inspects the spammish repetition").hexdigest()

print(hash.digest_size)
r = hash.copy(h)
print(r.hexdigest())



#example
data = 'Hello'
hash_value = hash(data)
print(hash_value)   #---> 1234567890


#__hash__ :
class MyClass:
    def __init__(self, value):
        self.value = value

    def __hash__(self):
        return hash(self.value)

my_object = MyClass(5)
hash_value = my_object.__hash__()       # Getting the hash value using the __hash__ method
print(hash_value)   #--->  5


#example
my_list = [1, 2, 3]
my_tuple = tuple(my_list)   # Converting the list to a tuple
hash_value = hash(my_tuple)
print(hash_value)   #--->  2528502973977326415


#example
import hashlib

# encode using UTF-8 encoding
message = "Some text to hash".encode()
print(message)
message2 = message.decode('utf-8')
print(message2)


#example
# Importing the hashlib library
import hashlib

# Defining a string
data = 'Hello, world!'
hash_value = hashlib.md5(data.encode()).hexdigest()
print(hash_value)  #--->  '6cd3556deb0da54bca060b4c39479839'


#example
string1 = 'Hello, world!'
string2 = 'Hello, world!'
hash_value1 = hash(string1)
hash_value2 = hash(string2)
print(hash_value1) #--->  1234567890
print(hash_value2) #--->  1234567890


#example
# initializing objects
int_val = 4
str_val = 'GeeksforGeeks'
flt_val = 24.56
print("The integer hash value is : " + str(hash(int_val)))  #--->  4
print("The string hash value is :  " + str(hash(str_val)))  #--->  4349415460800802357
print("The float hash value is :   " + str(hash(flt_val)))  #--->  1291272085159665688



#example
import hashlib

nonce = 0
key = 'f3q4uszyt67cfatq'
pad = hashlib.sha256(str(nonce)+key).digest()

# encrypt
plaintext = 'the quick brown fox jumped over.'
ciphertext = ''
for i in range(32):
  ciphertext += chr(ord(pad[i])^ord(plaintext[i]))
  
# ciphertext = '\x1bf\x13\r\x0c\xc4\x18`\x129\x16\x12|\x96\xa7\xc2\xf5E_\x97\xc2\x010\x88]j\xce\xe3x\x14\xe8\xb6'

# decrypt
plaintext = ''
for i in range(32):
  plaintext += chr(ord(pad[i]^ord(ciphertext[i]))

# plaintext = 'the quick brown fox jumped over.'





#------------------------------------------------
#BLAKE2
#is a cryptographic hash function defined in RFC 7693 that comes in two flavors:
#   BLAKE2b     optimized for 64-bit platforms and produces digests of any size between 1 and 64 bytes,
#   BLAKE2s     optimized for 8- to 32-bit platforms and produces digests of any size between 1 and 32 bytes.

#BLAKE2 supports keyed mode (a faster and simpler replacement for HMAC), salted hashing, personalization, and tree hashing.





##########################################################################################################
#CURL
##########################################################################################################
#curl command is a tool to download or transfer files/data from or to a server using FTP, HTTP, HTTPS, SCP, SFTP, SMB 
#and other supported protocols on Linux or Unix-like system.

#Installing cURL for Ubuntu Linux:
#>>sudo apt update && sudo apt upgrade
#>>sudo apt install curl
#>>curl --version                                  Verify install of curl
#>>apt-cache search libcurl | grep python          Search for libcurl bindings for your programming needs: 
#>>sudo apt install python3-pycurl                 Install the Python bindings to libcurl: 
#>>apt-cache search libcurl                        Search for other curl bindings to libcurl: 


to see the headers:
curl -I https://www.google.com/
curl -I https://www.cyberciti.biz/

Or download a file from a server using curl itself:
curl -o output.file http://server1.cyberciti.biz/bar.foo.txt

You can resume broken download with the curl command as follows:
curl -L -O -C - http://ftp.ussg.iu.edu/linux/centos/latest/isos/file.iso

, upload a ‘.doc’ file (HTTP POST request) using the curl command:
curl -F 'file_name=@/home/vivek/Documents/sales.doc https://server1.cyberciti.biz/mycloud/

#The list of all the available options is given below:

#Option	            Description
#----------------------------------
"""
--abstract-unix-socket <path>	Connect through abstract Unix socket instead through a network.
Example:
curl --abstract-unix-socket socketpath https://example.com

--alt-svc <file name>	Enable alt-svc parser.
Example:
curl --alt-svc svc.txt https://example.com

--anyauth	Curl finds and uses the most secure authentication method for the given HTTP URL.
Example:
curl --anyauth --user me:pass https://example.com

-a, --append	Append to the target file.
Example:
curl --upload-file local --append ftp://example.com/
--aws-sigv4 <provider1[:provider2[:region[:service]]]>	Use AWS V4 signature authentication.

Example:
curl --aws-sigv4 "aws:amz:east-2:es" --user "key:secret" https://example.com
--basic	Use HTTP basic authentication. 

Example:
curl -u name:password --basic https://example.com
--cacert <file>	Use the specified file for certificate verification.

Example:
curl --cacert CA-file.txt https://example.com
--capath <dir>	Use the specified directory to look for the certificates.

Example:
curl --capath /local/directory https://example.com
--cert-status	Verify the server certificate status.

Example:
curl --cert-status https://example.com
--cert-type <type>	Specify the type of the provided certificate. The recognized types are PEM (default), DER, ENG and P12.

Example:
curl --cert-type ENG --cert file https://example.com
-E, --cert <certificate[:password]>	Use the provided certificate file when working with a SSL-based protocol.

Example:
curl --cert certfile --key keyfile https://example.com
--ciphers <list of ciphers>	Provide ciphers to be used in the connection.

Example:
curl --ciphers ECDHE-ECDSA-AES256-CCM8 https://example.com
--compressed-ssh	Enable built-in SSH compression. 

Example:
curl --compressed-ssh sftp://example.com/
--compressed	Request to receive a compressed response. 

Example:
curl --compressed https://example.com 
-K, --config <file>	Provide a text file with curl arguments, instead of writing them on the command line. 

Example:
curl --config file.txt https://example.com
--connect-timeout <fractional seconds>	Specify maximum time a curl connection may last.

Example:
curl --connect-timeout 30 https://example.com
--connect-to <HOST1:PORT1:HOST2:PORT2>	Provide a connection rule to direct requests at a specific server cluster node. 

Example:
curl --connect-to example.com:443:example.net:8443 https://example.com
-C, --continue-at <offset>	Resume file transfer at the offset specified.

curl -C 400 https://example.com
-c, --cookie-jar <filename>	Specify a file for storing cookies.

curl -c store.txt https://example.com
-b, --cookie <data|filename>	Read cookies from a file. 

Example:
curl -b cookiefile https://example.com
--create-dirs	Create the local directories for the --output option. 

Example:
curl --create-dirs --output local/dir/file https://example.com
--create-file-mode <mode>	Specify which mode to set upon file creation. 

Example:
curl --create-file-mode 0777 -T localfile sftp://example.com/new
--crlf	Convert LF to CRLF. 

curl --crlf -T file ftp://example.com/
--crlfile <file>	Provide a Certificate Revocation List for peer certificates. 

curl --crlfile revoke.txt https://example.com
--curves <algorithm list>	Provide curves for establishing an SSL session.

Example:
curl --curves X25519 https://example.com
--data-ascii <data>	See -d, --data. 

Example:
curl --data-ascii @file https://example.com
--data-binary <data>	Post data as specified, without extra processing. 

curl --data-binary @filename https://example.com
--data-raw <data>	Same as -d, --data, but the @ character is not treated differently from the rest. 

curl --data-raw "@at@at@" https://example.com
--data-urlencode <data>	Same as -d, --data, but perform URL encoding.

Example:
curl --data-urlencode name=val https://example.com
-d, --data <data>	Send data to a HTTP server in a POST request.  

Example:
curl -d "name=curl" https://example.com
--delegation <LEVEL>	Specify when the server is allowed to delegate credentials. 

Example:
curl --delegation "always" https://example.com
--digest	Enable HTTP Digest authentication. 

Example:
curl -u name:password --digest https://example.com
--disable-eprt	Disable EPRT and LPRT commands for active FTP transfers. 

Example:
curl --disable-eprt ftp://example.com/
--disable-epsv	Disable EPSV for passive FTP transfers.

Example:
curl --disable-epsv ftp://example.com/
-q, --disable	Disable the reading of the curlrc config file.

curl -q https://example.com 
--disallow-username-in-url	Exit if provided with a URL that contains a username. 

Example:
curl --disallow-username-in-url https://example.com
--dns-interface <interface>	Specify an interface for outgoing DNS requests. 

Example:
curl --dns-interface eth0 https://example.com
--dns-ipv4-addr <address>	Specify an IPv4 address from which the DNS requests will come. 

Example:
curl --dns-ipv4-addr 10.1.2.3 https://example.com
--dns-ipv6-addr <address>	Specify an IPv6 address from which the DNS requests will come. 

Example:
curl --dns-ipv6-addr 2a04:4e42::561 https://example.com
--dns-servers <addresses>	Specify your own list of DNS servers. 

Example:
curl --dns-servers 192.168.0.1,192.168.0.2 https://example.com
--doh-cert-status	--cert-status for DNS-over-HTTPS. 

Example:
curl --doh-cert-status --doh-url https://doh.server https://example.com 
--doh-insecure	-k, --insecure for DoH.

Example:
curl --doh-insecure --doh-url https://doh.server https://example.com
--doh-url <URL>	Specify a DoH server for hostname resolution. 

Example:
curl --doh-url https://doh.server https://example.com 
-D, --dump-header <filename>	Specify a file for writing protocol headers. 

Example:
curl --dump-header store.txt https://example.com 
--egd-file <file>	Provide a path for the EGD socket. 

Example:
curl --egd-file /path/here https://example.com 
--engine <name>	Specify an OpenSSL crypto engine.

Example:
curl --engine flavor https://example.com  
--etag-compare <file>	Request an ETag read from a file.

Example:
curl --etag-compare etag.txt https://example.com  
--etag-save <file>	Save a HTTP ETag to a file. 

Example:
curl --etag-save etag.txt https://example.com 
--expect100-timeout <seconds>	Maximum wait time for a 100-continue response. 

Example:
curl --expect100-timeout 2.5 -T file https://example.com 
--fail-early	Tell curl to fail and exit when it detects the first error in transfer. 

Example:
curl --fail-early https://example.com https://two.example 
--fail-with-body	If the server returns an error with code 400 or greater, curl saves the content and returns error 22.  

Example:
curl --fail-with-body https://example.com 
-f, --fail	If the server returns an error, curl fails silently and returns error 22. 

Example:
curl --fail https://example.com 
--false-start	Use false start on TLS handshake. 

Example:
curl --false-start https://example.com 
--form-string <name=string>	Similar to -F, --form, but the value strings are processed literally. 

Example:
curl --form-string "data" https://example.com 
-F, --form <name=content>	Emulate a form with a Submit button that has been pressed. The @ sign forces the content to be a file. The < sign extracts only the content part of the file.  

Example:
curl --form "name=curl" --form "file=@loadthis" https://example.com
--ftp-account <data>	Specify the account data for the FTP server. 

Example:
curl --ftp-account "account_data" ftp://example.com/
--ftp-alternative-to-user <command>	Specify the command to be sent if the username and password authentication fails. 

Example:
curl --ftp-alternative-to-user "U53r" ftp://example.com 
--ftp-create-dirs	If the specified directory does not exist, curl will attempt to create it.

Example:
curl --ftp-create-dirs -T file ftp://example.com/dirs/one/file 
--ftp-method <method>	Specify a method to be used for obtaining files over FTP. Available methods are multicwd, nocwd, and singlecwd.  

Example:
curl --ftp-method multicwd ftp://example.com/dir1/dir2/file 
--ftp-pasv	Use passive data connection mode. 

Example:
curl --ftp-pasv ftp://example.com/ 
-P, --ftp-port <address>	Reverse the default roles for the FTP connection. 

Example:
curl -P eth0 ftp:/example.com 
--ftp-pret	Send the PRET command before PASV/EPSV.

Example:
curl --ftp-pret ftp://example.com/ 
--ftp-skip-pasv-ip	Do not use the IP address suggested by the server. curl will use the control connection IP. 

Example:
curl --ftp-skip-pasv-ip ftp://example.com/ 
--ftp-ssl-ccc-mode <active/passive>	Set the Clear Command Channel (CCC) mode.

Example:
curl --ftp-ssl-ccc-mode active --ftp-ssl-ccc ftps://example.com/ 
--ftp-ssl-ccc	After the authentication is complete, the SSL/TLS layer is eliminated, allowing for unencrypted communication. 

Example:
curl --ftp-ssl-ccc ftps://example.com/ 
--ftp-ssl-control	Use SSL/TLS for logging in, stop the encryption when the data transfer starts.

Example:
curl --ftp-ssl-control ftp://example.com 
-G, --get	Use HTTP GET request instead of POST. 

Example:
curl --get -d "tool=curl" -d "age=old" https://example.com
-g, --globoff	Disable the URL globbing parser.

Example:
curl -g "https://example.com/{[]}}}}"  
--happy-eyeballs-timeout-ms <milliseconds>	Use the Happy Eyeballs algorithm for connecting to dual-stack hosts. 

Example:
curl --happy-eyeballs-timeout-ms 500 https://example.com 
--haproxy-protocol	Use HAProxy PROXY protocol v1 header. 

Example:
curl --haproxy-protocol https://example.com 
-I, --head	Obtain only headers.

Example:
curl -I https://example.com 
-H, --header <header/@file>	Specify an additional header to be sent in the HTTP request. 

Example:
curl -H "X-First-Name: Joe" https://example.com 
-h, --help <category>	See help for a specific category. all lists all the available options. 

Example:
curl --help all 
--hostpubmd5 <md5>	Pass a 32-digit hexadecimal string. 

Example:
curl --hostpubmd5 e5c1c49020640a5ab0f2034854c321a8 sftp://example.com/ 
--hsts <file name>	Enable HSTS. 

Example:
curl --hsts cache.txt https://example.com 
--http0.9	Accept a HTTP version 0.9 response. 

Example:
curl --http0.9 https://example.com
-0, --http1.0	Use HTTP version 1.0. 

Example:
curl --http1.0 https://example.com
--http1.1	Use HTTP version 1.1.   

Example:
curl --http1.1 https://example.com 
--http2-prior-knowledge	Use HTTP version 2.0. Use this option if you know that the server supports this HTTP version. 

Example:
curl --http2-prior-knowledge https://example.com
--http2	Attempt to use HTTP version 2.0. 

Example:
curl --http2 https://example.com
--http3	Use HTTP version 3.0. This is an experimental option.   

Example:
curl --http3 https://example.com
--ignore-content-length	Ignore the Content-Length header.

Example:
curl --ignore-content-length https://example.com 
-i, --include	Specify that the output should include the HTTP response headers. 

Example:
curl -i https://example.com
-k, --insecure	Allow curl to work with insecure connections. 

Example:
curl --insecure https://example.com 
--interface <name>	Specify the interface for performing an action. 

Example:
curl --interface eth0 https://example.com 
-4, --ipv4	Only resolve names to IPv4 addresses. 

Example:
curl --ipv4 https://example.com 
-6, --ipv6	Only resolve names to IPv6 addresses.

Example:
curl --ipv6 https://example.com
-j, --junk-session-cookies	Discard session cookies. 

Example:
curl --junk-session-cookies -b cookies.txt https://example.com 
--keepalive-time <seconds>	Specify the idle time for the connection before it sends keepalive probes. 

Example:
curl --keepalive-time 30 https://example.com 
--key-type <type>	Specify the type of the private key. Available types are PEM (default), DER, and ENG. 

Example:
curl --key-type ENG --key here https://example.com 
--key <key>	Specify the file containing the private key. 

Example:
curl --cert certificate --key here https://example.com 
--krb <level>	Enable and use Kerberos authentication. Available levels are clear, safe, confidential, and private (default). 

Example:
curl --krb clear ftp://example.com/ 
--libcurl <file>	Obtain C source code for the specified command line operation. 

Example:
curl --libcurl client.c https://example.com 
--limit-rate <speed>	Specify the maximum upload and download transfer rate. 

Example:
curl --limit-rate 100K https://example.com 
-l, --list-only	Force a name-only view. 

Example:
curl --list-only ftp://example.com/dir/ 
--local-port <num/range>	Specify the port numbers to be used for the connection. 

Example:
curl --local-port 1000-3000 https://example.com 
--location-trusted	Similar to -L, --location, but enables you to send name and password to all redirections.

Example:
curl --location-trusted -u user:pass https://example.com
-L, --location	Allow curl to follow any redirections. 

Example:
curl -L https://example.com 
--login-options <options>	Specify the login options for email server authentication. 

Example:
curl --login-options 'AUTH=*' imap://example.com 
--mail-auth <address>	Provide a single address as the identity. 

Example:
curl --mail-auth user@example.come -T mail smtp://example.com/ 
--mail-from <address>	Provide a single "from" address.

Example:
curl --mail-from user@example.com -T mail smtp://example.com/ 
--mail-rcpt-allowfails	Allows curl to continue with SMTP conversation if one of the recipients fails. 

Example:
curl --mail-rcpt-allowfails --mail-rcpt dest@example.com smtp://example.com 
--mail-rcpt <address>	Provide a single "to" address.  

Example:
curl --mail-rcpt user@example.net smtp://example.com 
-M, --manual	Read the curl manual. 

Example:
curl --manual 
--max-filesize <bytes>	Provide the maximum size of the file to be downloaded.  
Example:
curl --max-filesize 500K https://example.com 
--max-redirs <num>	Specify the maximum number of redirections when --location is active. 

Example:
curl --max-redirs 3 --location https://example.com 
-m, --max-time <fractional seconds>	Specify the maximum time for an operation. 

Example:
curl --max-time 5.52 https://example.com 
--metalink	Specify a metalink resource. This option is disabled in the newest versions of curl. 

Example:
curl --metalink file https://example.com 
--negotiate	Enable SPNEGO authentication. 

Example:
curl --negotiate -u : https://example.com
--netrc-file <filename>	Like --n, --netrc, but allows you to specify the file to be used. 

Example:
curl --netrc-file netrc https://example.com 
--netrc-optional	Like --n, --netrc, but using netrc is optional. 

Example:
curl --netrc-optional https://example.com 
-n, --netrc	Search the netrc file for login information.

Example:
curl --netrc https://example.com 
-:, --next	Use the option to separate URL requests. 

Example:
curl -I https://example.com --next https://example.net/ 
--no-alpn	Disable ALPN TLS extension. 

Example:
curl --no-alpn https://example.com 
-N, --no-buffer	Disable output stream buffer. 

Example:
curl --no-buffer https://example.com 
--no-keepalive	Disable keepalive messages. 

Example:
curl --no-keepalive https://example.com 
--no-npn	Disable NPN TLS extension. 

Example:
curl --no-npn https://example.com 
--no-progress-meter	Disable the progress bar but display any other message. 

Example:
curl --no-progress-meter -o store https://example.com 
--no-sessionid	Disable the caching of SSL session-ID. 

Example:
curl --no-sessionid https://example.com 
--noproxy <no-proxy-list>	List the hosts which should not use a proxy. 

Example:
curl --noproxy "www.example" https://example.com 
--ntlm-wb	Like --ntlm, but also hands authentication to ntlmauth.

Example:
curl --ntlm-wb -u user:password https://example.com  
--ntlm	Enable NTLM authentication. 

Example:
curl --ntlm -u user:password https://example.com 
--oauth2-bearer <token>	Provide a Bearer Token for OAUTH 2.0. 

Example:
curl --oauth2-bearer "mF_9.B5f-4.1JqM" https://example.com 
--output-dir <dir>	Specify the output file directory.

Example:
curl --output-dir "tmp" -O https://example.com 
-o, --output <file>	Store output in a file. The output is not shown in stdout. 

Example:
curl -o file https://example.com -o file2 https://example.net 
--parallel-immediate	Prefer parallel connections to waiting for new connections or multiplexed streams. 

Example:
curl --parallel-immediate -Z https://example.com -o file1 https://example.com -o file2
--parallel-max <num>	Specify the maximum number of parallel connections. 

Example:
curl --parallel-max 100 -Z https://example.com ftp://example.com/ 
-Z, --parallel	Perform transfers in parallel.

Example:
curl --parallel https://example.com -o file1 https://example.com -o file2
--pass <phrase>	Specify a private key passphrase. 

Example:
curl --pass secret --key file https://example.com 
--path-as-is	Prevent curl from merging /./ and /../ sequences. 

Example:
curl --path-as-is https://example.com/../../etc/passwd
--pinnedpubkey <hashes>	Specify a public key for curl to use. 

Example:
curl --pinnedpubkey keyfile https://example.com 
--post301	Prevent curl from converting POST to GET requests after a 301 redirection. 

Example:
curl --post301 --location -d "data" https://example.com 
--post302	Prevent curl from converting POST to GET requests after a 302 redirection.  

curl --post302 --location -d "data" https://example.com 
--post303	Prevent curl from converting POST to GET requests after a 303 redirection.  

Example:
curl --post303 --location -d "data" https://example.com 
--preproxy [protocol://]host[:port]	Use the SOCKS proxy as a pre-proxy. 

Example:
curl --preproxy socks5://proxy.example -x http://http.example https://example.com 
-#, --progress-bar	Use the simple progress bar.

Example:
curl -# -O https://example.com 
--proto-default <protocol>	Specify which protocol curl should use for URLs without a scheme name. 

Example:
curl --proto-default https ftp.example.com 
--proto-redir <protocols>	Specify which protocols curl should use on redirection. 

Example:
curl --proto-redir =http,https https://example.com 
--proto <protocols>	Specify which protocols curl should use for transfers.  

Example:
curl --proto =http,https,sftp https://example.com 
--proxy-anyauth	Curl should choose an appropriate authentication method. 

Example:
curl --proxy-anyauth --proxy-user user:passwd -x proxy https://example.com
--proxy-basic	Use HTTP Basic for communication with a proxy. 

Example:
curl --proxy-basic --proxy-user user:passwd -x proxy https://example.com 
--proxy-cacert <file>	--cacert for HTTPS proxies. 

Example:
curl --proxy-cacert CA-file.txt -x https://proxy https://example.com 
--proxy-capath <dir>	--capath for HTTPS proxies. 

Example:
curl --proxy-capath /local/directory -x https://proxy https://example.com
--proxy-cert-type <type>	--cert-type for HTTPS proxies. 

Example:
curl --proxy-cert-type PEM --proxy-cert file -x https://proxy https://example.com
--proxy-cert <cert[:passwd]>	-E, --cert for HTTPS proxies. 

Example:
curl --proxy-cert file -x https://proxy https://example.com 
--proxy-ciphers <list>	--ciphers for HTTPS proxies. 

curl --proxy-ciphers ECDHE-ECDSA-AES256-CCM8 -x https://proxy https://example.com 
--proxy-crlfile <file>	--crlfile for HTTPS proxies. 

Example:
curl --proxy-crlfile rejects.txt -x https://proxy https://example.com
--proxy-digest	Use HTTP Digest authentication with a proxy. 

Example:
curl --proxy-digest --proxy-user user:passwd -x proxy https://example.com 
--proxy-header <header/@file>	-H, --header for proxy communication. 

Example:
curl --proxy-header "Host:" -x http://proxy https://example.com 
--proxy-insecure	-k, --insecure for HTTPS proxies. 

Example:
curl --proxy-insecure -x https://proxy https://example.com 
--proxy-key-type <type>	--key-type for HTTPS proxies. 

Example:
curl --proxy-key-type DER --proxy-key here -x https://proxy https://example.com 
--proxy-key <key>	--key for HTTPS proxies. 

Example:
curl --proxy-key here -x https://proxy https://example.com 
--proxy-negotiate	--negotiate for proxy communication.

Example:
curl --proxy-negotiate --proxy-user user:passwd -x proxy https://example.com
--proxy-ntlm	Use HTTP NTLM authentication with a proxy.

Example:
curl --proxy-ntlm --proxy-user user:passwd -x http://proxy https://example.com
--proxy-pass <phrase>	--pass for HTTPS proxies. 

Example:
curl --proxy-pass secret --proxy-key here -x https://proxy https://example.com 
--proxy-pinnedpubkey <hashes>	Specify the public key for proxy verification. 

Example:
curl --proxy-pinnedpubkey keyfile https://example.com 
--proxy-service-name <name>	Specify the service name for proxy communciation. 

Example:
curl --proxy-service-name "shrubbery" -x proxy https://example.com 
--proxy-ssl-allow-beast	--ssl-allow-beast for HTTPS proxies. 

Example:
curl --proxy-ssl-allow-beast -x https://proxy https://example.com 
--proxy-ssl-auto-client-cert	--ssl-auto-client-cert for HTTPS proxies. 

Example:
curl --proxy-ssl-auto-client-cert -x https://proxy https://example.com 
--proxy-tls13-ciphers <ciphersuite list>	Specifies the list of cipher suites to use in negotiating TLS 1.3 for proxies. 

Example:
curl --proxy-tls13-ciphers TLS_AES_128_GCM_SHA256 -x proxy https://example.com
--proxy-tlsauthtype <type>	--tlsauthtype for HTTPS proxies. 

Example:
curl --proxy-tlsauthtype SRP -x https://proxy https://example.com 
--proxy-tlspassword <string>	--tlspassword for HTTPS proxies.

Example:
curl --proxy-tlspassword passwd -x https://proxy https://example.com 
--proxy-tlsuser <name>	--tlsuser for HTTPS proxies. 

Example:
curl --proxy-tlsuser smith -x https://proxy https://example.com 
--proxy-tlsv1	-1, --tlsv1 for HTTPS proxies. 

Example:
curl --proxy-tlsv1 -x https://proxy https://example.com 
-U, --proxy-user <user:password>	Specify the username and password for authenticating with a proxy.

Example:
curl --proxy-user name:pwd -x proxy https://example.com 
-x, --proxy [protocol://]host[:port]	Specify a proxy to use.

Example:
curl --proxy http://proxy.example https://example.com 
--proxy1.0 <host[:port]>	Specify a HTTP 1.0 proxy to use. 

Example:
curl --proxy1.0 -x http://proxy https://example.com 
-p, --proxytunnel	Create a proxy tunnel.

Example:
curl --proxytunnel -x http://proxy https://example.com 
--pubkey <key>	Provide a file containing a public key. 

Example:
curl --pubkey file.pub sftp://example.com/ 
-Q, --quote <command>	Send a command to a FTP or SFTP server, to be executed before the transfer. 

Example:
curl --quote "rm file" ftp://example.com/foo 
--random-file <file>	Specify a file containing random data. This file will be used for seeding the random engine. 

Example:
curl --random-file rubbish https://example.com 
-r, --range <range>	Obtain a range of bytes. 

Example:
curl --range 40-80 https://example.com 
--raw	Disable HTTP content decoding and obtain raw data. 

Example:
curl --raw https://example.com 
-e, --referer <URL>	Send Referrer Page information. 

Example:
curl --referer "https://test.example" https://example.com 
-J, --remote-header-name	Use header name specified by the server instead of obtaining it from the URL.

Example:
curl -OJ https://example.com/file 
--remote-name-all	Apply the -O, --remote-name option to all the URLs.

Example:
curl --remote-name-all ftp://example.com/file1 ftp://example.com/file2 
-O, --remote-name	Specify that the local file should have the name of the remote file that was downloaded.

Example:
curl -O https://example.com/filename 
-R, --remote-time	Specify that the local file should have the timestamp of the remote file that was downloaded.

Example:
curl --remote-time -o foo https://example.com 
--request-target <path>	Specify an alternative target path.

Example:
curl --request-target "*" -X OPTIONS https://example.com 
-X, --request <command>	Specify a request method for communication with the server.

Example:
curl -X "DELETE" https://example.com 
--resolve <[+]host:port:addr[,addr]...>	Specify a custom address for a host/port. 

Example:
curl --resolve example.com:443:127.0.0.1 https://example.com 
--retry-all-errors	Force retrying on all errors.

Example:
curl --retry-all-errors https://example.com 
--retry-connrefused	Add ECONNREFUSED to the list of errors that are eligible for --retry. 

Example:
curl --retry-connrefused --retry https://example.com 
--retry-delay <seconds>	Specify the amount of time between retries. 

Example:
curl --retry-delay 5 --retry https://example.com 
--retry-max-time <seconds>	Specify the maximum amount of time for --retry attempts. 

Example:
curl --retry-max-time 30 --retry 10 https://example.com 
--retry <num>	Specify the number of retries after curl encounters and error. 

Example:
curl --retry 7 https://example.com
--sasl-authzid <identity>	Specify an additional authentication identity for SASL PLAIN authentication. 

Example:
curl --sasl-authzid zid imap://example.com/ 
--sasl-ir	Enable initial response during SASL authentication.

Example:
curl --sasl-ir imap://example.com/ 
--service-name <name>	Specify the SPNEGO service name. 

Example:
curl --service-name sockd/server https://example.com 
-S, --show-error	Show an error message event with the -s, --silent option enabled. 

Example:
curl --show-error --silent https://example.com 
-s, --silent	Turn on the silent mode. This option mutes curl.

Example:
curl -s https://example.com 
--socks4 <host[:port]>	Specify a SOCKS4 proxy.

Example:
curl --socks4 hostname:4096 https://example.com 
--socks4a <host[:port]>	Specify a SOCKS4a proxy. 

Example:
curl --socks4a hostname:4096 https://example.com 
--socks5-basic	Use the basic authentication method (username/password) with a SOCKS5 proxy. 

Example:
curl --socks5-basic --socks5 hostname:4096 https://example.com 
--socks5-gssapi-nec	Allow protection mode negotiation to be unprotected.

Example:
curl --socks5-gssapi-nec --socks5 hostname:4096 https://example.com 
--socks5-gssapi-service <name>	Change the name of a socks server.

Example:
curl --socks5-gssapi-service sockd --socks5 hostname:4096 https://example.com 
--socks5-gssapi	Use GSS-API authentication with a SOCKS5 proxy. 

Example:
curl --socks5-gssapi --socks5 hostname:4096 https://example.com 
--socks5-hostname <host[:port]>	Specify the SOCKS5 proxy to use. 

Example:
curl --socks5-hostname proxy.example:7000 https://example.com 
--socks5 <host[:port]>	Specify the SOCKS5 proxy to use. The hostname is resolved locally. 

Example:
curl --socks5 proxy.example:7000 https://example.com 
-Y, --speed-limit <speed>	Set the lower limit for the download speed.

Example:
curl --speed-limit 300 --speed-time 10 https://example.com 
-y, --speed-time <seconds>	Set the time period for the speed limit measurement. 

Example:
curl --speed-limit 300 --speed-time 10 https://example.com 
--ssl-allow-beast	Tell curl to ignore the BEAST security flaw in the SSL3 and TLS1.0 protocols. 

Example:
curl --ssl-allow-beast https://example.com 
--ssl-auto-client-cert	Obtain and use a client certificate automatically. 

Example:
curl --ssl-auto-client-cert https://example.com 
--ssl-no-revoke	Do not check for certificate revocation. 

Example:
curl --ssl-no-revoke https://example.com 
--ssl-reqd	Require SSL/TLS. 

Example:
curl --ssl-reqd ftp://example.com 
--ssl-revoke-best-effort	Ignore certificate revocation checks if they failed because of missing distribution points.

Example:
curl --ssl-revoke-best-effort https://example.com 
--ssl	Attempt to use SSL. 

Example:
curl --ssl pop3://example.com/ 
-2, --sslv2	Use SSLv2. Newer curl versions ignore this request due to security concerns with SSLv2.

Example:
curl --sslv2 https://example.com 
-3, --sslv3	Use SSLv3. Newer curl versions ignore this request due to security concerns with SSLv3.  

Example:
curl --sslv3 https://example.com 
--stderr <file>	Output stderr to a file. The - symbol tells curl to output stderr to stdout. 

Example:
curl --stderr output.txt https://example.com 
--styled-output	Enable bold fonts for HTTP header terminal output. 

curl --styled-output -I https://example.com 
--suppress-connect-headers	Prevent curl from outputting CONNECT headers. 

Example:
curl --suppress-connect-headers --include -x proxy https://example.com 
--tcp-fastopen	Enable TCP Fast Open.

Example:
curl --tcp-fastopen https://example.com
--tcp-nodelay	Enable TCP_NODELAY. 

Example:
curl --tcp-nodelay https://example.com 
-t, --telnet-option <opt=val>	Pass the TTYPE, XDISPLOC, and NEW_ENV options to the telnet protocol. 

Example:
curl -t TTYPE=vt100 telnet://example.com/ 
--tftp-blksize <value>	Set the value of TFTP BLKSIZE. Must be a value larger than 512. 

Example:
curl --tftp-blksize 1024 tftp://example.com/file 
--tftp-no-options	Prevents curl from sending requests for TFTP options.

Example:
curl --tftp-no-options tftp://192.168.0.1/ 
-z, --time-cond <time>	Request a document that was modified after a certain date and time. For documents modified before the time, prefix the date expression with a dash.
 
Example:
curl -z "Wed 01 Sep 2021 12:18:00" https://example.com 
--tls-max <VERSION>	Specify the newest TLS version that is supported.

Example:
curl --tls-max 1.2 https://example.com 
--tls13-ciphers <ciphersuite list>	Specifies the list of cipher suites to use in negotiating TLS 1.3  

Example:
curl --tls13-ciphers TLS_AES_128_GCM_SHA256 https://example.com 
--tlsauthtype <type>	Specify the TLS authentication type.

Example:
curl --tlsauthtype SRP https://example.com 
--tlspassword <string>	Specify the TLS password. 

Example:
curl --tlspassword pwd --tlsuser user https://example.com 
--tlsuser <name>	Specify the TLS username. 

Example:
curl --tlspassword pwd --tlsuser user https://example.com 
--tlsv1.0	Tell curl to use TLS1.0 or newer. 

Example:
curl --tlsv1.0 https://example.com 
--tlsv1.1	Tell curl to use TLS1.1 or newer.  

Example:
curl --tlsv1.1 https://example.com 
--tlsv1.2	Tell curl to use TLS1.2 or newer.  

Example:
curl --tlsv1.2 https://example.com 
--tlsv1.3	Tell curl to use TLS1.3 or newer.  

Example:
curl --tlsv1.3 https://example.com 
-1, --tlsv1	Specify that curl should use at least 1.x version of TLS.

Example:
curl --tlsv1 https://example.com 
--tr-encoding	Ask for a compressed Transfer-Encoding response.

Example:
curl --tr-encoding https://example.com 
--trace-ascii <file>	Enable a full trace dump to a file. Eliminates the hex part and shows only ASCII.

Example:
curl --trace-ascii log.txt https://example.com 
--trace-time	Require a time stamp on each trace or verbose line. 

Example:
curl --trace-time --trace-ascii output https://example.com 
--trace <file>	Enable a full trace dump to a file.  

Example:
curl --trace log.txt https://example.com 
--unix-socket <path>	Specify a Unix socket path. 

Example:
curl --unix-socket socket-path https://example.com 
-T, --upload-file <file>	Upload a file to the URL. 

Example:
curl -T "img[1-1000].png" ftp://ftp.example.com/ 
--url <url>	Provide a URL to be fetched. 

Example:
curl --url https://example.com 
-B, --use-ascii	Enable ASCII transfer. 

Example:
curl -B ftp://example.com/README 
-A, --user-agent <name>	Specify the user agent name. 

Example:
curl -A "Agent 007" https://example.com 
-u, --user <user:password>	Provide the username and password for authentication. 

Example:
curl -u user:secret https://example.com 
-v, --verbose	Tell curl to be verbose. 

Example:
curl --verbose https://example.com 
-V, --version	See the installed versions of curl and libcurl.

Example:
curl --version 
-w, --write-out <format>	Tell curl to show information about the completed transfer on stdout. 

Example:
curl -w '%{http_code}\n' https://example.com 
--xattr	Store file metadata in file attributes.

Example:
curl --xattr -o storage https://example.com  
"""


##########################################################################################################
#NUMPY
##########################################################################################################
#NumPy is a Python library. is used for working with arrays. is short for "Numerical Python".
#It also has functions for working in domain of linear algebra, fourier transform, and matrices.
#NumPy was created in 2005 by Travis Oliphant. It is an open source project and you can use it freely.
#NumPy aims to provide an array object that is up to 50x faster than traditional Python lists.

#Why is NumPy Faster Than Lists?
#NumPy arrays are stored at one continuous place in memory unlike lists, so processes can access and manipulate them very efficiently.

#Which Language is NumPy written in?
#NumPy is a Python library and is written partially in Python, but most of the parts that require fast computation are written in C or C++.

#Where is the NumPy Codebase?
#The source code for NumPy is located at this github repository https://github.com/numpy/numpy

#--------------------------------------
#Installation of NumPy
#>pip install numpy

import numpy
arr = numpy.array([1, 2, 3, 4, 5])
print(arr)  #--->  [1 2 3 4 5]

#NumPy is usually imported under the np alias.

import numpy as np
arr = np.array([1, 2, 3, 4, 5])
print(arr)  #--->  [1 2 3 4 5]
print(type(arr))    #---> 

#Checking NumPy Version
print(np.__version__)   #--->  1.16.3

#To create an ndarray, we can pass a list, tuple or any array-like object into the array() method, and it will be converted into an ndarray:

#Use tuple to create a NumPy array:
arr = np.array((1, 2, 3, 4, 5))
print(arr)  #--->  ???  

#--------------------------------------
#Dimensions in Arrays
#A dimension in arrays is one level of array depth (nested arrays).

#0-D Arrays
arr = np.array(42)
print(arr)  #--->  42

#1-D Arrays
arr = np.array([1, 2, 3, 4, 5])
print(arr)  #--->  ???

#2-D Arrays
arr = np.array([[1, 2, 3], [4, 5, 6]])
print(arr)  #--->  [[1 2 3]
            #       [4 5 6]]

#3-D arrays
arr = np.array([[[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [4, 5, 6]]])
print(arr)  #--->  [[[1 2 3]
            #        [4 5 6]]

            #       [[1 2 3]
            #        [4 5 6]]]


#Check Number of Dimensions?
a = np.array(42)
b = np.array([1, 2, 3, 4, 5])
c = np.array([[1, 2, 3], [4, 5, 6]])
d = np.array([[[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [4, 5, 6]]])

print(a.ndim)   #--->  0
print(b.ndim)   #--->  1
print(c.ndim)   #--->  2
print(d.ndim)   #--->  3


#Higher Dimensional Arrays
arr = np.array([1, 2, 3, 4], ndmin=5)
print(arr)                                  #--->  [[[[[1 2 3 4]]]]]
print('number of dimensions :', arr.ndim)   #--->  5


#--------------------------------------
#Access Array Elements

import numpy as np
arr = np.array([1, 2, 3, 4])
print(arr[0])   #--->  1
print(arr[1])   #--->  2
print(arr[2] + arr[3])  #--->  7
print(arr[-1])  #--->  4
print(arr[-2])  #--->  3


#Access 2-D Arrays

arr = np.array([[1,2,3,4,5], [6,7,8,9,10]])
print('2nd element on 1st row: ', arr[0, 1])    #--->  2
print('5th element on 2nd row: ', arr[1, 4])    #--->  10

print(arr[1,1])     #--->  7
print(arr[-1,1])    #--->  7
print(arr[1,-1])    #--->  10
print(arr[-1,-1])   #--->  10


#Access 3-D Arrays
arr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
print(arr[0, 1, 2]) #--->  6
#because:
#The first number represents the first dimension, which contains two arrays:
#   [[1, 2, 3], [4, 5, 6]]
#   and:
#   [[7, 8, 9], [10, 11, 12]]
#   Since we selected 0, we are left with the first array:
#   [[1, 2, 3], [4, 5, 6]]
#The second number represents the second dimension, which also contains two arrays:
#   [1, 2, 3]
#   and:
#   [4, 5, 6]
#   Since we selected 1, we are left with the second array:
#   [4, 5, 6]
#The third number represents the third dimension, which contains three values:
#   4
#   5
#   6
#   Since we selected 2, we end up with the third value:
#   6

#--------------------------------------
#Array Slicing

arr = np.array([1, 2, 3, 4, 5, 6, 7])
print(arr[1:5]) #--->  [2 3 4 5]
print(arr[4:])  #--->  [5 6 7]
print(arr[:4])  #--->  [1 2 3 4]
print(arr[-3:-1])   #--->  [5 6]
print(arr[-1:-3])   #--->  []
print(arr[1:-3])    #--->  [2 3 4]
print(arr[-1:2])    #--->  []
print(arr[1:5:2])   #--->  [2 4]
print(arr[::2])     #--->  [1 3 5 7]












#Slicing 2-D Arrays

arr = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])
print(arr[1, 1:4])  #--->  [7 8 9]
print(arr[0:2, 2])  #--->  [3 8]
print(arr[0:2, 1:4])    #--->  [[2 3 4]
                        #       [7 8 9]]



#--------------------------------------
#Data Types
#NumPy has some extra data types, and refer to data types with one character, like i for integers, u for unsigned integers etc.

#--------------------------------------------------------------
#characters   data types
#--------------------------------------------------------------
#   i       - integer
#   b       - boolean
#   u       - unsigned integer
#   f       - float
#   c       - complex float
#   m       - timedelta
#   M       - datetime
#   O       - object
#   S       - string
#   U       - unicode string
#   V       - fixed chunk of memory for other type ( void )


#Checking the Data Type of an Array
arr = np.array([1, 2, 3, 4])
print(arr.dtype)    #--->  int64
arr = np.array(['apple', 'banana', 'cherry'])
print(arr.dtype)    #--->  ???


#Creating Arrays With a Defined Data Type
arr = np.array([1, 2, 3, 4], dtype='S')
print(arr)          #--->  ???
print(arr.dtype)    #--->  ???

#For i, u, f, S and U we can define size as well.
arr = np.array([1, 2, 3, 4], dtype='i4')
print(arr)          #--->  ???
print(arr.dtype)    #--->  ???

arr = np.array(['a', '2', '3'], dtype='i')  #--->  Error-A non integer string like 'a' can not be converted to integer


#Converting Data Type on Existing Arrays
arr = np.array([1.1, 2.1, 3.1])
newarr = arr.astype('i')
print(newarr)       #--->  [1 2 3]
print(newarr.dtype) #--->  int32

arr = np.array([1.1, 2.1, 3.1])
newarr = arr.astype(int)
print(newarr)       #--->  [1 2 3]
print(newarr.dtype) #--->  int64

arr = np.array([1, 0, 3])
newarr = arr.astype(bool)
print(newarr)       #--->  [ True False  True]
print(newarr.dtype) #--->  bool


#--------------------------------------
#Copy vs View
#the copy is a new array, and the view is just a view of the original array.

#The copy owns the data and any changes made to the copy will not affect original array, and any changes made to the original array will not affect the copy.
#The view does not own the data and any changes made to the view will affect the original array, and any changes made to the original array will affect the view.

import numpy as np
arr = np.array([1, 2, 3, 4, 5])
x = arr.copy()
arr[0] = 42
print(arr)  #--->  [42  2  3  4  5]
print(x)    #--->  [1 2 3 4 5]


import numpy as np
arr = np.array([1, 2, 3, 4, 5])
x = arr.view()
arr[0] = 42
print(arr)  [42  2  3  4  5]
print(x)    [42  2  3  4  5]

arr = np.array([1, 2, 3, 4, 5])
x = arr.view()
x[0] = 31
print(arr)  #--->  [31  2  3  4  5]
print(x)    #--->  [31  2  3  4  5]


#Check if Array Owns its Data
import numpy as np
arr = np.array([1, 2, 3, 4, 5])
x = arr.copy()
y = arr.view()
print(x.base)   #--->  None
print(y.base)   #--->  [1 2 3 4 5]



#--------------------------------------
#Shape of an Array
#The shape of an array is the number of elements in each dimension.
import numpy as np
arr = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
print(arr.shape)    #--->  (2, 4)


#Create an array with 5 dimensions using ndmin
import numpy as np
arr = np.array([1, 2, 3, 4], ndmin=5)
print(arr)                      #--->  [[[[[1 2 3 4]]]]]
print('shape of array :', arr.shape)    #--->  (1, 1, 1, 1, 4)


#Reshaping arrays
#Reshaping means changing the shape of an array.
#By reshaping we can add or remove dimensions or change number of elements in each dimension.

#Reshape From 1-D to 2-D
arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])
newarr = arr.reshape(4, 3)
print(newarr)   #--->  [[ 1  2  3]
                #       [ 4  5  6]
                #       [ 7  8  9]
                #       [10 11 12]]


#Reshape From 1-D to 3-D
arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])
newarr = arr.reshape(2, 3, 2)
print(newarr)   #--->  [[[ 1  2]
  [ 3  4]
  [ 5  6]]

 [[ 7  8]
  [ 9 10]
  [11 12]]]


arr = np.array([1, 2, 3, 4, 5, 6, 7, 8])
newarr = arr.reshape(3, 3)
print(newarr)   #--->  ValueError: cannot reshape array of size 8 into shape (3,3)


arr = np.array([1, 2, 3, 4, 5, 6, 7, 8])
print(arr.reshape(2, 4).base)   #--->  [1 2 3 4 5 6 7 8]


arr = np.array([1, 2, 3, 4, 5, 6, 7, 8])
newarr = arr.reshape(2, 2, -1)
print(newarr)   #--->  [[[1 2]
  [3 4]]

 [[5 6]
  [7 8]]]



#Flattening the arrays
#Flattening array means converting a multidimensional array into a 1D array.
arr = np.array([[1, 2, 3], [4, 5, 6]])
newarr = arr.reshape(-1)
print(newarr)   #--->  [1 2 3 4 5 6]

#There are a lot of functions for changing the shapes of arrays in numpy flatten, ravel and also for rearranging the elements rot90, flip, fliplr, flipud etc.



#--------------------------------------
#Iterating Arrays

#Iterating 1-D Arrays

arr = np.array([1, 2, 3])

for x in arr:
  print(x)

  1
2
3

#Iterating 2-D Arrays

arr = np.array([[1, 2, 3], [4, 5, 6]])

for x in arr:
  print(x)

[1 2 3]
[4 5 6]

#Iterate on each scalar element of the 2-D array:
arr = np.array([[1, 2, 3], [4, 5, 6]])

for x in arr:
  for y in x:
    print(y)

1
2
3
4
5
6

#Iterating 3-D Arrays

arr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
for x in arr:
    print(x)  #--->  
[[1 2 3]
 [4 5 6]]
[[ 7  8  9]
 [10 11 12]]


#To return the actual values, the scalars, we have to iterate the arrays in each dimension.
arr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
for x in arr:
    for y in x:
        for z in y:
            print(z)
1
2
3
4
5
6
7
8
9
10
11
12

#Iterating Arrays Using nditer()
arr = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
for x in np.nditer(arr):
    print(x)    #--->  ???
1
2
3
4
5
6
7
8

#Iterating Array With Different Data Types
arr = np.array([1, 2, 3])

for x in np.nditer(arr, flags=['buffered'], op_dtypes=['S']):
  print(x)
b'1'
b'2'
b'3'


#Iterating With Different Step Size
arr = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
for x in np.nditer(arr[:, ::2]):
    print(x)    #--->  ???
1
3
5
7



#Enumerated Iteration
#Enumeration means mentioning sequence number of somethings one by one.

#Enumerate on 1D arrays elements:
arr = np.array([1, 2, 3])
for idx, x in np.ndenumerate(arr):
    print(idx, x)   #--->  ???
(0,) 1
(1,) 2
(2,) 3


#Enumerate on 2D array's elements:
arr = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
for idx, x in np.ndenumerate(arr):
    print(idx, x)   #--->  ???
(0, 0) 1
(0, 1) 2
(0, 2) 3
(0, 3) 4
(1, 0) 5
(1, 1) 6
(1, 2) 7
(1, 3) 8


#--------------------------------------
#Joining Array
#Joining means putting contents of two or more arrays in a single array.
#In SQL we join tables based on a key, whereas in NumPy we join arrays by axes.
#If axis is not explicitly passed, it is taken as 0.


#Join two arrays
import numpy as np
arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])
arr = np.concatenate((arr1, arr2))
print(arr)  #--->  ???
[1 2 3 4 5 6]

#Join two 2-D arrays along rows (axis=1):
arr1 = np.array([[1, 2], [3, 4]])
arr2 = np.array([[5, 6], [7, 8]])
arr = np.concatenate((arr1, arr2), axis=1)
print(arr)  #--->  ???
[[1 2 5 6]
 [3 4 7 8]]

#Joining Arrays Using Stack Functions
#Stacking is same as concatenation, the only difference is that stacking is done along a new axis.
arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])
arr = np.stack((arr1, arr2), axis=1)
print(arr)
[[1 4]
 [2 5]
 [3 6]]

#Stacking Along Rows
arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])
arr = np.hstack((arr1, arr2))
print(arr)
[1 2 3 4 5 6]

#Stacking Along Columns
arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])
arr = np.vstack((arr1, arr2))
print(arr)
[[1 2 3]
 [4 5 6]]

#Stacking Along Height (depth)
arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])
arr = np.dstack((arr1, arr2))
print(arr)
[[[1 4]
  [2 5]
  [3 6]]]


#--------------------------------------
#Splitting NumPy Arrays
#Splitting is reverse operation of Joining
#Joining merges multiple arrays into one and Splitting breaks one array into multiple.

#Split the array in 3 parts:
import numpy as np
arr = np.array([1, 2, 3, 4, 5, 6])
newarr = np.array_split(arr, 3)
print(newarr)   #--->  [array([1, 2]), array([3, 4]), array([5, 6])]

#Split the array in 4 parts:
arr = np.array([1, 2, 3, 4, 5, 6])
newarr = np.array_split(arr, 4)
print(newarr)   #--->  [array([1, 2]), array([3, 4]), array([5]), array([6])]


#Split Into Arrays
#Access the splitted arrays:

arr = np.array([1, 2, 3, 4, 5, 6])
newarr = np.array_split(arr, 3)
print(newarr[0])
print(newarr[1])
print(newarr[2])

[1 2]
[3 4]
[5 6]


#Splitting 2-D Arrays
arr = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]])
newarr = np.array_split(arr, 3)
print(newarr)
[array([[1, 2],
       [3, 4]]), array([[5, 6],
       [7, 8]]), array([[ 9, 10],
       [11, 12]])]

#Split the 2-D array into three 2-D arrays
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]])
newarr = np.array_split(arr, 3)
print(newarr)
[array([[1, 2, 3],
       [4, 5, 6]]), array([[ 7,  8,  9],
       [10, 11, 12]]), array([[13, 14, 15],
       [16, 17, 18]])]

#Split the 2-D array into three 2-D arrays along rows
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]])
newarr = np.array_split(arr, 3, axis=1)
print(newarr)
[array([[ 1],
       [ 4],
       [ 7],
       [10],
       [13],
       [16]]), array([[ 2],
       [ 5],
       [ 8],
       [11],
       [14],
       [17]]), array([[ 3],
       [ 6],
       [ 9],
       [12],
       [15],
       [18]])]


#Use the hsplit() method to split the 2-D array into three 2-D arrays along rows
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]])
newarr = np.hsplit(arr, 3)
print(newarr)       

[array([[ 1],
       [ 4],
       [ 7],
       [10],
       [13],
       [16]]), array([[ 2],
       [ 5],
       [ 8],
       [11],
       [14],
       [17]]), array([[ 3],
       [ 6],
       [ 9],
       [12],
       [15],
       [18]])]


#Similar alternates to vstack() and dstack() are available as vsplit() and dsplit()
       



#--------------------------------------
#Searching Arrays
import numpy as np
arr = np.array([1, 2, 3, 4, 5, 4, 4])
x = np.where(arr == 4)
print(x)    #--->  (array([3, 5, 6]),)


#Find the indexes where the values are even:
arr = np.array([1, 2, 3, 4, 5, 6, 7, 8])
x = np.where(arr%2 == 0)
print(x)    #--->  (array([1, 3, 5, 7]),)


#Find the indexes where the values are odd:
arr = np.array([1, 2, 3, 4, 5, 6, 7, 8])
x = np.where(arr%2 == 1)
print(x)    #--->  (array([0, 2, 4, 6]),)


#Search Sorted
arr = np.array([6, 7, 8, 9])
x = np.searchsorted(arr, 7)
print(x)    #--->  1


#Search From the Right Side
arr = np.array([6, 7, 8, 9])
x = np.searchsorted(arr, 7, side='right')
print(x)    #--->  2


#Multiple Values
#To search for more than one value, use an array with the specified values.
arr = np.array([1, 3, 5, 7])
x = np.searchsorted(arr, [2, 4, 6])
print(x)    #--->  [1 2 3]


#Sorting Arrays
arr = np.array([3, 2, 0, 1])
print(np.sort(arr)) #--->  [0 1 2 3]

#Sort the array alphabetically:
arr = np.array(['banana', 'cherry', 'apple'])
print(np.sort(arr))
['apple' 'banana' 'cherry']

#Sort a boolean array:
arr = np.array([True, False, True])
print(np.sort(arr)) #--->  [False True True]




#Sorting a 2-D Array
arr = np.array([[3, 2, 4], [5, 0, 1]])
print(np.sort(arr))

[[2 3 4]
 [0 1 5]]



#--------------------------------------
#Filtering Arrays
#Getting some elements out of an existing array and creating a new array out of them is called filtering.

import numpy as np
arr = np.array([41, 42, 43, 44])
x = [True, False, True, False]
newarr = arr[x]
print(newarr)   #--->  [41 43]

#Creating the Filter Array
#Create a filter array that will return only values higher than 42
arr = np.array([41, 42, 43, 44])
filter_arr = [] # Create an empty list
for element in arr:
  # if the element is higher than 42, set the value to True, otherwise False:
  if element > 42:
    filter_arr.append(True)
  else:
    filter_arr.append(False)

newarr = arr[filter_arr]
print(filter_arr)
print(newarr)

[False, False, True, True]
[43 44]



#Create a filter array that will return only even elements from the original array:
arr = np.array([1, 2, 3, 4, 5, 6, 7])
filter_arr = [] # Create an empty list
for element in arr:
  # if the element is completely divisble by 2, set the value to True, otherwise False
  if element % 2 == 0:
    filter_arr.append(True)
  else:
    filter_arr.append(False)
newarr = arr[filter_arr]
print(filter_arr)
print(newarr)

[False, True, False, True, False, True, False]
[2 4 6]


#Creating Filter Directly From Array
#Create a filter array that will return only values higher than 42:
arr = np.array([41, 42, 43, 44])
filter_arr = arr > 42
newarr = arr[filter_arr]
print(filter_arr)
print(newarr)

[False False  True  True]
[43 44]




#Create a filter array that will return only even elements from the original array:
arr = np.array([1, 2, 3, 4, 5, 6, 7])
filter_arr = arr % 2 == 0
newarr = arr[filter_arr]
print(filter_arr)
print(newarr)

[False  True False  True False  True False]
[2 4 6]


#--------------------------------------
#Random Numbers in NumPy

#Generate Random Number
from numpy import random
x = random.randint(100)     #Generate a random integer from 0 to 100
print(x)    #--->  27

x = random.rand()   #Generate a random float from 0 to 1
print(x)    #--->  0.9717414713232739

#Generate Random Array
x=random.randint(100, size=(5))
print(x)    #--->  [30 99 14 58 37]


x = random.randint(100, size=(3, 5))    #Generate a 2-D array with 3 rows, each row containing 5 random integers from 0 to 100
print(x)

x = random.rand(5)  #Generate a 1-D array containing 5 random floats:
print(x)    #--->  [0.2162030 0.3350710 0.3812299 0.0567805 0.8698823]

x = random.rand(3, 5)   #Generate a 2-D array with 3 rows, each row containing 5 random numbers
print(x)    #--->  [[0.14252791 0.44691071 0.59274288 0.73873487 0.22082345] 
            #       [0.00484242 0.36294206 0.88507594 0.56948479 0.15075563] 
            #       [0.69195833 0.75111379 0.92780785 0.57986471 0.6203633 ]]



#Generate Random Number From Array
x = random.choice([3, 5, 7, 9])
print(x)    #--->  3


x = random.choice([3, 5, 7, 9], size=(3, 5))    #Generate a 2-D array that consists of the values in the array parameter (3, 5, 7, and 9)
print(x)    #--->  [[5 7 7 3 9]
            #       [9 9 5 7 5]
            #       [5 9 7 5 3]]



#Random Data Distribution
#https://www.w3schools.com/python/numpy/numpy_random_distribution.asp

#Random Permutations
#https://www.w3schools.com/python/numpy/numpy_random_permutation.asp

#Seaborn
#https://www.w3schools.com/python/numpy/numpy_random_seaborn.asp

#Normal (Gaussian) Distribution
#https://www.w3schools.com/python/numpy/numpy_random_normal.asp

#Binomial Distribution
#https://www.w3schools.com/python/numpy/numpy_random_binomial.asp

#Poisson Distribution
#https://www.w3schools.com/python/numpy/numpy_random_poisson.asp

#Uniform Distribution
#https://www.w3schools.com/python/numpy/numpy_random_uniform.asp

#Logistic Distribution
#https://www.w3schools.com/python/numpy/numpy_random_logistic.asp

#Multinomial Distribution
#https://www.w3schools.com/python/numpy/numpy_random_multinomial.asp

#Exponential Distribution
#https://www.w3schools.com/python/numpy/numpy_random_exponential.asp

#Chi Square Distribution
#https://www.w3schools.com/python/numpy/numpy_random_chisquare.asp

#Rayleigh Distribution
#https://www.w3schools.com/python/numpy/numpy_random_rayleigh.asp

#Pareto Distribution
#https://www.w3schools.com/python/numpy/numpy_random_pareto.asp

#Zipf Distribution
#https://www.w3schools.com/python/numpy/numpy_random_zipf.asp

#???



#--------------------------------------
#NumPy ufuncs

#https://www.w3schools.com/python/numpy/numpy_ufunc.asp

#???


##########################################################################################################
#PYLAB
##########################################################################################################
##https://www.javatpoint.com/python-pylab-module

#???



##########################################################################################################
#SCIPY
##########################################################################################################
#SciPy is a scientific computation library that uses NumPy underneath.
#stands for Scientific Python
#https://www.w3schools.com/python/scipy/index.php
#???

##########################################################################################################
#PANDAS
##########################################################################################################
#Pandas is a Python library. is used to analyze data.
#https://www.w3schools.com/python/pandas/default.asp
#???

#--------------------------------------
#DATA_FRAMES
#DataFrames
#https://www.javatpoint.com/how-to-create-a-dataframes-in-python







##########################################################################################################
#NMAP
##########################################################################################################
#helps us achieve the task of port scanning by creating a port scanner using the Python program. By using 
#this Nmap Module in a Python program, we can build a port scanner, and when we run the program, the port 
#scanner will automatically inspect the port ranges we defined inside the program.
#the port scanner is an application that is designed for probing a host or server connected with the particular
#port, and it is used for servers and hosts of open ports. 

#https://www.javatpoint.com/python-nmap-module
#???


##########################################################################################################
#OPENCV
##########################################################################################################
#???




##########################################################################################################
#WEBCAM_MOTION_DETECTOR
##########################################################################################################
#Webcam Motion Detector
#https://www.javatpoint.com/webcam-motion-detector-in-python
#???






##########################################################################################################
#DATABASE
##########################################################################################################
#There are various relational database management systems (RDBMS) available:
#GadFly    MySQL      PostgreSQL    Microsoft SQL Server        Informix     Oracle      Sybase      SQLite
#and many more...

#Database Packages
#   <<Database>>    	<<Python Package>>
#     Oracle      	      cx_oracle, pyodbc
#     SQL Server  	      pymssql, pyodbc
#     PostgreSQL  	      psycopg2
#     ySQL        	      MySQL Connector/Python, pymysql
#     SQLite        

#Performing Transactions
#Transactions are a mechanism that ensure data consistency. Transactions have the following four properties:
#   Atomicity   − Either a transaction completes or nothing happens at all.
#   Consistency − A transaction must start in a consistent state and leave the system in a consistent state.
#   Isolation   − Intermediate results of a transaction are not visible outside the current transaction.
#   Durability  − Once a transaction was committed, the effects are persistent, even after a system failure.

#Database Errors
#The DB API defines a number of errors that must exist in each database module. The following table lists these exceptions.
#   Warning             Used for non-fatal issues. Must subclass StandardError.	
#   Error               Base class for errors. Must subclass StandardError.	
#   InterfaceError      Used for errors in the database module, not the database itself. Must subclass Error.
#   DatabaseError       Used for errors in the database. Must subclass Error.
#   DataError           Subclass of DatabaseError that refers to errors in the data.
#   OperationalError    Subclass of DatabaseError that refers to errors such as the loss of a connection to the database. These errors are generally outside of the control of the Python scripter.
#   IntegrityError      Subclass of DatabaseError for situations that would damage the relational integrity, such as uniqueness constraints or foreign keys.
#   InternalError       Subclass of DatabaseError that refers to errors internal to the database module, such as a cursor no longer being active.
#   ProgrammingError    Subclass of DatabaseError that refers to errors such as a bad table name and other things that can safely be blamed on you.	
#   NotSupportedError   Subclass of DatabaseError that refers to trying to call unsupported functionality.


##########################################################################################################
#SQL
##########################################################################################################
#Structured Query language


# SELECT
# UPDATE
# DELETE
# INSERT TO
# CREATE DATABASE
# ALTER DATABASE
# CREATE TABLE
# ALTER TABLE
# DROP TABLE
# CREATE INDEX
# DROP INDEX


# CREATE TABLE student(
    # id int NOT NULL PRIMARY KEY AUTO_INCREMENT,
    
    # id int AUTO_INCREMENT,
    # name varchar(50), 
    # age int NOT NULL CHECK(age >= 18),
    # nationalcode varchar UNIQUE,
    # city varchar DEFAULT 'tehran',
    #
    # PRIMARY KEY (id)          # or
    # );

# SELECT DISTINCT * FROM <>

# SELECT COUNT(*) FROM <>
# SELECT MIN(<>) FROM <>

# SELECT * FROM <> WHERE <>
# ORDER BY <> ASC|DESC

# INSERT INTO <> VALUES (...)

# INSERT INTO <> (...)
# VALUES (...)

# INSERT INTO Student
# VALUES (12, 'alireza', 'ahmadi')

# INSERT INTO Student(id, name, family, age)
# VALUES(12, 'alireza', 'ahmadi')


# WHERE <> IS NOT NULL

# UPDATE <>
# SET 
# WHERE <> IS NULL

# SELECT DISTINCT * FROM Student;

# SELECT SUM() AVG() MIN() MAX()

# --comment in sql

# UPDATE Student
# SET name='zamazingo', family='zama'
# WHERE name = 'mehrdad' AND id = 123 OR id = 231
# WHERE NOT name = 'ali'
# ORDER BY age ASC,     # DESC
 

# DELETE FROM <>
# WHERE 

# SELECT TOP 3 * FROM <>

# SELECT * FROM <> LIMIT 3

# SELECT * FROM <> FETCH FIRST 3 ROWS ONLY

# SELECT * FROM <>
# WHERE 
# ORDER BY 
# LIMIT 3

# SELECT <>*<> AS <> FROM <>
 
# SELECT * FROM <>
# WHERE ... LIKE "..."  

# SELECT * FROM <>
# WHERE ... IN {...}  

# SELECT * FROM <>
# WHERE ... IN (...) 

# SELECT * FROM <>
# WHERE ... BETWEEN <> AND <>

# SELECT * FROM <>
# WHERE ... IN SELECT * FROM <>
#              WHERE ...





##########################################################################################################
#SQLITE
##########################################################################################################
#SQLite3 Module
#import
import sqlite3
print(sqlite3.sqlite_version)   #--->  '3.39.4'

#connect
conn = sqlite3.connect('testdb.sqlite3')
print(type(conn))      #--->  <class 'sqlite3.Connection'>

#cursor
cur=conn.cursor()
print(type(cur))       #--->  <class 'sqlite3.Cursor'>

#CREATE
import sqlite3
conn = sqlite3.connect('testdb.sqlite3')
cur  = conn.cursor()
qry='''                
CREATE TABLE Employee (
EmpID       INTEGER PRIMARY KEY AUTOINCREMENT,
FIRST_NAME  TEXT(20),
LAST_NAME   TEXT(20),
AGE         INTEGER,
SEX         TEXT(1),
INCOME      FLOAT
);
'''
try:
   cur.execute(qry)         #this is a query for create table
   print ('Table created successfully')
except:
   print ('error in creating table')
conn.close()

#way-2
#!/usr/bin/python  
import sqlite3  
conn = sqlite3.connect('javatpoint.db')  
print "Opened database successfully";  
conn.execute('''''CREATE TABLE Employees 
       (ID INT PRIMARY KEY     NOT NULL, 
       NAME           TEXT    NOT NULL, 
       AGE            INT     NOT NULL, 
       ADDRESS        CHAR(50), 
       SALARY         REAL);''')  
print "Table created successfully";  
conn.close()  




#We can verify by listing out tables in this database in SQLite console.
#   sqlite> .open mydb.sqlite
#   sqlite> .tables
#   Employee


#COMMIT Operation
#   Commit is an operation, which gives a green signal to the database to finalize the changes, and after 
#   this operation, no change can be reverted back.


#ROLLBACK Operation
#   If you are not satisfied with one or more of the changes and you want to revert back those changes completely
#   , then use the rollback() method.


#INSERT
#Way-1
import sqlite3
conn=sqlite3.connect('testdb.sqlite3')
cur=conn.cursor()
qry="""INSERT INTO EMPLOYEE(FIRST_NAME, LAST_NAME, AGE, SEX, INCOME)
       VALUES ('Mac', 'Mohan', 20, 'M', 2000)"""
try:
   cur.execute(qry)
   conn.commit()
   print ('Record inserted successfully')
except:
   conn.rollback()
print ('error in INSERT operation')
conn.close()

#Way-2
import sqlite3
conn=sqlite3.connect('testdb.sqlite3')
cur=conn.cursor()
qry="""INSERT INTO EMPLOYEE(FIRST_NAME, LAST_NAME, AGE, SEX, INCOME)
       VALUES (?, ?, ?, ?, ?)"""
try:
   cur.execute(qry, ('Makrand', 'Mohan', 21, 'M', 5000))
   conn.commit()
   print ('Record inserted successfully')
except Exception as e:
   conn.rollback()
   print ('error in INSERT operation')
conn.close()




#READ
#fetchone()   It fetches the next row of a query result set. A result set is an object that is returned
#             when a cursor object is used to query a table.
#fetchall()   It fetches all the rows in a result set. If some rows have already been extracted from the
#             result set, then it retrieves the remaining rows from the result set.
#rowcount     This is a read-only attribute and returns the number of rows that were affected by an execute()
#             method.
import sqlite3
conn = sqlite3.connect('testdb.sqlite3')
cur  = conn.cursor()
qry="SELECT * FROM EMPLOYEE"

try:
    cur.execute(qry)     # Execute the SQL command
    results = cur.fetchall()     # Fetch all the rows in a list of lists.
    for row in results:
        fname  = row[1]
        lname  = row[2]
        age    = row[3]
        sex    = row[4]
        income = row[5]
        print ("fname={},lname={},age={},sex={},income={}".format(fname, lname, age, sex, income ))
except Exception as e:
    print (e)
    print ("Error: unable to fetch data")
conn.close()        #--->  fname=Mac,lname=Mohan,age=20,sex=M,income=2000.0
                    #      fname=Makrand,lname=Mohan,age=21,sex=M,income=5000.0

#way-2
#!/usr/bin/python  
import sqlite3  
conn = sqlite3.connect('javatpoint.db')  
data = conn.execute("select * from Employees");  
for row in data:  
   print "ID = ", row[0]  
   print "NAME = ", row[1]  
   print "ADDRESS = ", row[2]  
   print "SALARY = ", row[3], "\n"  
conn.close(); 



#UPDATE
import sqlite3
conn = sqlite3.connect('testdb.sqlite3')
cur  = conn.cursor()
qry  = "UPDATE EMPLOYEE SET INCOME = INCOME+1000 WHERE INCOME=?"

try:
   cur.execute(qry, (1000,))           # Execute the SQL command
   conn.commit()        # Fetch all the rows in a list of lists.
   print ("Records updated")
except Exception as e:
   print ("Error: unable to update data")
conn.close()




#DELETE
import sqlite3
conn = sqlite3.connect('testdb.sqlite3')
cur  = conn.cursor()
qry  = "DELETE FROM EMPLOYEE WHERE INCOME<?"
try:
   # Execute the SQL command
   cur.execute(qry, (2000,))
   # Fetch all the rows in a list of lists.
   conn.commit()
   print ("Records deleted")
except Exception as e:
   print ("Error: unable to delete data")
conn.close()



##########################################################################################################
#MYSQL
##########################################################################################################
#https://www.w3schools.com/python/python_mysql_getstarted.asp


#Python needs a MySQL driver to access the MySQL database.
#We recommend that you use PIP to install "MySQL Connector"

#Download and install "MySQL Connector":
#>>python -m pip install mysql-connector-python

#----------------------------
#create database
#----------------------------
#creating a connection to the database
import mysql.connector

mydb = mysql.connector.connect(     
  host="localhost",
  user="yourusername",
  password="yourpassword"
)

print(mydb)


#connecting to the database with name: "mydatabase"
mydb = mysql.connector.connect(     
  host="localhost",
  user="yourusername",
  password="yourpassword",
  database="mydatabase"             #this database
)



#create a database
mycursor = mydb.cursor()
mycursor.execute("CREATE DATABASE mydatabase")      

mycursor.execute("SHOW DATABASES")
for x in mycursor:
  print(x)      #a list of your system's databases




#----------------------------
#create table
#----------------------------
#Create a table named "customers"
import mysql.connector

mydb = mysql.connector.connect(
  ...
)

mycursor = mydb.cursor()
mycursor.execute("CREATE TABLE customers (name VARCHAR(255), address VARCHAR(255))")

#Check if Table Exists
mycursor = mydb.cursor()
mycursor.execute("SHOW TABLES")
for x in mycursor:
  print(x)


#Create primary key when creating the table
mycursor = mydb.cursor()
mycursor.execute("CREATE TABLE customers (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255), address VARCHAR(255))")


#Create primary key on an existing table
mycursor = mydb.cursor()
mycursor.execute("ALTER TABLE customers ADD COLUMN id INT AUTO_INCREMENT PRIMARY KEY")



#----------------------------
#insert record in table
#----------------------------
#Insert a record in the "customers" table:
mycursor = mydb.cursor()

sql = "INSERT INTO customers (name, address) VALUES (%s, %s)"
val = ("John", "Highway 21")
mycursor.execute(sql, val)
mydb.commit()

print(mycursor.rowcount, "record inserted.")


#insert multiple rows into a table, use the executemany() method.
mycursor = mydb.cursor()

sql = "INSERT INTO customers (name, address) VALUES (%s, %s)"
val = [
  ('Peter', 'Lowstreet 4'),
  ('Amy', 'Apple st 652'),
  ('Hannah', 'Mountain 21'),
  ('Michael', 'Valley 345'),
  ('Sandy', 'Ocean blvd 2'),
  ('Betty', 'Green Grass 1'),
  ('Richard', 'Sky st 331'),
  ('Susan', 'One way 98'),
  ('Vicky', 'Yellow Garden 2'),
  ('Ben', 'Park Lane 38'),
  ('William', 'Central st 954'),
  ('Chuck', 'Main Road 989'),
  ('Viola', 'Sideway 1633')
]

mycursor.executemany(sql, val)
mydb.commit()
print(mycursor.rowcount, "was inserted.")


#get the id of the row you just inserted by asking the cursor object.
mycursor = mydb.cursor()
sql = "INSERT INTO customers (name, address) VALUES (%s, %s)"
val = ("Michelle", "Blue Village")
mycursor.execute(sql, val)
mydb.commit()
print(" id of inserted record: , ID:", mycursor.lastrowid)





#----------------------------
#select
#----------------------------
#select from a table
mycursor = mydb.cursor()
mycursor.execute("SELECT * FROM customers")
myresult = mycursor.fetchall()
for x in myresult:
  print(x)  #--->  ???


#select only some of the columns in a table,
mycursor = mydb.cursor()
mycursor.execute("SELECT name, address FROM customers")
myresult = mycursor.fetchall()  #   the fetchall() method will return all rows
for x in myresult:
  print(x)  #--->  ???
#or
myresult = mycursor.fetchone()  #   the fetchone() method will return the first row of the result:
print(myresult)


#----------------------------
#where
#----------------------------

mycursor = mydb.cursor()

sql = "SELECT * FROM customers WHERE address = %s"
adr = ("Yellow Garden 2", )

mycursor.execute(sql, adr)

myresult = mycursor.fetchall()

for x in myresult:
  print(x)




#----------------------------
#delete Record
#----------------------------

mycursor = mydb.cursor()

sql = "DELETE FROM customers WHERE address = 'Mountain 21'"

mycursor.execute(sql)

mydb.commit()

print(mycursor.rowcount, "record(s) deleted")

#----------------------------
#delete table
#----------------------------
#drop table
mycursor = mydb.cursor()
sql = "DROP TABLE customers"
mycursor.execute(sql)

#drop Only if Exist
mycursor = mydb.cursor()
sql = "DROP TABLE IF EXISTS customers"
mycursor.execute(sql)



#----------------------------
#update table
#----------------------------
mycursor = mydb.cursor()
sql = "UPDATE customers SET address = %s WHERE address = %s"
val = ("Valley 345", "Canyon 123")
mycursor.execute(sql, val)
mydb.commit()
print(mycursor.rowcount, "record(s) affected")




##########################################################################################################
#POSTGRESQL
##########################################################################################################
#-------
#install
#-------
#$ sudo apt update
#$ sudo apt install postgresql

#-------
#config
#-------
#$ sudo systemctl is-active postgresql
#$ sudo systemctl is-enabled postgresql
#$ sudo systemctl status postgresql


#$ sudo pg_isready

#-----------------
#Creating Database
#-----------------
#$ sudo su - postgres
#$ psql
#postgres=# 

#postgres=# CREATE USER tecmint WITH PASSWORD 'securep@wd';
#postgres=# CREATE DATABASE tecmintdb;
#postgres=# GRANT ALL PRIVILEGES ON DATABASE tecmintdb to tecmint;
#postgres=# \q

#---------------------------------
#Configuring Client Authentication
#---------------------------------
#$ sudo vim /etc/postgresql/12/main/pg_hba.conf

#-------
#restart
#-------
#$ sudo systemctl restart postgresql



#-----------------------------
#Installing pgAdmin4 in Ubuntu
#-----------------------------
#$ curl https://www.pgadmin.org/static/packages_pgadmin_org.pub | sudo apt-key add
#or
#$ curl -fsS https://www.pgadmin.org/static/packages_pgadmin_org.pub | sudo gpg --dearmor -o /usr/share/keyrings/packages-pgadmin-org.gpg

#$ sudo sh -c 'echo "deb https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/$(lsb_release -cs) pgadmin4 main" > /etc/apt/sources.list.d/pgadmin4.list && apt update'
#or
#sudo sh -c 'echo "deb [signed-by=/usr/share/keyrings/packages-pgadmin-org.gpg] https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/$(lsb_release -cs) pgadmin4 main" > /etc/apt/sources.list.d/pgadmin4.list && apt update'


#$sudo apt install pgadmin4

#http://SERVER_IP/pgadmin4






##########################################################################################################
#MONGODB
##########################################################################################################
#https://www.w3schools.com/python/python_mongodb_getstarted.asp
#https://www.javatpoint.com/python-mongodb

#Python needs a MongoDB driver to access the MongoDB database.
#We recommend that you use PIP to install "PyMongo".

#>>python -m pip install pymongo

#----------------------------
#creating a database
#----------------------------
#Create a database called "mydatabase"
import pymongo

myclient = pymongo.MongoClient("mongodb://localhost:27017/")

mydb = myclient["mydatabase"]

print(myclient.list_database_names())   #list of your system's databases

#check a specific database by name
dblist = myclient.list_database_names()
if "mydatabase" in dblist:
  print("The database exists.")



#----------------------------
#creating a collection
#----------------------------
import pymongo

myclient = pymongo.MongoClient("mongodb://localhost:27017/")
mydb = myclient["mydatabase"]

mycol = mydb["customers"]

print(mydb.list_collection_names())     #list of all collections in your database


#check a specific collection by name
collist = mydb.list_collection_names()
if "customers" in collist:
  print("The collection exists.")



#----------------------------
#insert Into collection
#----------------------------
import pymongo

myclient = pymongo.MongoClient("mongodb://localhost:27017/")
mydb = myclient["mydatabase"]
mycol = mydb["customers"]

mydict = { "name": "John", "address": "Highway 37" }

x = mycol.insert_one(mydict)

print(x.inserted_id)


#insert multiple documents into a collection
mylist = [
  { "name": "Amy", "address": "Apple st 652"},
  { "name": "Hannah", "address": "Mountain 21"},
  { "name": "Michael", "address": "Valley 345"},
  { "name": "Sandy", "address": "Ocean blvd 2"},
  { "name": "Betty", "address": "Green Grass 1"},
  { "name": "Richard", "address": "Sky st 331"},
  { "name": "Susan", "address": "One way 98"},
  { "name": "Vicky", "address": "Yellow Garden 2"},
  { "name": "Ben", "address": "Park Lane 38"},
  { "name": "William", "address": "Central st 954"},
  { "name": "Chuck", "address": "Main Road 989"},
  { "name": "Viola", "address": "Sideway 1633"}
]

x = mycol.insert_many(mylist)


print(x.inserted_ids)   #print list of the _id values of the inserted documents



#insert Multiple Documents, with Specified IDs
mylist = [
  { "_id": 1, "name": "John", "address": "Highway 37"},
  { "_id": 2, "name": "Peter", "address": "Lowstreet 27"},
  { "_id": 3, "name": "Amy", "address": "Apple st 652"},
  { "_id": 4, "name": "Hannah", "address": "Mountain 21"},
  { "_id": 5, "name": "Michael", "address": "Valley 345"},
  { "_id": 6, "name": "Sandy", "address": "Ocean blvd 2"},
  { "_id": 7, "name": "Betty", "address": "Green Grass 1"},
  { "_id": 8, "name": "Richard", "address": "Sky st 331"},
  { "_id": 9, "name": "Susan", "address": "One way 98"},
  { "_id": 10, "name": "Vicky", "address": "Yellow Garden 2"},
  { "_id": 11, "name": "Ben", "address": "Park Lane 38"},
  { "_id": 12, "name": "William", "address": "Central st 954"},
  { "_id": 13, "name": "Chuck", "address": "Main Road 989"},
  { "_id": 14, "name": "Viola", "address": "Sideway 1633"}
]

x = mycol.insert_many(mylist)


print(x.inserted_ids)   #print list of the _id values of the inserted documents



#----------------------------
#find
#----------------------------
#Find the first document in the customers collection
import pymongo

myclient = pymongo.MongoClient("mongodb://localhost:27017/")
mydb = myclient["mydatabase"]
mycol = mydb["customers"]

x = mycol.find_one()

print(x)


#find all documents in the "customers" collection
for x in mycol.find():
  print(x)
  
#Return only the names and addresses, not the _ids  
for x in mycol.find({},{ "_id": 0, "name": 1, "address": 1 }):
      print(x)  

# will exclude "address" from the result  
for x in mycol.find({},{ "address": 0 }):
      print(x)


#----------------------------
#filter the result
#----------------------------
#find document(s) with the address "Park Lane 38"

myquery = { "address": "Park Lane 38" }

mydoc = mycol.find(myquery)

for x in mydoc:
  print(x)


#Find documents where the address starts with the letter "S" or higher:
import pymongo

myclient = pymongo.MongoClient("mongodb://localhost:27017/")
mydb = myclient["mydatabase"]
mycol = mydb["customers"]

myquery = { "address": { "$gt": "S" } }

mydoc = mycol.find(myquery)

for x in mydoc:
  print(x)
  
  
#Find documents where the address starts with the letter "S"
import pymongo

myclient = pymongo.MongoClient("mongodb://localhost:27017/")
mydb = myclient["mydatabase"]
mycol = mydb["customers"]

myquery = { "address": { "$regex": "^S" } }

mydoc = mycol.find(myquery)

for x in mydoc:
  print(x)
  

#----------------------------
#Sort the Result    
#----------------------------
#Sort the result alphabetically by name:
import pymongo

myclient = pymongo.MongoClient("mongodb://localhost:27017/")
mydb = myclient["mydatabase"]
mycol = mydb["customers"]

mydoc = mycol.find().sort("name")

for x in mydoc:
  print(x)


#Use the value -1 as the second parameter to sort descending.
sort("name", 1) #ascending
sort("name", -1) #descending



#----------------------------
#delete document
#----------------------------
#delete the document with the address "Mountain 21"
import pymongo

myclient = pymongo.MongoClient("mongodb://localhost:27017/")
mydb = myclient["mydatabase"]
mycol = mydb["customers"]

myquery = { "address": "Mountain 21" }

mycol.delete_one(myquery)


#delete all documents were the address starts with the letter S
import pymongo

myclient = pymongo.MongoClient("mongodb://localhost:27017/")
mydb = myclient["mydatabase"]
mycol = mydb["customers"]

myquery = { "address": {"$regex": "^S"} }

x = mycol.delete_many(myquery)

print(x.deleted_count, " documents deleted.")



#Delete all documents in the "customers" collection
import pymongo

myclient = pymongo.MongoClient("mongodb://localhost:27017/")
mydb = myclient["mydatabase"]
mycol = mydb["customers"]

x = mycol.delete_many({})

print(x.deleted_count, " documents deleted.")


#----------------------------
#delete collection
#----------------------------
#delete the "customers" collection:

import pymongo

myclient = pymongo.MongoClient("mongodb://localhost:27017/")
mydb = myclient["mydatabase"]
mycol = mydb["customers"]

mycol.drop()

#----------------------------
#update collection
#----------------------------
#Change the address from "Valley 345" to "Canyon 123"
import pymongo

myclient = pymongo.MongoClient("mongodb://localhost:27017/")
mydb = myclient["mydatabase"]
mycol = mydb["customers"]

myquery = { "address": "Valley 345" }
newvalues = { "$set": { "address": "Canyon 123" } }

mycol.update_one(myquery, newvalues)

for x in mycol.find():      #print "customers" after the update
  print(x)
  
  
  
  
#Update all documents where the address starts with the letter "S"
import pymongo

myclient = pymongo.MongoClient("mongodb://localhost:27017/")
mydb = myclient["mydatabase"]
mycol = mydb["customers"]

myquery = { "address": { "$regex": "^S" } }
newvalues = { "$set": { "name": "Minnie" } }

x = mycol.update_many(myquery, newvalues)

print(x.modified_count, "documents updated.")  



#----------------------------
#limit the result
#----------------------------
#Limit the result to only return 5 documents:
import pymongo

myclient = pymongo.MongoClient("mongodb://localhost:27017/")
mydb = myclient["mydatabase"]
mycol = mydb["customers"]

myresult = mycol.find().limit(5)

for x in myresult:
  print(x)




##########################################################################################################
#INFLUXDB
##########################################################################################################
#https://www.javatpoint.com/Influxdb-in-python
#???






##########################################################################################################
#MATPLOTLIB
##########################################################################################################
#https://www.w3schools.com/python/matplotlib_intro.asp
#???



##########################################################################################################
#MACHINE_LEARNING
##########################################################################################################
#https://www.w3schools.com/python/python_ml_getting_started.asp
#???


##########################################################################################################
#PYSPARK
##########################################################################################################
#https://www.javatpoint.com/pyspark-mllib
#???


##########################################################################################################
#GUI
##########################################################################################################
#https://pygobject.readthedocs.io
#https://gtk.org

#Gtk ~ Qt
#pygobject
import gi
#Adw <--->  Gtk
#gi.require_versions({"Gtk" : "4.0"})
gi.require_version({"Awd" : '1'})
#from gi.repository import Gtk
from gi.repository import Adw
from . import handlers

Adw.init()
#builder = Gtk.Builder()
builder = Gtk.Builder(scope_object_or_map = handlers)
builder.add_from_file("frontend.ui")

class MyWindow(Awd.ApplicationWindow):
    header_bar = Adw.HeaderBar()
    def __init__(self):
        super().__init__()

class Application(Adw.Application):
    def do_activate(self):
        #window = Gtk.ApplicationWindow(application = self , title = "Test1 app")
        window = builder.get_object("window")
        window.set_application(self)
        self.window = window
        self.window.present()

def main():
    app = Application()
    app.run()

if __name__ == "__main__" :
    main()
#this was backend

#we make a xml file to save our Template codes then add file to our main code
#MVT
#Model          --->  Data
#View           --->  Logical part of our program      (Model <-- View --> Template)
#Template       --->  what we see when open the software

#ui.xml is a file that we produce it and save our graphical codes in it
#you can get help from "cambalache" to produce many xml code for frontend with Gtk
#ui.xml or "frontend.ui"
'''
<interface>
    <requires lib="gtk" version="4.6"/>
    <requires lib="libadwaita" version="1.1"/>
    
    <object class="AdwApplicationWindow" id="window">
        <child>
            <object class="GtkBox">
                <property name="orientation">vertical</property>
                <child>
                    <object class="AdwHeaderBar">
                        <child type="title">
                            <object class="AdwWindowTitle">
                                <property name="title">Hello</property>
                                <property name="subtitle">Daneshkar</property>
                            </object>
                        </child>
                    </object>
                </child>
            </object>
        </child>
    </object>

</interface>
'''
#this was frontend


#handlers.py
'''
def on_clicked(button, *args, **kwargs):
'''

##########################################################################################################
#TKINTER
##########################################################################################################
#???


##########################################################################################################
#QT
##########################################################################################################
#https://www.javatpoint.com/create-the-first-gui-application-using-pyqt5-in-python
#???




##########################################################################################################
#DESKTOP_NOTIFIER
##########################################################################################################
#Desktop Notifier
#https://www.javatpoint.com/desktop-notifier-in-python
#???






##########################################################################################################
#TURTLE
##########################################################################################################
#Turtle library is a Python library used to create unique graphics, pictures and games in Python.
#Python turtle library was developed by Wally Feurzeig, Seymour Parpet and Cynthia Solomon in 1967.
#it need "tkinter" module to run



#Step-1: Import Turtle library and its Functions
import turtle  
from turtle import *  

#Step-2: Setup the turtle screen
screen = turtle.Screen()  # screen for output  
t = turtle.Turtle()  # Defining a turtle Instance  
speed(1) 

#Step-3: Create Functions
#step-4: Call them

#Turtle methods:
#   t.penup()            it is for ...
#   t.pendown()          it is for ...    
#   t.goto(x,y)          it is for ...
#   t.color("blue")   
#   t.pensize(1)        to change size of pen
#   t.begin_fill()      start filling with color
#   t.end_fill()        end filling with color
#   t.forward(x)
#   t.backward(x)  
#   t.right(x)
#   t.left(x)
#   t.circle(x)         
#   turtle.done()       for finish turtle work
#   speed(5)            define the pen speed 



#example - draw a flag
import turtle  
from turtle import *  
screen = turtle.Screen()  
t = turtle.Turtle()  
speed(5)  
# Orange Rectangle  
#white rectangle  
def draw_orange_rectangle():  
    # initially penup()  
    t.penup()  
    t.goto(-200, 125)  
    t.pendown()  
  
    t.color("orange")  
    t.begin_fill()  
    t.forward(400)  
    t.right(90)  
    t.forward(84)  
    t.right(90)  
    t.forward(400)  
    t.end_fill()  
    t.left(90)  
    t.forward(84)  
  
# Draw Green Rectangle  
def draw_green_rectangle():  
    t.color("green")  
    t.begin_fill()  
    t.forward(84)  
    t.left(90)  
    t.forward(400)  
    t.left(90)  
    t.forward(84)  
    t.end_fill()  
  
# Big Blue Circle  
def big_blue_circle():  
    t.penup()  
    t.goto(35, 0)  
    t.pendown()  
    t.color("navy")  
    t.begin_fill()  
    t.circle(35)  
    t.end_fill()  
  
# Big White Circle  
def big_white_circle():  
    t.penup()  
    t.goto(30, 0)  
    t.pendown()  
    t.color("white")  
    t.begin_fill()  
    t.circle(30)  
    t.end_fill()  
  
#Mini Blue Circles of Flag  
def mini_blue():  
    t.penup()  
    t.goto(-27, -4)  
    t.pendown()  
    t.color("navy")  
    for i in range(24):  
        t.begin_fill()  
        t.circle(2)  
        t.end_fill()  
        t.penup()  
        t.forward(7)  
        t.right(15)  
        t.pendown()  
  
# Small Blue Circle  
def draw_small_blue_circle():  
    t.color("navy")  
    t.penup()  
    t.goto(10, 0)  
    t.pendown()  
    t.begin_fill()  
    t.circle(10)  
    t.end_fill()  
  
#The spokes of India Flag  
def flag_spokes():  
    t.penup()  
    t.goto(0, 0)  
    t.pendown()  
    t.pensize(1)  
    for i in range(24):  
        t.forward(30)  
        t.backward(30)  
        t.left(15)  
  
#for stick of the flag  
def flag_stick():  
    t.color("Brown")  
    t.pensize(10)  
    t.penup()  
    t.goto(-200,125)  
    t.right(180)  
    t.pendown()  
    t.forward(800)  
  
draw_orange_rectangle()  
draw_green_rectangle()  
big_blue_circle()  
big_white_circle()  
mini_blue()  
draw_small_blue_circle()  
flag_spokes()  
flag_stick()  
  
turtle.done()  



##########################################################################################################
#PYGAME
##########################################################################################################
# importing the necessary modules  
import pygame   # importing the pygame module  
import time     # importing the time module  
import random   # importing the random module  
  
# defining the speed of the snake  
speed_of_snake = 15  
  
# defining the size of the window  
SCREEN_WIDTH = 700  
SCREEN_HEIGHT = 460  
  
# defining  the colors  
midnight_blue = pygame.Color(25, 25, 112)  
mint_cream = pygame.Color(245, 255, 250)  
crimson_red = pygame.Color(220, 20, 60)  
lawn_green = pygame.Color(124, 252, 0)  
orange_red = pygame.Color(255, 69, 0)  
  
# initializing the pygame window using the pygame.init() function  
pygame.init()  
  
# using the set_mode() function of the pygame.display module to set the size of the screen  
display_screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))  
  
# setting the title of the application using the set_caption() function  
pygame.display.set_caption('SNAKE - JAVATPOINT')  
  
# creating an object of the Clock() class of the pygame.time module  
game_clock = pygame.time.Clock()  
  
# defining the default position of the snake  
position_of_snake = [100, 50]  
  
# defining the first four blocks of snake body  
body_of_snake = [  
    [100, 50],  
    [90, 50],  
    [80, 50],  
    [70, 50]  
    ]  
  
# position of the fruit  
position_of_fruit = [  
    random.randrange(1, (SCREEN_WIDTH//10)) * 10,  
    random.randrange(1, (SCREEN_HEIGHT//10)) * 10  
    ]  
spawning_of_fruit = True  
  
# setting the default direction of the snake towards RIGHT  
initial_direction = 'RIGHT'  
snake_direction = initial_direction  
  
# initial score  
player_score = 0  
  
# defining the functions  
# function to display the score  
def display_score(selection, font_color, font_style, font_size):  
  
    # creating the font object  
    score_font_style = pygame.font.SysFont(font_style, font_size)  
  
    # creating the display surface object  
    score_surface = score_font_style.render('Your Score : ' + str(player_score), True, font_color)  
  
    # creating a rectangular object for the text placement  
    score_rectangle = score_surface.get_rect()  
  
    # displaying the text  
    display_screen.blit(score_surface, score_rectangle)  
  
# function to over the game  
def game_over():  
  
    # creating the font object  
    game_over_font_style = pygame.font.SysFont('times new roman', 50)  
  
    # creating the display surface object  
    game_over_surface = game_over_font_style.render(  
        'Your Score is : ' + str(player_score), True, crimson_red  
    )  
  
    # creating a rectangular object for the text placement  
    game_over_rectangle = game_over_surface.get_rect()  
  
    # setting the position of the text  
    game_over_rectangle.midtop = (SCREEN_WIDTH/2, SCREEN_HEIGHT/4)  
  
    # displaying the text on the screen  
    display_screen.blit(game_over_surface, game_over_rectangle)  
  
    # using the flip() function to update the small portion of the screen  
    pygame.display.flip()  
  
    # suspending the execution of the current thread for 2 seconds  
    time.sleep(2)  
  
    # calling the quit() function  
    pygame.quit()  
  
    # quiting the application  
    quit()  
  
# setting the run flag value to True  
game_run = True  
  
# the game loop  
# using the while loop  
while game_run:  
    # iterating through the events in the pygame.event module  
    for event in pygame.event.get():  
        # setting the variable value to False if the event's type is equivalent to pygame's QUIT constant  
        if event.type == pygame.QUIT:  
            # setting the flag value to False  
            game_run = False  
  
        # setting the variable value either to UP, DOWN, LEFT, or RIGHT  
        # if the event's type is equivalent to pygame's KEYDOWN constant,  
        # and any of the stated keys is pressed  
        if event.type == pygame.KEYDOWN:  
            if event.key == pygame.K_UP:  
                snake_direction = 'UP'  
            if event.key == pygame.K_DOWN:  
                snake_direction = 'DOWN'  
            if event.key == pygame.K_LEFT:  
                snake_direction = 'LEFT'  
            if event.key == pygame.K_RIGHT:  
                snake_direction = 'RIGHT'  
  
    # neglecting the action taken if the key of opposite direction is pressed  
    if snake_direction == 'UP' and initial_direction != 'DOWN':  
        initial_direction = 'UP'  
    if snake_direction == 'DOWN' and initial_direction != 'UP':  
        initial_direction = 'DOWN'   
    if snake_direction == 'LEFT' and initial_direction != 'RIGHT':  
        initial_direction = 'LEFT'   
    if snake_direction == 'RIGHT' and initial_direction != 'LEFT':  
        initial_direction = 'RIGHT'  
  
    # updating the position of the snake for every direction   
    if initial_direction == 'UP':  
        position_of_snake[1] -= 10  
    if initial_direction == 'DOWN':  
        position_of_snake[1] += 10  
    if initial_direction == 'LEFT':  
        position_of_snake[0] -= 10  
    if initial_direction == 'RIGHT':  
        position_of_snake[0] += 10  
      
    # updating the body of the snake  
    body_of_snake.insert(0, list(position_of_snake))  
    if position_of_snake[0] == position_of_fruit[0] and position_of_snake[1] == position_of_fruit[1]:  
        # incrementing the player's score by 1  
        player_score += 1  
        spawning_of_fruit = False  
    else:  
        body_of_snake.pop()  
  
    # randomly spawning the fruit  
    if not spawning_of_fruit:  
        position_of_fruit = [  
            random.randrange(1, (SCREEN_WIDTH//10)) * 10,  
            random.randrange(1, (SCREEN_HEIGHT//10)) * 10  
        ]  
    spawning_of_fruit = True  
  
    # filling the color on the screen  
    display_screen.fill(mint_cream)  
  
    # drawing the game objects on the screen  
    for position in body_of_snake:  
        pygame.draw.rect(display_screen, lawn_green, pygame.Rect(position[0], position[1], 10, 10))  
        pygame.draw.rect(display_screen, orange_red, pygame.Rect(position_of_fruit[0], position_of_fruit[1], 10, 10))  
  
    # conditions for the game to over  
    if position_of_snake[0] < 0 or position_of_snake[0] > SCREEN_WIDTH - 10:  
        game_over()  
    if position_of_snake[1] < 0 or position_of_snake[1] > SCREEN_HEIGHT - 10:  
        game_over()      
  
    # touching the snake body  
    for block in body_of_snake[1:]:  
        if position_of_snake[0] == block[0] and position_of_snake[1] == block[1]:  
            game_over  
    
    # displaying the score continuously  
    display_score(1, midnight_blue, 'times new roman', 20)  
  
    # refreshing the game screen  
    pygame.display.update()  
  
    # refresh rate  
    game_clock.tick(speed_of_snake)  
  
# calling the quit() function to quit the application  
pygame.quit()  


##########################################################################################################
#EMOJI_MODULE
##########################################################################################################
#https://www.javatpoint.com/python-emoji-module
#???



##########################################################################################################
#AUDIO
##########################################################################################################
#https://www.javatpoint.com/python-audio-modules
#???



##########################################################################################################
#WEB_SCRAPING
##########################################################################################################
#https://www.javatpoint.com/web-scraping-using-python
#???





##########################################################################################################
#IMDBPY
##########################################################################################################
#https://www.javatpoint.com/python-imdbpy-a-library-for-movies
#???

##########################################################################################################
#CHATBOT
##########################################################################################################
#https://www.javatpoint.com/chatbot-in-python






##########################################################################################################
#GRAMMAR_&_SPELL_CHECKER
##########################################################################################################
#https://www.javatpoint.com/grammar-and-spell-checker-in-python
#???




##########################################################################################################
#TELEGRAM_BOT
##########################################################################################################
#https://www.javatpoint.com/building-a-telegram-bot-using-python
#???



#some of most comman frameworks for making telegram bot with python:
# aiogram
# origamibot
# pyrogram
# pytelegrambotapi
# pytgbot
# python-telegram-bot
# teleflask
# telethon
# tgrambot


##########################################################################################################
#PYROGRAM
##########################################################################################################
#is a library for python which we can use it to make telegram bots
#we can connect to telegram core with : 
#       -telegram bot api
#       -MTProto
#pyrogram is based on MTProto
#Pyrogram is a framework written from the ground up that acts as a fully-fledged Telegram client based on the MTProto API.
#This means that Pyrogram is able to execute any official client and bot API action and more.



#----------------------------
# MTProto vs. Bot API
#----------------------------
#MTProto:
# took alone, is the name of 
#   - the custom-made, 
#   - open and encrypted communication protocol 
#   - created by Telegram itself  
# 
# it’s the only protocol used to exchange information between a client and the actual Telegram servers.
# Clients that make use of Telegram’s main API, such as Pyrogram, implement all details.


#The Bot API: 
# is an HTTP(S) interface for building normal bots using a sub-set of the main Telegram API
# Bots are special accounts that are authorized via tokens instead of phone numbers
# the Bot API
#   -is built yet again on top of the main Telegram API, 
#   -but runs on an intermediate server application that in turn communicates with the actual Telegram servers using MTProto.

# bot      <------(json/http)------> bot api <------(mtproto/tcp)------> telegram
# pyrogram <-----------------------(mtproto/tcp)-----------------------> telegram


#Advantages of the MTProto API:
#the advantages in using MTProto-based libraries (such as Pyrogram) instead of the official HTTP Bot API
#
#   + Authorize both user and bot identities
#   – The Bot API only allows bot accounts
#
#   + Upload & download any file, up to 2000 MiB each (~2 GB)
#   – The Bot API allows uploads and downloads of files only up to 50 MB / 20 MB in size
#
#   + Has less overhead due to direct connections to Telegram
#   – The Bot API uses an intermediate server to handle HTTP requests before they are sent to the actual Telegram servers.
#
#   + Run multiple sessions at once (for both user and bot identities)
#   – The Bot API intermediate server will terminate any other session in case you try to use the same bot again in a parallel connection.
#
#   + Has much more detailed types and powerful methods
#   – The Bot API types often miss some useful information about Telegram entities and some of the methods are limited as well.
#
#   + Obtain information about any message existing in a chat using their ids
#   – The Bot API simply doesn’t support this
#
#   + Retrieve the whole chat members list of either public or private chats
#   – The Bot API simply doesn’t support this
#
#   + Receive extra updates, such as the one about a user name change
#   – The Bot API simply doesn’t support this
#
#   + Has more meaningful errors in case something went wrong
#   – The Bot API reports less detailed errors
#
#   + Get API version updates, and thus new features, sooner
#   – The Bot API is simply slower in implementing new features
#




#----------------------------
# Install Pyrogram
#----------------------------
#>>pip isnatall Pyrogram
#>>pip install TgCrypto


#for verify installation:
#>>import pyrogram
#>>pyrogram.__version__



# API Key
#The first step requires you to obtain a Telegram API key.
#In order to do so, follow Telegram’s instructions at https://core.telegram.org/api/obtaining_api_id and make sure you understand and abide to the rules for third-party clients and libraries explained there.
#The API key consists of two parts: api_id and api_hash. Keep it secret.

# Telegram Doc
#Creating your Telegram Application
#We welcome all developers to use our API and source code to create Telegram-like messaging applications on our platform free of charge.
#In order to ensure consistency and security across the Telegram ecosystem, all third-party client apps must comply with the API Terms of Service.
#Obtaining api_id
#In order to obtain an API id and develop your own application using the Telegram API you need to do the following:
#   -Sign up for Telegram using any application.
#   -Log in to your Telegram core: https://my.telegram.org.
#   -Go to "API development tools" and fill out the form.
#   -You will get basic addresses as well as the api_id and api_hash parameters required for user authorization.
#   -For the moment each number can only have one api_id connected to it.
#We will be sending important developer notifications to the phone number that you use in this process, so please use an up-to-date number connected to your active Telegram account.

#for fill api_id and api_hash:
# must to login to my.telegram.org and in developement tools create an app  (recommended)
#or
# @PyGetApiBot


#----------------------------
# Initialize Pyrogram
#----------------------------
#in __main__.py:
from pyrogram import Client

api_id = 12345
api_hash = "0123456789abcdef0123456789abcdef"
bot_token = "123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11"

app = Client("my_account", api_id=api_id, api_hash=api_hash, bot_token=bot_token)

#or
#in __main__.py:
from pyrogram import Client

#app = Client(session_name="",)     # old_version
app = Client(
                name="test_bot",             # name of app      (from my.telegram)
                api_id=123456789,            # api id of app    (from my.telegram)
                api_hash="23488LoghetEr128", # api hash of app  (from my.telegram)
                token="594555:dasadAsdhrg",  # token of bot     (from botfather)       
            )


#for test functionality of bot 
#if i send any message to bot it reply me salam
@app.on_message()
def my_handler(client:Client, message:Message):
    message.reply_text("salam")

app.run()



#----------------------------
# Plugins
#----------------------------
#with two way we can use plugins to encapsulating our bot project:
#   way-1       add plugins folder to main code with plugins root
#   way-2       add plugins folder to main code with config.ini

#way-1
#we create a folder with name plugins and inside it create start.py to do when bot is started
#   -plugins
#       -start.py
#   -__main__.py

#in start.py:
from pyrogram import Client

@Client.on_message()
def my_handler(client, message):
    message.reply_text("salam")


#in __main__.py:
from pyrogram import Client

plugins = dict(root="plugins")

app = Client(
                name="test_bot",             # name of app      (from my.telegram)
                api_id=123456789,            # api id of app    (from my.telegram)
                plugins=plugins,
                api_hash="23488LoghetEr128", # api hash of app  (from my.telegram)
                token="594555:dasadAsdhrg",  # token of bot     (from botfather)       
            )

app.run()


#way-2
#create config.ini file and add this code to it:
[plugins]
root=plugins    # folder which contain plugin files


##########################################################################################################
#INSTAGRAM_BOT
##########################################################################################################
#???





##########################################################################################################
#NLP
##########################################################################################################
#???



#--------------------------------------
#TOKENIZER
#https://www.javatpoint.com/tokenizer-in-python
#???




#--------------------------------------
#TEXT_MINING
#https://faradars.org/courses/text-mining-with-python-fvpy316
#Text Mining
#???




##########################################################################################################
#LINTER
##########################################################################################################








##########################################################################################################
#PYLINT
##########################################################################################################
#first you must download and install 'pylint'

#in terminal:
#>>pylint mycode.py
#or
#>>pylint code1.py code2.py
#or
#>>pylint directroy-of-.py-file

#disable an error
class person:   # pylint: disable=invalid-name

    def __init__(self):
        pass




#rc file
#>>pylint --generate-rcfile > .pylintrc
#this will be create a file (.pylintrc) inside of my directory nearby mycode.py file
#this is a config file for pylint


#pycharm has a linter based on pep8 that work better than pylint
#ruff is fastest linter for python
##########################################################################################################
#FLAKE
##########################################################################################################




##########################################################################################################
#ruff
##########################################################################################################
#a python linter which created with rust programming language
#is the fastest linter in between python linters         



##########################################################################################################
#ERROR_HANDLING
##########################################################################################################

# Errors
#Syntax errors are the most common type of errors one faces while writing a program
#Syntax errors are basically related to the rules of grammar of a certain language.
#Syntax errors occur whenever the rules laid down by the language are not followed

#name="Python
#--->  SyntaxError: unterminated string literal (detected at line 1)

#print "Hello"
#--->  SyntaxError: Missing parentheses in call to 'print'. Did you mean print(...)?

numbers = [10,20,30,40]
for n in range(5):
   print (numbers[n])
#--->  IndexError: list index out of range

#import notamodule
#--->  ModuleNotFoundError: No module named 'notamodule'   

D1={'1':"aa", '2':"bb", '3':"cc"}
print ( D1['4'])
#--->  KeyError: '4'

from math import cube
#--->  ImportError: cannot import name 'cube'

it = iter([1,2,3])
next(it)
next(it)
next(it)
next(it)
#--->  StopIteration

print ('2'+2)
#--->  TypeError: must be str, not int

print (int('xyz'))
#--->  ValueError: invalid literal for int() with base 10: 'xyz'

print (age)
#--->  NameError: name 'age' is not defined

x = 100/0
#--->  ZeroDivisionError: division by zero

#When user hits the interrupt key normally Control-C during execution of program.
#--->  KeyboardInterrupt





###################
# Exception
###################
#An exception is an event, which occurs during the execution of a program that disrupts the normal flow of the program's instructions.
#When a Python script raises an exception, it must either handle the exception immediately otherwise it terminates and quits.
#Python's standard library defines standard exception classes

#object hierarchy of Python's Exceptions:
'''
object:
    BaseException
        Exception
            ArithmeticError
                FloatingPointError
                OverflowError
                ZeroDivisionError
            AssertionError
            AttributeError
            BufferError
            EOFError
            ImportError
                ModuleNotFoundError
            LookupError
                IndexError
                KeyError
            MemoryError
            NameError
            osError
            ReferenceError
            RuntimeError
            StopAsyncIteration
            StopIteration
            SyntaxError
            GeneratorExit
'''

#try-except Block
#example-2
def div (num1,num2):
    return num1/num2 

num1 , num2 = input("enter two numbers: ") 
print(f"division is: {div(int(num1),int(num2))}")

num1 , num2 = 4 , 0
div(num1, num2)     #ZeroDivisionError - division by zero

try:
    div(num1,num2)
except ZeroDivisionError:
    print("تقسیم بر صفر مجاز نیست")
except TypeError:
    print("خطا در نوع داده ای")    
else :
    print("doing something")    
#it is faster than if else statement but it use more memory


#exception with Arguments
def temp_convert(var):
    try:
        return int(var)
    except ValueError as Argument:
        print("The argument does not contain numbers\n")
        print(Argument)  #--->  invalid literal for int() with base 10: 'xyz'

temp_convert("xyz")






#try-except-else Block
#if we dont go to any except we will go to else
#example-2
toolong = "this is toolong file"

try:
   fh = open("testfile", "w")
   fh.write("This is my test file for exception handling!!")
except IOError:     # if there is IO error    
   print ("Error: can\'t find file or read data")
else:               # if there is no error
   print ("Written content in the file successfully")
   fh.close()
   raise toolong or ValueError  # you can raise a message like Error Exception




#try-finally Block
#The finally: block is a place to put any code that must execute, whether the try-block raised an exception or not.
#example-3
var1 = 4  
var2 = 0  
    
try:  
    d = var1 // var2 # this will raise a "divide by zero" exception.  
    print( d )  
except ZeroDivisionError:  # this section will handle exception raised in try block 
    print("We cannot divide by zero")  
finally:  # If exception is raised or not, this block will be executed every time  
    print("This is inside finally block")  

print ("The value of var1 / var2 is : ")  
assert var2 != 0, "Divide by 0 error"   # by using assert keyword we will check if var2 is 0  
print (var1 / var2)  


#example-4
try:
    fh = open("testfile", "w")
    try:
        fh.write("This is my test file for exception handling!!")
    finally:
        print ("Going to close the file")
        fh.close()
except IOError:
    print ("Error: can\'t find file or read data")


#example-5
try:
    f = open('myfile.txt')
    s = f.readline()
    i = int(s.strip())
except OSError as err:
    print("os error:", err)
except ValueError:
    print("Could not convert data to an integer.")
except Exception as err:
    print(f"Unexpected {err=}, {type(err)=}")
    raise        

#Nested try Block
#example-5
a = 10
b = 0
try:
    print ("This is outer try block") #--->  This is outer try block (1)
    try:
        print (a/b)
    except KeyError:
        print ("Key Error")
    finally:
        print ("inside inner finally block") #--->  inside inner finally block (2)
      
except ZeroDivisionError:
    print ("Division by 0") #--->  Division by 0 (3)
finally:
    print ("inside outer finally block")    #--->  inside outer finally block (4)


#example
a=10
b=0
try:
    print ("This is outer try block") #--->  This is outer try block (1)
    try:
        print (a/b)
    except ZeroDivisionError:
        print ("Division by 0") #--->  Division by 0 (2)
    finally:
        print ("inside inner finally block") #--->  inside inner finally block (3)
      
except Exception:
    print ("General Exception")
finally:
    print ("inside outer finally block") #--->  inside outer finally block (4)






###################
# raise
###################
#Raising Exceptions
#You can raise exceptions in several ways by using the raise statement.

#example-1
try:
    x = 10
    if x > 5:
        raise Exception('something go wrong')
except Exception as error:        
    print('error :', error)
    
    
#example-2
def welcome(name):
    if name != "mahmood" :
        print(f"welcome {name} to your home")
    else :
        raise NameError("mahmood is not allowed")
    if 'A' <= name[0] <= 'Z' :
        raise SyntaxError
    
name = input("Enter your name:")
try:
    welcome(name)
except NameError :
    print("check your name!!")
    raise MemoryError   #Exception Chaining
    #During handling of the above exception, another exception occurred

#raise . . from
#in upper example (exception chaining) first you see except error then raise error
#but in this one  (raise  ...   from ) first you see raise error then except error 
#also in below one(raise .. from None) you just see raise error
try:
   open("nofile.txt")
except OSError as exc:
   raise RuntimeError from exc
   #The above exception was the direct cause of the following exception

#raise . . from None
try:
    open("nofile.txt")
except OSError as exc:
    raise RuntimeError from None
    #RuntimeError

#raise manual exception
num = [3, 4, 5, 7]  
if len(num) > 3:  
    raise Exception( f"Length of the given list must be less than or equal to 3 but is {len(num)}" )  
    #--->  Exception: Length of the given list must be less than or equal to 3 but is 4



#Error in Argument
def functionName( level ):
    if level <1:
        raise Exception(level)
    return level
   
try:
   l=functionName(-10)
   print ("level=",l)
except Exception as e:
   print ("error in level argument",e.args[0])



#__context__ and __cause__
#Raising an exception in the except block will automatically add the captured exception to the __context__ 
#attribute of the new exception. Similarly, you can also add __cause__ to any exception using the expression 
#raise ... from syntax.
try:
    try:
        raise ValueError("ValueError")
    except ValueError as e1:
        raise TypeError("TypeError") from e1
    print(e1)   #---> ???
    print(e1.__cause__) #--->  ???
    print(e1.__context__ ) #--->  ???
except TypeError as e2:
    print("e2 exception was", repr(e2))                 #--->  TypeError('TypeError')
    print("e2 __context__ was", repr(e2.__context__))   #--->  ValueError('ValueError')
    print("e2 __cause__ was", repr(e2.__cause__))       #--->  ValueError('ValueError')
    print(e2)   #---> TypeError
    print(e2.__cause__) #--->  ValueError
    print(e2.__context__ ) #--->  ValueError


###########################
# Built-in Exceptions
###########################
#Exception              Base class for all exceptions

#StopIteration          Raised when the next() method of an iterator does not point to any object.
#StopIteration	        Raised when the next() method of an iterator has no further values

#SystemExit             Raised by the sys.exit() function.
#StandardError          Base class for all built-in exceptions except StopIteration and SystemExit.

#ArithmeticError        Base class for all errors that occur for numeric calculation.
#OverflowError          Raised when a calculation exceeds maximum limit for a numeric type.
#FloatingPointError     Raised when a floating point calculation fails.
#ZeroDivisonError       Raised when division or modulo by zero takes place for all numeric types.

#AssertionError         Raised in case of failure of the Assert statement.
#AttributeError         Raised in case of failure of attribute reference or assignment.

#ImportError            Raised when an import statement fails.
#ModuleNotFoundError    Raised by import when a module could not be located. It is also raised when None is found in sys.modules.
#KeyboardInterrupt      Raised when the user interrupts program execution, usually by pressing Ctrl+C.

#LookupError            Base class for all lookup errors.
#IndexError             Raised when an index is not found in a sequence.
#KeyError               Raised when the specified key is not found in the dictionary.
#NameError              Raised when an identifier is not found in the local or global namespace.This is raised when you try to use a variable or function that hasn’t been defined.
#UnboundLocalError      Raised when trying to access a local variable in a function or method but no value has been assigned to it.
#EnvironmentError       Base class for all exceptions that occur outside the Python environment.
#IOError                Raised when an input/ output operation fails, such as the print statement or the open() function when trying to open a file that does not exist.
#OSError                Raised for operating system-related errors.
#SyntaxError            Raised when there is an error in Python syntax.
#IndentationError       Raised when indentation is not specified properly.
#SystemError            Raised when the interpreter finds an internal problem, but when this error is encountered the Python interpreter does not exit.
#SystemExit             Raised when Python interpreter is quit by using the sys.exit() function. If not handled in the code, causes the interpreter to exit.
#SystemError	        Raised when a system error occurs
#SystemExit	            Raised when the sys.exit() function is called

#TypeError              Raised when an operation or function is attempted that is invalid for the specified data type.
#ValueError             Raised when the built-in function for a data type has the valid type of arguments, but the arguments have invalid values specified.
#RuntimeError           Raised when a generated error does not fall into any category.
#NotImplementedError    Raised when an abstract method that needs to be implemented in an inherited class is not actually implemented.
#FileNotFoundError      Happens when you try to open or access a file that does not exist.
#FileExistsError        Raised when trying to create a file or directory which already exists.
#TimeoutError           Raised when a system function timed out at the system level
#StopAsyncIteration     
#RecursionError         Raised when the interpreter detects that the maximum recursion depth
#UnicodeError
#UnicodeEncodeError     Raised when a unicode encoding problem occurs
#UnicodeDecodeError     Raised when a unicode decoding problem occurs
#UnicodeTranslateError  Raised when a unicode translation problem occurs
#GeneratorExit          Raised when a generator is closed (with the close() method)
#KeyboardInterrupt      Raised when the user presses Ctrl+c, Ctrl+z or Delete
#LookupError            Raised when errors raised cant be found
#MemoryError            Raised when a program runs out of memory
#ReferenceError         Raised when a weak reference object does not exist
#TabError               Raised when indentation consists of tabs or spaces
#ProcessLookupError     Raised when a given process does not exist.
#PermissionError        Raised when trying to run an operation without the adequate access rights
#NotADirectoryError     Raised when a directory operation (such as os.listdir()) is requested on something which is not a directory
#IsADirectoryError      Raised when a file operation (such as os.remove()) is requested on a directory. 

#IndentationError       Base class for syntax errors related to incorrect indentation. This is a subclass of SyntaxError.
#ChildProcessError      Raised when an operation on a child process failed.

#ConnectionError        Base class for connection-related issues.
#ConnectionRefusedError Raised when a connection attempt is refused by the peer.A subclass of ConnectionError, 
#ConnectionAbortedError Raised when a connection attempt is aborted by the peer. A subclass of ConnectionError
#ConnectionResetError   Raised when a connection is reset by the peer.
#BrokenPipeError        raised when trying to write on a pipe while the other end has been closed, or trying to write on a socket which has been shutdown for writing.

#EOFError               Raised when there is no input from either the raw_input() or input() function and the end of file is reached.
#BlockingIOError        Raised when an operation would block on an object (e.g. socket) set for non-blocking operation.





###################
#User-Defined Exceptions
###################

class MyException(Exception):
    "Invalid marks used"
    pass
   
num = 10
try:
    if num <0 or num>100:
        raise MyException
except MyException as e:
    print ("Invalid marks:", num)
else:
    print ("Marks obtained:", num) 
#???    
#num = 10 , 104, -10    
#Marks obtained:  10
#Invalid marks:  104
#Invalid marks:  -10

#User-Defined Exceptions with constructor
class CapitalLetterError (Exception) :
    def __init__(self, message, errors) :
        super().__init__(message)
        self.errors = "لطفا بزرگ ننویسید"
    

name = "Ali"

if 'A' <= name[0] <= 'Z' :
    raise CapitalLetterError("No Capital Letter")


#Nested Exception

#try:
#    raise ValueError('value error')
#except Exception:
#    raise TypeError('type error') from ImportError('import error')
#--->
"""
ImportError: import error
The above exception was the direct cause of the following exception:
Traceback (most recent call last):
  File "main.py", line 6, in <module>
    raise TypeError('type error') from ImportError('import error')
TypeError: type error
"""




#####################
# ASSERT (Assertions)
#####################
#An assertion is a sanity-check that you can turn on or turn off when you are done with your testing of the program.
#The AssertionError is also a built-in exception. So it can be used as argument in except block.

x = 4
assert x == 5 #check this if True then continue else raise an AssertionError
print("x is equal to 5")
#--->  AssertionError


def sum(a, b):
    assert (type(a) is int and type(b) is int), "numbers must be int"
    assert (a >= 0 and b >= 0), "arguments must be bigger than zero"
    return a + b

print(sum(1,"2"))   #---> numbers must be int


shoe = {'name': "Nike", 'price':400}

def apply_discount(product, discount):
    price = product['price'] - discount
    assert 0 <= price <= product['price']
    return price

print(apply_discount(shoe, 70))

#assert is not for show error to user - assert is to help developer to find bugs and problems in code
#never use asset for authentication checking
#in Terminal you can disable all asserts inside of code
#>>python -O mycode.py      (-O will disable all asserts)

#if you use assert condition inside of () like tuple it will never be false, always will be True
assert(x == 7,)




x = []
def add_x(i):
    assert i not in x, 'Sorry...'
    x.append(i)


#example-1
num = 75
assert num>=0 and num<=100      #assert num>=0 and num<=100, "only numbers in 0-100 accepted"
print ('marks obtained: ', num) #--->  marks obtained: 75

num = 125
assert num>=0 and num<=100  #--->  AssertionError
print ('marks obtained: ', num)



#example-2
try:
    num = int(input('enter a number'))
    assert (num >= 0), "only non negative numbers accepted"
    print (num)
except AssertionError as msg:
    print (msg) #--->  only non negative numbers accepted



#example-3
def avg(scores):    
    assert len(scores) != 0,"The List is empty."    #کنترل کن تا شرط برقرار باشه
    return sum(scores)/len(scores)    
    
scores2 = [67,59,86,75,92]    
print("The Average of scores2:",avg(scores2))   #--->  The Average of scores2: 75.8  
    
scores1 = []    
print("The Average of scores1:",avg(scores1))   #--->  AssertionError: The List is empty.

#assert with message
x = 7    
y = 0       
print ("x / y value is : ")     
assert y != 0, "Divide by 0 error"    
print (x / y)    


#example 
def sum(a, b):
    assert (type(a) is int and type(b) is int), "numbers must be int"
    assert (a >= 0 and b >= 0), "arguments must be bigger than zero"
    return a + b

try:
    print(sum(2,-1))
except:
    print("there is an error")
except AssertionError:
    print("there is an error too")

try:
    print(sum(2,-1))    
except AssertionError as msg:
    print(msg)    
    

##########################################################################################################
#TRACEBACK_MODULE
##########################################################################################################

import traceback

try:
    print(number445)
except Exception:
    traceback.print_exc()   #--->  Traceback (most recent call last):
                            #        File "main.py", line 4, in <module>
                            #          prunt(number445)
                            #      NameError: name 'prunt' is not defined
    exresult = traceback.format_exc()

#for example:
#we use it to search in error sentences
def test_empty_stop_iteration(self):
    try:
        ...
    except ValueError:
        formatted_exc = traceback.format_exc()
        self.assertIn('StopIteration', formatted_exc)
        self.assertIn("The above exception was the direct cause", formatted_exc)




import traceback

try:
    print(number)
except Exception: 
    print("Error")  #--->  Error
    traceback.print_exc()
    result = traceback.format_exc() # string





##########################################################################################################
#TEST
##########################################################################################################
# test.py
import unittest
from add import main as add

class TestAddFunc(unittest.TestCase):
    def test_add(self):
        self.assertEqual(add[-,2,3] , 5)    #because in add.py we give arg 1 and 2 , arg 0 not used 

unittest.main()    


# add.py
from sys import argv 
def main(argv) :
    return ( int(argv[1]) + int(argv[2]) )

if __name__ == "__main__" :
    main(argv)







#example-1
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity: int):
        # ظرفیت ماکسیمم کش
        self.capacity = capacity
        # اطلاعات کش به صورت یک OrderedDict
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key in self.cache:
            # کلید دسترسی‌یافته به انتهای OrderedDict منتقل می‌شود تا نشان‌دهنده استفاده‌ی اخیرترین باشد
            self.cache.move_to_end(key)
            return self.cache[key]
        else:
            # اگر کلید یافت نشد، -1 برگردانید
            return -1

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            # اگر کلید در کش وجود داشته باشد، مقدار آن به‌روزرسانی شده و به انتهای OrderedDict منتقل می‌شود
            self.cache[key] = value
            self.cache.move_to_end(key)
        else:
            # اگر ظرفیت کش بیشتر یا مساوی با ظرفیت ماکسیمم باشد، آیتم کمتر استفاده شده (اولین آیتم در OrderedDict) حذف می‌شود
            if len(self.cache) >= self.capacity:
                self.cache.popitem(last=False)
            # کلید و مقدار جدید به کش اضافه می‌شود
            self.cache[key] = value


# Tests:

def test_lru_cache():
    cache = LRUCache(2)

    cache.put(1, 1)
    cache.put(2, 2)
    assert cache.get(1) == 1

    cache.put(3, 3)
    assert cache.get(2) == -1

    cache.put(4, 4)
    assert cache.get(1) == -1

    assert cache.get(3) == 3

    assert cache.get(4) == 4

    print("All test cases passed!")

if __name__ == "__main__":
    test_lru_cache()


#------------------------------------------------
#DOC_TEST
#is good for small codes and not use for any other
#will wrote inside of docstring
#>>> is called prompt
#you must try different situations for test
#example:   
#addfunc.py
"""
in module level:    you can access to all funcs and classes which are inside of module 
>>>add(0,8)
8
"""  
def add(x,y):
    """
    in func level:  you can access to this func just
    >>> add(5,2)
    7
    >>> add(2,'a')
    Traceback (most recent call last):
        ...
    ValueError: n must be exact integer
    >>>raise Exception('message')
    Traceback (most recent call last):
    Exception: message
    """

    return x +y

if __name__ == "__main__":  #you can do this or run with -m doctest or run doctest_addfunc.py or using script
    import doctest
    doctest.testmod()


#for run:
#>>python -m doctest -v mycode.py     

#also we can run doctest from any other module
#doctest_addfunc.py
import addfunc, doctest
doctest.testmod(addfunc)

#also we can use scripts to run doctest
import doctest
print(doctest.script_from_examples(r"""
    Set x and y to 1 and 2.                 #this line will shown as comment
    >>> x, y = 1, 2

    Print their sum:
    >>> print(x+y)
    3
"""))

#---> output is:
"""
# Set x and y to 1 and 2.
x, y = 1, 2
#
# Print their sum:
print(x+y)
# Expected:
## 3
"""


#------------------------------------------------
#UNIT_TEST
#most common tool
#suit choice for django
#why de we write unit test?
#   less debugging
#   increased confidence in changes
#   Imporoved documantation
#   Simpler review 
#   Thoughtful design
#   Fast high-quality release
    
#pen test   (security test)
#test writing will help to product manager


#calculator.py
def add(num1,num2):
    return num1 + num2

def substraction(num1,num2):
    return num1 - num2

def division(num1,num2):
    if num2 ==0:
        raise ValueError("Cant division number to 0 !!!")
    return num1/num2

def multiplication(num1,num2):
    return num1 * num2


#test_calculator.py         (test_<filename>) 
import unittest  
from Calculator import *     #or: import Calculator 
class CalculatorTest(unittest.TestCase):    #(Test<Classname>)
    def test_add(self):                     #(test_<funcname>)
        self.assertEqual(add(3,5),8)
        self.assertEqual(add(1,-8),7)
        self.assertEqual(add(-4,-1),-5)
        self.assertEqual(add(0,1),1)

    def test_division(self):
        self.assertEqual(division(10,2),5.0)
        self.assertEqual(division(4,2),2)    
        self.assertEqual(division(-9,-3),3)    
        self.assertEqual(division(-9,3),-3)
        #test for raise error
        self.assertEqual(division(10,0),ValueError)
        self.assertEqual(division(25,0),ValueError)   
        self.assertRaise(ZeroDivisionError, calculator.division, 4, 0) 


    def test_multiplication(self):
        self.assertEqual(multiplication(2,5),10)
        self.assertEqual(multiplication(-1,8),-8)
        self.assertEqual(multiplication(5,0),0)
        self.assertEqual(multiplication(-25,-2),50)

    def test_substraction(self):
        self.assertEqual(substraction(5,3),2)
        self.assertEqual(substraction(-1,-5),4)
        self.assertEqual(substraction(5,0),5)
        self.assertEqual(substraction(25,25),0)

if __name__ == "__main__":
    unittest.main()


#for run:
#>>python -m unittest test_calculator.py
#>>python -m unittest discover              (will find filds which start with "test" and run automatically)

#because we have 4 test func then we will see 4 "." in terminal
# ....
#if there is a ptoblem in which test func will shown as ..F.
# ..F.

#https://docs.python.org/3.3/library/unittest.html
"""
Method                          Checks that
--------------------------------------------------
assertEqual(a, b)               a == b
assertNotEqual(a, b)            a != b
assertTrue(x)                   bool(x) is True
assertFalse(x)                  bool(x) is False
assertIs(a, b)                  a is b
assertIsNot(a, b)               a is not b
assertIsNone(x)                 x is None
assertIsNotNone(x)              x is not None
assertIn(a, b)                  a in b
assertNotIn(a, b)               a not in b
assertIsInstance(a, b)          isinstance(a, b)
assertNotIsInstance(a, b)       not isinstance(a, b)

assertRaises(exc, fun, *args, **kwds)               fun(*args, **kwds) raises exc
assertRaisesRegex(exc, r, fun, *args, **kwds)       fun(*args, **kwds) raises exc and the message matches regex r
assertWarns(warn, fun, *args, **kwds)               fun(*args, **kwds) raises warn
assertWarnsRegex(warn, r, fun, *args, **kwds)       fun(*args, **kwds) raises warn and the message matches regex r
assertLogs(logger, level)                           The with block logs on logger with minimum level
assertNoLogs(logger, level)                         The with block does not log on logger with minimum level

assertAlmostEqual(a, b)         round(a-b, 7) == 0
assertNotAlmostEqual(a, b)      round(a-b, 7) != 0
assertGreater(a, b)             a > b
assertGreaterEqual(a, b)        a >= b
assertLess(a, b)                a < b
assertLessEqual(a, b)           a <= b
assertRegex(s, r)               r.search(s)
assertNotRegex(s, r)            not r.search(s)
assertCountEqual(a, b)          a and b have the same elements in the same number, regardless of their order.

assertMultiLineEqual(a, b)      strings
assertSequenceEqual(a, b)       sequences
assertListEqual(a, b)           lists
assertTupleEqual(a, b)          tuples
assertSetEqual(a, b)            sets or frozensets
assertDictEqual(a, b)           dicts
"""





#example2:
#person.py
class Person:
    def __init__(self, fname, lname):
        self.fname = fname
        self.lname = lname

    def fullname(self):
        return f"{self.fname} {self.lname}"

    def email(self):
        return f"{self.fullname()}@email.com".replace(' ', '')        

#test_person.py
import unittest
from person import Person

class TestPerson(unittest.TestCase):
    def test_fullname(self):
        p1 = Person("amir", "big")
        p2 = Person("john", "doe")

        self.assertEqual(p1.fullname(), "amir big")
        self.assertEqual(p2.fullname(), "john doe")

    def test_email(self):
        p1 = Person("amir", "big")
        p2 = Person("john", "doe") 

        self.assertEqual(p1.email(), "amirbig@gmail.com")
        self.assertEqual(p2.email(), "johndoe@gmail.com")  

if __name__ == "__main__":
    unittest.main()

#for run:
#>>python -m unittest test_person.py             

#setUp()            will run before run of each unit (func)
#tearDown()         will run after  run of each unit (func)
#setUpClass         will run before run of each class
#tearDownClass      will run after  run of each class
#setUpModule        will run before run of each module
#tearDownModule     will run after  run of each module


#we can make better test_person.py with fixtures:
    
#test_person.py
import unittest 
from person import Person

class TestPerson(unittest.TestCase):
    def setUp(self):
        self.p1 = Person("amir", "big")
        self.p2 = Person("john", "doe")

    def tearDown(self):
        print("Done ... ")

    def test_fullname(self):
        self.assertEqual(self.p1.fullname(), "amir big")
        self.assertEqual(self.p2.fullname(), "john doe")

    def test_email(self):
        self.assertEqual(self.p1.email(), "amirbig@email.com")
        self.assertEqual(self.p2.email(), "johndoe@email.com")     

if __name__ == "__main__":
    unittest.main()               



#------------------------------------------------
#PYTEST
#is unittest with brief methods

#for run:
#>>pytest                   (will run all tests which can find)
#or
#>>pytest -v test_person.py    (will run just this test module)

#also you can run a test module which use unittest with pytest 

from person import Person
import pytest
import time

class TestPErson:
    @pytest.fixture
    def setup23(self):
        self.p1 = Person("amir", "big")
        self.p2 = Person("john", "doe")
        yield 'setup23'     # after this will act like tearDown                 
        print("Done ...")
        time.sleep(2)

    def test_fullname(self, setup23):
        assert self.p1.fullname() == "amir big"
        assert self.p2.fullname() == "john doe"

    def test_email(self, setup23):
        assert self.p1.email() == "amirbig@email.com"
        assert self.p2.email() == "johndoe@email.com"            

#save result of test by pytest in a file
#>>pytest test_one.py --resultlog=result.log

#------------------------------------------------
#raise exception in pytest
#example
#test_calculator.py
class TestOne:
    def test_division(self):
        assert one.division(50, 5) == 10
        with pytest.raise(ZeroDivisionError):
            one.division(3,0)            

#------------------------------------------------
#chunked

#more.py
from itertools import islice
from functools import partial

l = [1, 2, 3, 4, 5, 6, 7]       # [[1, 2, 3],[4, 5, 6],[7]]

def take(iterable, n):
    return list(islice(iterable, n))

def chunked(iterable, n, strict=False):
    iterator = iter(partial(take, iter(iterable), n) , [])
    if strict:
        if n is None:
            raise ValueError("n cant be None when strict is True")
        def ret():
            for chunk in iterator:
                if len(chunk) != n:
                    raise ValueError("iterator is not divisible by n")
                yield chunk
        return iter(ret())
    else:
        return iterator        

#test_more.py
from unittest import TestCase
import more

class TakeTests(TestCase):
    def test_simple_take(self):
        t = more.take(range(10), 5)
        self.assertEqual(t, [0, 1, 2, 3, 4])

    def test_null_take(self):
        t = more.take(range(10), 0)
        self.assertEqual(t, [])

    def test_negative_take(self):
        self.assertRaises(ValueError, lambda: more.take(-3, range(10)))

    def test_take_too_much(self):
        t = more.take(range(5), 10)         
        self.assertEual(t, [0, 1, 2, 3, 4])   

class ChunkedTests(TestCase):
    def test_even(self):
        self.assertEqual(
            list(more.chunked("ABCDEF", 3)), [['A','B','C'],['D','E','F']]
        )

    def test_odd(self):
        self.assertEqual(
            list(more.chunked('ABCDE' , 3)), [['A','B','C'],['D','E']]
        )
  
    def test_none(self):
        self.assertEqual(
            list(more.chunked('ABCDE', None)), [['A','B','C','D','E']]
        )

    def test_strict_false(self):
        self.assertEqual(
            list(more.chunked('ABCDE', 3, strict=False)),
            [['A','B','C'],['D','E']]
        )    

    def test_strict_true(self):
        def f():
            return list(more.chunked('ABCDE', 3, strict=True))
        self.assertRaiseRegex('ValueError, iterator is not divisible bu n', f)
        self.assertEqual(
            list(more.chunked('ABCDEF', 3, strict =True)),
            [['A','B','C'],['D','E','F']]
        )    

    def test_strict_true_size_none(self):
        def f():
            return list(more.chunked('ABCDE', None, strict=True))
        self.assertRaisesRegex(
            ValueError, 'n cant be None when strict is True', f
        )
#------------------------------------------------
#first

#more.py
_marker = object()
def first(iterable, default=_marker):
    try:
        return next(iter(iterable))
    except StopIteration as e:
        if default is _marker:
            raise ValueError("first() was called on an empty iterable, and no"
                             "default value was provided.") from e
        return default


#test_more.py
class FirstTests(TestCase):
    def test_many(self):
        self.assertEqual(more.first(x for x in range(4)), 0)

    def test_one(self):
        self.assertEqual(more.first([3]), 3)

    def test_default(self):
        self.assertEqual(more.first([],"boo"), "boo")  

    import traceback
    def test_empty_stop_iteration(self):
        try:
            move.first([])
        except ValueError:
            formatted_exec = traceback.format_exc()                  
            self.assertIn("StopIteration", formatted_exec)
            self.assertIn("The above exception was the direct cause", formatted_exec)
        else:
            self.fail()    

#way2
class FirstTest(TestCase):
    def test_basic(self):
        cases = [
            (range(4),3),
            (iter(range(4)),3),
            (range(1),0),
            (iter(range(1)),0),
            ({n: str(n) for n in range(5)},4)
        ]   

        for iterable, expected in cases:
            with self.subTest(iterable=iterable):   # will show you which case cause to error
                self.assertEqual(more.last(iterable), expected)             

    def test_default(self):
        for iterable, default, expected in [
            (range(1), None, 0),
            ([], None, None),
            ({}, None, None),
            (iter([]), None, None)
        ]:
            with self.subTest(args=(iterable, default)):
                self.assertEqual(more.last(iterable, default=default), expected)

    def test_empty(self):
        for iterable in ([], iter(range(0))):
            with self.sunTest(iterable=iterable):
                with self.assertRaises(ValueError):
                    more.last(iterable)

    def test_empty_iterable_no_default(self):
        self.assertRaises(ValueError, lambda: more.nth_or_last(range(0),0)) #lambda cause to return error and dont take it in running cmd
                                                                            #without lambda program will be stopped because of error occurs 
                                                                            #but lambda will cause to return error but keep on running program                    
    def test_short(self):
        actual = list(more.interleave([1,4],[2,5,7],[3,6,8]))
        expected = [1,2,3,4,5,6]
        self.assertEqual(actual, expected)


def repeat_each(iterable, n=2):
    return chain.from_iterable(map(repeat, iterable, repeat(n)))

print(list(repeat_each(s))) #--->  ???   


def test_too_short_default(self):
    iterable = ['a','b','c','d']
    n = 5
    with self.assertRaises(ValueError) as exc:
        list(more.strictly_n(iterable, n))

    self.assertEqual(
        "Too few items in iterable (got 4)", exc.exception.args[0]
    )    

    print(exc)
    print(exc.exception)
    print(exc.exception.args)
    print(exc.exception.args[0])


#------------------------------------------------
#only
#more.py
def only(iterable, default=None, too_long=None):
    it = iter(iterable)
    first_value = next(it, default)

    try:
        second_value = next(it)
    except StopIteration:
        pass
    else:
        msg = (
            "Expected exactly one item in iterable, but got {}, {}, "
            "and perhaps more.".format(first_value, second_value)
        )        
        raise too_long or ValueError(msg)
    return first_value    


#test_more.py
class OnlyTests(TestCase):
    def test_defaults(self):
        self.assertEqual(more.only([]), None)
        self.assertEqual(more.only([1]), 1)
        self.assertRaises(ValueError, lambda: more.only([1,2]))

    def test_ustom_value(self):
        self.assertEqual(more.only([], default = '!'), '!')
        self.assertEqual(more.only([1], default= '!'), 1)
        self.assertRaises(ValueError, lambda: more.only([1,2], default='!'))

    def test_custom_exception(self):
        self.assertEqual(more.only([],too_long=RuntimeError), None)
        self.assertEqual(more.only([1], too_long=RuntimeError), 1)
        self.assertRaises(RuntimeError, lambda: more.only([1,2], too_long=RuntimeError))

    def test_default_exception_message(self):
        self.assertRaisesRegex(
            ValueError,
            "Expected exactly one item in iterable, but got foo, bar, and perhaps more",
            lambda: more.only(['foo', 'bar', 'baz'])
        )                
#------------------------------------------------
# test for generator
def test_generator():
    def _gen():
        yield 0
        yield 1
    assertEqual(list(more.always_iterable(_gen())), [0,1])    
#------------------------------------------------
def test_max_split(self):
    for args, expected in [
        (
            ('a,b,c'),
            ['a','b','c']
        ),
        (
            (),

        )
    ]:
        actual = list(more.split_after(*args))
        self.assertEqual(actual, expected)

def test_iterable_just_right():
    iterable = [1,2,3,4,5,6,7,8,9]
    sizes = [2,3,4]
    expected = [[1,2],[3,4,5],[6,7,8,9]]
    actual = list(more.split_into(iterable, sizes))
    assertEqual(actual, expected)        

#------------------------------------------------
#ignore test if python version is old

from unittest import TestCase, skipIf
from sys import version_info

@skipIf(version_info[:2] < (3,8), "accumulate with initial needs +3.8")
def test_initial(self):
    original = list(range(100))
    accumulate(original, initial=100)
    actual = list(more.difference(accumulated, initial=100))
    self.assertEqual(actual, original)

#------------------------------------------------
def value_chain(*args): # *args allow you to send many input to func
    for value in args:
        if isinstance(value, (str, bytes)):
            yield value
            continue
        try:
            yield from value
        except TypeError:
            yield value    

#test:
def test_complex():
    obj = object()
    actual = list(
        more.value_chain(
            (1,(2,(3,))),
            ['foo',['bar',['baz']], 'tic'],
            {'key':{'foo':1}},
            obj,
        )
    )
    expected = [1,(2,(3,)), 'foo', ['bar', ['baz']], 'tic', 'key', obj]
    assertEqual(actual, expected)



#------------------------------------------------
#test a class

class SequenceView(Sequence):
    def __init__(self, target):
        if not isinstance(target, Sequence):
            raise TypeError
        self._target = target

    def __getitem__(self, index):
        return self._target[index]

    def __len__(self):
        return len(self._target)

    def __repr__(self):
        return f"{self.__class__.__name__}({self._target})"                    

#test:
def test_init(self):
    view = more.SequenceView( (1,2,3) )
    self.assertEqual(repr(view), "SequenceView( (1,2,3) )")
    self.assertRaises(TypeError, lambda: more.SequenceView( {} ))

def test_update(self):
    seq = [1,2,3]
    view = more.SequenceView(seq)
    self.assertEqual(len(view),3)
    self.assertEqual(repr(view), "SequenceView([1,2,3])")

    seq.pop()
    self.assertEqual(len(view), 3)

def test_indexing(self):
    seq = ('a','b','c','d','e','f')
    view = more.SequenceView(seq)
    for i in range(-len(seq),len(seq)):
        self.assertEqual(view[i]. seq[i])

def test_abc_methods(self):
    seq = ('a','b','c','d','e','f','f')
    view = more.SequenceView(seq)

    self.assertIn('b', view)
    self.assertNotIn('g',view)
    self.assertEqual(list(iter(view)), list(seq))
    self.assertEqual((list(reversed(view))), list(reversed(seq)))
    self.assertEqual(view.index('b'), 1)
    self.assertEqual(seq.count('f'), 2)








##########################################################################################################
#LOGGING
##########################################################################################################
#the mechanism of recording different intermediate events in a certain process. Recording logs in a software
#application proves helpful for the developer in debugging and tracing any errors in the application logic.

#Logging Levels
#you can generate log message of different severity levels.
'''
level   value   When it's used
------------------------------------------------------------------------------------------
NOTSET    0
DEBUG     10    Detailed information, typically of interest only when diagnosing problems.
INFO      20    Confirmation that things are working as expected.
WARNING   30    An indication that something unexpected happened, or indicative of some problem in the near future (e.g. 'disk space low'). The software is still working as expected.
ERROR     40    Due to a more serious problem, the software has not been able to perform some function.
CRITICAL  50    A serious error, indicating that the program itself may be unable to continue running.
'''

#level of warning display with value of warning level
#just levels with value up to 30 will display (include: warning - error - critical)




import logging

logging.debug('This is a debug message')        #--->  
logging.info('This is an info message')         #--->  
logging.warning('This is a warning message')    #--->  WARNING:root:This is a warning message
logging.error('This is an error message')       #--->  ERROR:root:This is an error message
logging.critical('This is a critical message')  #--->  CRITICAL:root:This is a critical message


#------------------------------------------------
#config

#set level manual
#To log all the messages above DEBUG level, set the level parameter to logging.DEBUG
logging.basicConfig(level = logging.DEBUG)
logging.debug('This message will get logged')   #--->  DEBUG:root:This message will get logged


#record log in file
#To record the logging messages in a file instead of echoing them on the console, use filename parameter.
logging.basicConfig(filename='mycode.log')  #default filemod is 'a' (append to end of a existing file)
logging.basicConfig(filename='mycode.log', encoding = "utf-8")
logging.basicConfig(filename='logs.txt', filemode='w', level=logging.DEBUG) 
logging.warning('This message will be saved to a file')


#change format of log (LogRecord attributes)
logging.basicConfig(format = "%(asctime)s-%(filename)s-%(levelname)s-%(message)s")
#https://docs.python.org/3/library/logging.html#logrecord-attributes

#--------------------------------------
#   Attribute name     Format  Description
#--------------------------------------
#   asctime         %(asctime)s         Human-readable time when the LogRecord was created. By default this is of the form ‘2003-07-08 16:49:45,896’ (the numbers after the comma are millisecond portion of the time).
#   created         %(created)f         Time when the LogRecord was created (as returned by time.time()).
#   filename        %(filename)s        Filename portion of pathname.
#   funcName        %(funcName)s        Name of function containing the logging call.
#   levelname       %(levelname)s       Text logging level for the message ('DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL').
#   levelno         %(levelno)s         Numeric logging level for the message (DEBUG, INFO, WARNING, ERROR, CRITICAL).
#   lineno          %(lineno)d          Source line number where the logging call was issued (if available).
#   message         %(message)s         The logged message, computed as msg % args. This is set when Formatter.format() is invoked.
#   module          %(module)s          Module (name portion of filename).
#   msecs           %(msecs)d           Millisecond portion of the time when the LogRecord was created.
#   name            %(name)s            Name of the logger used to log the call.
#   pathname        %(pathname)s        Full pathname of the source file where the logging call was issued (if available).
#   process         %(process)d         Process ID (if available).
#   processName     %(processName)s     Process name (if available).
#   relativeCreated %(relativeCreated)d Time in milliseconds when the LogRecord was created, relative to the time the logging module was loaded.
#   thread          %(thread)d          Thread ID (if available).
#   threadName      %(threadName)s      Thread name (if available).
#   taskName        %(taskName)s        asyncio.Task name (if available).

#   exc_info        You shouldn't need to format this yourself.     Exception tuple (à la sys.exc_info) or, if no exception has occurred, None.
#   msg             You shouldn't need to format this yourself.     The format string passed in the original logging call. Merged with args to produce message, or an arbitrary object (see Using arbitrary objects as messages).
#   stack_info      You shouldn't need to format this yourself.     Stack frame information (where available) from the bottom of the stack in the current thread, up to and including the stack frame of the logging call which resulted in the creation of this record.
#   args            You shouldn't need to format this yourself.     The tuple of arguments merged into msg to produce message, or a dict whose values are used for the merge (when there is only one argument, and it is a dictionary).




import logging

a = {'name':'amir'}

try:
    print(a['age'])
except KeyError:
    logging.error('this is an error', exc_info = True)  #will save message and exception
    #or
    logging.exception('this is an error')



#------------------------------------------------
#variable data in Logging Message
logging.basicConfig(level=logging.DEBUG)
marks = 120
logging.error("Invalid marks:{} Marks must be between 0 to 100".format(marks))  #--->  ERROR:root:Invalid marks:120 Marks must be between 0 to 100
subjects = ["Phy", "Maths"]
logging.warning("Number of subjects: {}. Should be at least three".format(len(subjects)))   #--->  WARNING:root:Number of subjects: 2. Should be at least three






#root is default logger inside of logging module
#in big projects we need to different loggers for different parts of project
# 

#------------------------------------------------
#handler
#Determines the destination of the logs

#handle types:
#   StreamHandler             sends logging output to streams such as sys.stdout, sys.stderr or any file-like object
#   FileHandler               sends logging output to a disk file
#   NullHandler               does not do any formatting or output. It is essentially a ‘no-op’ handler for use by library developers.
#   WatchedFileHandler        is a FileHandler which watches the file it is logging to. If the file changes, it is closed and reopened using the file name.
#   BaseRotatingHandler
#   RotatingFileHandler       supports rotation of disk log files.
#   TimedRotatingFileHandler  supports rotation of disk log files at certain timed intervals.
#   SocketHandler             sends logging output to a network socket. The base class uses a TCP socket.
#   DatagramHandler           support sending logging messages over UDP sockets.
#   SysLogHandler             supports sending logging messages to a remote or local Unix syslog.
#   NTEventLogHandler         supports sending logging messages to a local Windows NT, Windows 2000 or Windows XP event log
#   SMTPHandler               supports sending logging messages to an email address via SMTP.
#   HTTPHandler               supports sending logging messages to a web server, using either GET or POST semantics.
#   MemoryHandler             supports buffering of logging records in memory, periodically flushing them to a target handler. Flushing occurs whenever the buffer is full, or when an event of a certain severity or greater is seen.
#   QueueHandler              supports sending logging messages to a queue
#   QueueListener             supports receiving logging messages from a queue

import logging

logger = logging.getLogger(__name__)

file_h = logging.FileHandler('example.log')
stream_h = logging.StreamHandler()

file_f = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
stream_f = logging.Formatter('%(name)s - %(levelname)s - %(message)s')

file_h.setFormatter(file_f)
stream_h.setFormatter(stream_f)

file_h.setLevel(logging.ERROR)
stream_h.setLevel(logging.INFO)

logger.setLevel(logging.INFO)   #default is warning

logger.addHandler(file_h)
logger.addHandler(stream_h)


##########################################################################################################
#PDB_MODULE
##########################################################################################################
#pdb(python debugger)
#https://docs.python.org/3/library/pdb.html

import pdb

#it has two way to use
#   1) use inside of shell with command 'pdb'
#   2) use inside of code

#--------------------------------------
#1)inside of shell 
#run a .py file with -m (module) 'pdb'
#>> python3 -m pdb mycode.py
#>> help                show help menu 
#>> help list           show help of 'list' command in pdb
#>> s                   step forward (used for run code line by line)
#                       in step: function will run line by line            
#>> n                   next line (used for run code line by line with output of each line)
#                       in next: function will run by once time
#>> break mycode.py:7   breakpoint (start to debug from lie 7)  
#>> continue            after set breakpoint you shold use it
#>> ll                  list lines (list me all lines of code)
#>> myVar2              you can call any variable inside of yourcode to see the status of it


#Debugger Commands:
#h(elp)         Without argument, print the list of available commands. 
#               With a command as argument, print help about that command. 
#               help pdb displays the full documentation (the docstring of the pdb module).
#w(here)        Print a stack trace, with the most recent frame at the bottom. An arrow (>) indicates the current frame, which determines the context of most commands.    
#d(own)         Move the current frame count (default one) levels down in the stack trace (to a newer frame).
#u(p)           Move the current frame count (default one) levels up in the stack trace (to an older frame).
#b(reak)        With a lineno argument, set a break there in the current file. 
#               With a function argument, set a break at the first executable statement within that function.
#tbreak         Temporary breakpoint, which is removed automatically when it is first hit.
#cl(ear)        With a filename:lineno argument, clear all the breakpoints at this line. 
#disable        Disable the breakpoints given as a space separated list of breakpoint numbers.
#enable         Enable the breakpoints specified.
#ignore         Set the ignore count for the given breakpoint number
#condition      ???
#commands       ???
#s(tep)         Execute the current line, stop at the first possible occasion
#n(ext)         Continue execution until the next line in the current function is reached or it returns.
#unt(il)        Without argument, continue execution until the line with a number greater than the current one is reached.
#               With lineno, continue execution until a line with a number greater or equal to lineno is reached. 
#r(eturn)       Continue execution until the current function returns.
#c(ont(inue))   Continue execution, only stop when a breakpoint is encountered.
#j(ump)         Set the next line that will be executed.
#l(ist)         List source code for the current file. Without arguments,
#ll             List all source code for the current function or frame.
#a(rgs)         Print the arguments of the current function and their current values.
#p              Evaluate expression in the current context and print its value
#pp             Like the p command, except the value of expression is pretty-printed using the pprint module.
#whatis         Print the type of expression.
#source         Try to get source code of expression and display it.
#display        Display the value of expression if it changed, each time execution stops in the current frame.
#undisplay      Do not display expression anymore in the current frame
#interact       ???
#alias          Create an alias called name that executes command
#unalias        Delete the specified alias name.
#!              ???
#run            ???        
#restart        Restart the debugged Python program
#q(uit)         Quit from the debugger
#debug          Enter a recursive debugger that steps through code 
#retval         Print the return value for the last return of the current function.
#Footnotes      ???








#--------------------------------------
#inside of code
pdb.set_trace()         #set breakpoint inside of code
#or
breakpoint()

pdb.run(statement, globals=None, locals=None)
pdb.runeval(expression, globals=None, locals=None)
pdb.runcall(function, *args, **kwds)
pdb.set_trace(*, header=None)
pdb.post_mortem(traceback=None)
pdb.pm()



#--------------------------------------
#student way to trace
print(a)
print("+"*90)





##########################################################################################################
#TIME_COMPLEXITY
##########################################################################################################

#loop
for iter in mylist :
    print(iter)     #---> if len(mylist)==n     O(n)

#nested loop
x = 10
for iter in range(x) :
    for iter2 in mylist :
        print(iter1)    #---> O(2n)  or  O(n**2)   ???

#comparison 
if num == 1 or num ==2 :    #--->  O(2)  
    print("okey")
    
if num in (1, 2) :          #--->  O(1)
    print("okey")
    

#EAFP  (Easier To Ask for Forgiveness Than Permission)    
import timeit
eafp = """s = "345"
try:
    n = int(s)
except ValueError:
    n = 0"""
t = timeit.timeit(eafp)
print(t)    #--->  0.1687019999999393


#LBYL  (Look Before You Leap)
lbyl = """s = "345"
if s.isnumeric():
   n = int(s)
else:
   n = 0"""
t = timeit.timeit(lbyl)
print(t) #--->  0.30682630000001154    

##########################################################################################################
#GOOGLE
##########################################################################################################
#How to Search Google Effectively?

#1. Use quotes to get an "EXACT" match
#=> "your question goes here"


#2. Search within a specific site with site:
#=> site:freecodecamp.org react


#3. Exclude a term from search results with -
#=> how to write components in React -class


#4. Search images of a particular size with imagesize:
#=> cute dog images imagesize:500x600


#5. Search for a particular filetype with filetype:
#=> react tutorial filetype:pdf


#6. Use wildcard * to make searches
#=> the * of money             
#   It will be a bunch of pages that include the phrase such as "the exchange of money", "the use of money", "the role of money", "the psychology of money", and so on.


#7. Combine searches with OR, AND logic
#=> React AND Angular


#8. Filter out searches with AFTER:, BEFORE: or .. between two numbers
#=> React tutorials AFTER:2020 
#   will populate search results published after 2020.
#   add .. between the two numbers you want to search between along


#9. Check out related websites using related:
#=> related:google.com 
#   will fetch all the websites that are similar to Google like Bing, Yahoo, DuckDuckGo, and so on.


##########################################################################################################
#DOCKER
##########################################################################################################
# docker is a tool which let you to run your programms in different environment and adjust them to different environments
# in a developer team someone use python 3.7 but other use 3.5 and the othe one use python 3.6
# as you see there is an incompatibility
# we put dependencies, tools and etc to packet and run packet this packet is container in software deveoplment
# this container will run in every where
# without any dependency to operation system , and running environment

#virtualized systems     ---> hypervisor (like vmware)
#container based systems ---> containizer (like docker)

#virtualized systems >> hardware >> os >> hypervisor >> virtaul machine >> os >> app
#containered systems >> hardware >> os >> containizer>> container       >> app              (-1 level)


# docker has three main part:
# -Orchestration        level-1                 swarm -> manage containers
# -Engine / Daemon      level-2                 for networks and api's and volumes and ...
# -Runtime              level-3                 for containers and images

# client(cli) ---> daemon ---> container ---> stream 

# docker scheme:
# 1- infrastructure (server hardware)                   ===> run os
# 2- host operation system (windows server)             ===> run docker    
# 3- docker                                             ===> run app
# 4- app-a app-b app-c , ...                            ===> run container

# docker architecture:
# Client [CMD/remote api] <---> Host [daemon , (container & images)] <---> registry [hub]


# containers do not interfere (tadakhol) with each other
# with network we can set connection between containers
# To establish communication between two containers we can use network

# in docker ecosystem we say 'image' instead of 'app'
# for example if we run redis database in docker, redis is image in docker
# in docker hub there are some of comman usefull apps to use in your projects in docker

# dockerization do smth to run your app in docker


#--------------------------------------
#IMAGE_VS_CONTAINER
#--------------------------------------
#A Docker Image is an immutable file that contains the source code, libraries, dependencies, tools, 
#and other files required to run the application.

#Docker image contains all the elements that a program needs to run.

#Because of their read-only feature, sometimes these images are also referred to as 'snapshots'; 
#Because they show a program and its virtual environment at a specific time

#Since the images are actually just templates, you can't launch or run them; 
#What you can do is to use that template as a base to build a container

#A container is ultimately just a running image.

#When you create a container, it adds a writable layer on top of the immutable image, meaning you can now modify it.

#Therefore, docker images can contain a series of layers, each of which is different from the other;
    #But they also originate from the previous layer. 
    #Image layers represent read-only files to which a container layer is added after they are used to launch a virtual environment.




#docker container is a virtual run-time environment where users can isolate applications from the main system

#A Docker container is an instance of a running Docker image that can use various configurations to run applications.

#Since the containers are independent, 
    #it creates a strong isolation environment and guarantees that other running containers as well as the backup server will not be interrupted. 
    #Docker claims that these units "provide the most powerful isolation capability in the industry". 
    #So, you don't need to worry about the security of your device when deploying an app.

#Unlike virtual machines (VM) where virtualization happens at the hardware level, containers perform virtualization at the app layer. 
    #They can use the same machine, share its kernel and virtualize the operating system to run independent processes. 
    #This makes containers very lightweight and allows you to have valuable resources at your disposal.


#The difference between Image and container in Docker:
    #Images can exist without containers, while a container needs an image to run.
    #containers depend on images and use them to create a run-time environment and execute a program.

#The main difference between Docker images and Docker containers is that:
    #an image is a static, immutable file that serves as a blueprint for creating containers.
    #Whereas a container is a running instance of an image.
    #Docker images are read-only, meaning they cannot be modified once created.
    #Docker containers are writable, meaning you can modify them while they are running.
    #Any changes made to the container's file system or other resources during runtime are lost when the container is stopped or deleted.
    

#-------------------------------------- 
# step-0
# docker requirements

#in ubuntu:
#set dns(from shecan) to ubuntu 
#>>sudo nano /etc/resolv.conf           
#then add two nameserver which shecan give to list  


#--------------------------------------
# step-1
# install docker



#--------------------------------------
# step-2
# check docker status

#in ubuntu:
#>>docker                                       display docker menu
#>>sudo systemctl status docker                 to check status of docker in ubuntu (Active: active(runnung) - loader: enable)
#>>sudo systemctl start docker                  if Active: deactivate(dead) must start docker service manually
#>>sudo systemctl enable docker                 if loader: disable must enable docker manually
#>>sudo systemctl restart docker                restart docker
#>>sudo systemctl stop postgresql               we can stop service with this command
#>>sudo docker images                           display list of created images

#>>docker help container            show help of container
#>>docker help image                show help image

#>>docker info                      show info about docker

#>>docker system df --format 'table {{.Type}}\t{{.TotalCount}}\t{{.Size}}'          check how much space Docker images take up in the storage pool

#>>docker image inspect <image-name>                display details of image
#>>docker image inspect <image-name>:<tag-name>     display details of image
#>>docker container inspect <container-name>        display details of container








#--------------------------------------
# step-3
# disable root access

#by default for do any command from docker we must have permission of root but we can disable it

#in ubuntu:
#>>sudo groupadd docker
#>>sudo usermd -aG docker $USER
#>>docker images                                will do correct


#--------------------------------------
# step-4
# install apps on container

#>>docker login                     login to your docker account
#>>docker pull <image-name>         for download image
#>>docker run <image-name> 

#-------------
# pull & push
#-------------
#>>docker push <image-name>         for upload image
#>>docker pull <image-name>         for download image
#>>docker pull hello-world
#>>docker pull redis                for redis database (commands are in docker hub)
#>>docker pull <image-name>:<tag-name>          if tag not defined bu default will be 'latest'
#>>docker pull python:3.6.1                     also you can define version as tag-name
#>>docker pull alpine:latest                    last stable version
#>>docker pull alpine:edge                      last update version

#-------------
# create
#-------------
#>>docker create --name <container-name> <image-name>        create a container

#-------------
# run
#-------------
#>>docker container run <image-name>                    we can just write docker run (as shortcut)
#>>docker run <image-name>                              create container and run image (with random name)
#>>docker run --name <container-name> <image-name>      create container and run image (with manual name)
#>>docker run --rm <image-name>                         auto remove after run image (without archive)

#>>docker start <container-name>              start stopped container
#>>docker stop <container-name>               stop running container  
#>>docker restart <container-name>            restart stopped container or restart running container
#>>docker kil <container-name>                kill running container
#>>docker pause <container-name>              pause all proccesses within container
#>>docker unpause <container-name>            unpause paused container  

#>>docker exec <container-name> <command>     run a command in a running container
#>>docker exec python_container ls            because python image in real is a linux system  
#>>docker exec -it python_container bash      will run interactive python bash
#>>docker exec -it python_container sh        will run interactive python shell
#>>docker exec -it redis_container bash       will run interactive redis bash  

#-------------
# run in background
#-------------
#>>docker run -d redis              run container in background
#>>docker run -dit busybox          stay busybox in interactive mode
#>>docker run -tid busybox          or
#>>docker run -itd busybox          or
#>>docker run -itd python           python image also is interactive  (after exit in python not stopped and we can run again by exec)  
#>>docker run -it python            container will stopped after exit in python
#>>docker run python                will exit very soon because not in interactive mode
#>>docker run python sleep 10       10 seconds sleep after running

#-------------
# remove
#-------------
#>>docker rmi <image-name>          remove image
#>>docker rmi <image-id>            remove image by image-id
#>>docker rmi <image-name-1> <image-name-2>             remove multiple images
#>>docker rmi -f <image-name>       force remove

#>>docker rm <container-name>       remove container   
#>>docker rm -f <container-name>    force remove (not sugested) 
#>>docker rm                        display list of containers to remove 
#>>docker rm <container-name-1> <container-name-2>      remove multiple containers 

#>>docker container prune           remove all stopped containers

#>>docker image rm <image-name>     To delete a specific image
#>>docker image prune               remove all unused images

#>>docker system prune              clean up any resources like images, containers, volumes, and networks
#>>docker system prune -a           remove any stopped containers and all unused images

#-------------
# list
#-------------
#>>docker ps                        display list of containers which are already running 
#>>docker ps -a                     display list of containers which also stoped running
#>>docker container ls              list of containers
#>>docker container ls -a           list of all containers also deactivated ones 
#>>docker image ls


#-------------
# save & load
#-------------
#docker save -o <file-name>.tar <image-name>:<tag-name>           save one or more images to a tar archive
#docker load -i <file-name>.tar                                   load an image from a tar archive 


#--------------------------------------
# step-5
# provide os
# we use busybox (simples and lightweihtest linux)
#>>docker pull busybox              download busybox
#>>docker run busybox ls            run ls command in linux shell
#>>docker run -it busybox           run linux shell interactive for work live with linux shell (exit or ctrl+d)









#--------------------------------------
#container life cycle
#--------------------------------------
#                                          |
#                                          | 
#                                          | run                   
#                                          |   
#                                          v
# ---create---> [CREATED] ---start---> [RUNNING] <---pause/unpuase---> [PAUSED]
#                   |                      ^
#                   |                      |
#                   | rm             start | stop
#                   |                      |             
#                   v                      v
#               [DELETED]  <---rm----  [STOPPED]



#--------------------------------------
#image layered architecture
#--------------------------------------

#   container:       runtime
#           -----------------------------                                                
#           |   layer-6     read/write  |                                    
#           -----------------------------                
#   image:           buildtime
#           -----------------------------
#           |   layer-5     read-only   |           install pip                 python
#           |   layer-4     read-only   |           config                      source code
#           |   layer-3     read-only   |           install setup file          change in pip package
#           |   layer-2     read-only   |           setup file archive          change in apt package
#           |   layer-1     read-only   |           os                          base ubuntu layer                       
#           -----------------------------

#--------------------------------------
#restart policy
#--------------------------------------
#   always
#   unless-stop                 restart in all states unless you stop container (by stop container or restart docker)
#   on-failed                   if occures an error in container will restart it
# these three values determine in which states a container has the right to restart itself

#example:
#>>docker run -it --restart always python bash              it will restart after we exit from python bash



#--------------------------------------
#create image with docker file
#--------------------------------------
#define how to work this image 
#for dockerize need to 'Dockerfile' in first step
#Each instruction in Dockerfile present in the docker file represents a layer of the docker image.

#source code -----> Dockerfile -----> docker image build ---> push to dockerhub


#example:
#step-1     create a python fiel "a.py":
print("this image is working...")


#step-2     create a docker file "Dockerfile":
#FROM python                                        set python image as base image
#LABEL maintainer="mongard.anir@gmail.com"          extra info
#LABEL version="1.20"
#WORKDIR /src                                       if not exist create and enter if exist go inside
#COPY  a.py .                                       copy a.py to . (this directory)
#or
#COPY a.py /src                                     copy a.py to /src directory
#CMD ["python", "a.py"]                             what will happen after running this image


#step-3     build image:
#>>docker image build -t <image-name>:<tag-name> .

#>>docker image -a          display all images eventhough caching images with name <none>
#                           these type of images that has not name and are just <none> called 'dangling images'

#>>docker image --filter "dangling=true"                            display all dangling images
#>>docker rmi $(docker image -q --filter "dangling=true")              remove all dangling images
#if an image has some caches with itself they will not remove by upside command
#these image-relate caches wil remove just if we remove the image with docker rmi

#we can also use docker build for build image from docker file:
#>>docker build -t <image-name>:<tag-name> <image-directory>            located in the current folder 
#>>docker build -t mypostgres .


#step-4     push your image to dockerhub
#>>docker image tag <image-name>:<tag-name> <dockerhub-username>/<image-name>:<tag-name>        rename docker image tag
#>>docker login                                             login to your dockerhub account
#>>docker push <new-image-name>:<tag-name>                  push an image or repository to a registery




#   how an image created:
#
#   [con-001] ---> [con-002] ---> [con-003] ---> [con-004] ---> [con-005]
#   [deleted]      [deleted]      [deleted]      [deleted]      [created]
#
#   these are intrmediate containers which are deleted



#---------------------------------
#Dockerfile supports the following instructions:
#---------------------------------
#Instruction    Description
"""
ADD	            Add local or remote files and directories.
ARG	            Use build-time variables.
CMD	            Specify default commands.
COPY	        Copy files and directories.
ENTRYPOINT	    Specify default executable.
ENV	            Set environment variables.
EXPOSE	        Describe which ports your application is listening on.
FROM	        Create a new build stage from a base image.
HEALTHCHECK	    Check a container's health on startup.
LABEL	        Add metadata to an image.
MAINTAINER	    Specify the author of an image.
ONBUILD	        Specify instructions for when the image is used in a build.
RUN	            Execute build commands.
SHELL	        Set the default shell of an image.
STOPSIGNAL	    Specify the system call signal for exiting a container.
USER	        Set user and group ID.
VOLUME	        Create volume mounts.
WORKDIR	        Change working directory.


FROM	to specify the base image we want to start from.
RUN	RUN is used to run commands during the image build process.
ENV	Sets environment variables within the image, making them accessible both during the build process and while the container is running. If you only need to define build-time variables, you should utilize the ARG instruction.
COPY	The COPY command is used to copy a file or folder from the host system into the docker image.
EXPOSE	Used to specify the port you want the docker image to listen to at runtime.
ADD	An advanced form of COPY instruction. You can copy files from the host system into the docker image. You can also use it to copy files from a URL into a destination in the docker image. In fact, you can use it to copy a tarball from the host system and automatically have it extracted into a destination in the docker image.
WORKDIR	It's used to set the current working directory.
VOLUME	It is used to create or mount the volume to the Docker container
USER	Sets the user name and UID when running the container. You can use this instruction to set a non-root user of the container.
LABEL	Specify metadata information of Docker image
ARG	Defines build-time variables using key-value pairs. However, these ARG variables will not be accessible when the container is running. To maintain a variable within a running container, use  ENV instruction instead.
CMD	Executes a command within a running container. Only one CMD instruction is allowed, and if multiple are present, only the last one takes effect.
ENTRYPOINT	Specifies the commands that will execute when the Docker container starts. If you don't specify any ENTRYPOINT, it defaults to “/bin/sh -c”.


FROM
It is used for the base image of a Docker image in your Dockerfile using the FROM command.
If you want to start with a Linux base image, can use ubuntu.
FROM ubuntu:latest          # The base image

MAINTAINER
The Dockerfile MAINTAINER the command is simply used to tell who is maintaining this Dockerfile. 
MAINTAINER   Bikram <admin@gmail.com>

WORKDIR
The WORKDIR instruction specifies what the working directory should be inside the Docker image.
The working directory will be in effect for all commands following the WORKDIR instruction. Here is an example:
WORKDIR    /app

COPY
The Dockerfile COPY command copies one or more files from the Docker host into the Docker image.
The COPY command can copy both a file or a directory from the Docker host to the Docker image.
COPY    /myapp/target/myapp.jar    /app/myapp.jar
This example copies a single file from the Docker host at /myapp/target/myapp.jar to the Docker image at /myapp/myapp.jar .
The first argument is the Docker host path (where to copy from) and the second argument is the Docker image path (where to copy to).
You can also copy a directory from the Docker host to the Docker image. Here is an example:
COPY    /myapp/config/prod    /myapp/config
This example copies the directory /myapp/config/prod from the Docker host to the /myapp/config directory in the Docker image.
You can also copy multiple files into a single directory in the Docker image using the COPY command. Here is an example:
COPY    /myapp/config/prod/conf1.cfg   /myapp/config/prod/conf2.cfg   /myapp/config/
This example copies the two files /myapp/config/prod/conf1.cfg and /myapp/conig/prod/conf2.cfg into the Docker image directory /myapp/config/
Note: Destination directory has to end with a / (slash) for this to work.

ADD
The Dockerfile ADD instruction works in the same way as the COPY instruction with a few minor differences:
The ADD instruction can copy and extract TAR files from the Docker host to the Docker image.
The ADD instruction can download files via HTTP and copy them into the Docker image.
Here are a few Dockerfile ADD examples:
ADD    myapp.tar    /myapp/
This example will extract the given TAR file from the Docker host into the /myapp/ the directory inside the Docker image.
Here is another example:
ADD    http://examplesite.com/myapp.jar    /myapp/

ENV
The Dockerfile ENV command can set an environment variable inside the Docker image.
This environment variable is available for the application that is started inside the Docker image with the CMD command.
Here are a few Dockerfile ENV examples:
ENV    MY_VAR   123
This example sets the environment variable MY_VAR to the value 123 .

RUN
The Dockerfile RUN command can execute command-line executables within the Docker image.
The RUN command is executed during the build time of the Docker image, so RUN commands are only executed once.
The RUN command can be used to install applications within the Docker image or other command-line activities.
Here are a few Dockerfile ENV examples:
RUN apt-get install git -y

ARG
The Dockerfile ARG instruction lets you define an argument that can be passed to Docker when you build the Docker image from the Dockerfile. Here is an example:
ARG tcpPort
When you run the Docker command to build the Dockerfile containing the above ARG instruction, you can pass an argument to the tcpPort an argument like this:
docker build --build-arg tcpPort=8080 .
Notice the --build-arg followed by the tcpPort=8080 . This part sets the tcpPort argument value to 8080.
You can define multiple build arguments using multiple ARG instructions. Here is an example:
ARG tcpPort
ARG useTls
When building the Docker image you must provide values for all of the build arguments. You do so by repeating the --build-arg sections for each argument you want to set. Here is an example:
docker build --build-arg tcpPort=8080 --build-arg useTls=true .
You can set a default value for an ARG so that it becomes optional to provide a value for it when building the Docker image. If the argument is not given a value, it will be given its default value. Here is an example:
ARG tcpPort=8080
ARG useTls=true
If neither the tcpPort nor the useTls the argument is set when building the Docker image for the Dockerfile containing the above ARG instructions, their argument values will be set to 8080 and true .
Arguments declared by ARG are typically referenced elsewhere in your Dockerfile. You reference an ARG an argument like this:
ARG tcpPort=8080
ARG useTls=true
CMD start-my-server.sh -port ${tcpPort} -tls ${useTls}
Notice the two references ${tcpPort} and ${useTls}.
These refer to the declared ARG arguments named tcpPort and useTls .
docker build --build-arg tcpPort=8080

EXPOSE
The Dockerfile EXPOSE instruction opens up network ports in the Docker container to the outside world.
For instance, if your Docker container runs a web server, that web server will probably need port 80 open for any client to be able to connect to it.
Here is an example of opening a network port using the EXPOSE command:
EXPOSE   8080
You can also set which protocol is allowed to communicate on the opened port.
For instance, UDP or TCP. Here is an example of setting the allowed protocol also:
EXPOSE   8080/tcp 9999/udp
If no protocol is set (after the / ), then the protocol is assumed to be TCP.

VOLUME
The Dockerfile VOLUME instruction creates a directory inside the Docker image which you can later mount a volume (directory) to from the Docker host.
In other words, you can create a directory inside the docker image.
e.g. /data which can later be mounted to a directory.
e.g. /container-data/container1 in the Docker host.
The mounting is done when the container is started up.
Here is an example of defining a volume (mountable directory) in a Dockerfile using the VOLUME instruction:
VOLUME   /data

CMD
The CMD command specifies the command line command to execute when a Docker container is started up which is based on the Docker image built from this Dockerfile.
Here are a few Dockerfile CMD examples:
CMD echo Docker container started.
This example just prints the text Docker container started when the Docker container is started.
The next CMD example runs a Java application:
CMD java -cp /myapp/myapp.jar com.jenkov.myapp.MainClass arg1 arg2 arg3

ENTRYPOINT
The Dockerfile ENTRYPOINT instruction provides an entry point for Docker containers started from this Docker image.
An entry point is an application or command that is executed when the Docker container is started up.
ENTRYPOINT java -cp /apps/myapp/myapp.jar com.jenkov.myapp.Main
This example will execute the Java application, main class com.jenkov.myapp.Main when the Docker container is started up, and when the application shuts down, so does the Docker container.

HEALTHCHECK
The Dockerfile HEALTHCHECK instruction can execute a health check command line command at regular intervals, to monitor the health of the application running inside the Docker container.
If the command line command returns a value of 0 when exiting, Docker considers the application and container to be healthy.
If the command line command returns a value of 1, Docker considers the application and container to be unhealthy.
Here is a Dockerfile HEALTHCHECK example:
HEALTHCHECK java -cp /apps/myapp/healthcheck.jar com.jenkov.myapp.HealthCheck https://localhost/healthcheck
This example configures the Java application com.jenkov.myapp.HealthCheck as the healthcheck command. You can use whatever healthcheck command that makes sense to you here.
By default, Docker executes the HEALTHCHECK command every 30 seconds.
However, you can set a custom health check interval if you prefer a different interval longer than the default 30 seconds.
You specify the health check interval using the --interval argument to the HEALTHCHECK instruction. Here is an example that sets the HEALTHCHECK interval to 60 seconds instead:
HEALTHCHECK --interval=60s java -cp /apps/myapp/healthcheck.jar com.jenkov.myapp.HealthCheck https://localhost/healthcheck
If the HEALTHCHECK fails, either because the HEALTCHECK command returns 1, or if it times out.
Docker will retry the HEALTHCHECK command 3 times to see if the Docker container returns to a healthy state, before considering the Docker container unhealthy.
You can override the default 3 retries using the --retries argument to the HEALTHCHECK instruction. Here is an example of setting the number of health check retries to 5:


--------------
FROM

Usage:
FROM <image>
FROM <image>:<tag>
FROM <image>@<digest>
Information:

FROM must be the first non-comment instruction in the Dockerfile.
FROM can appear multiple times within a single Dockerfile in order to create multiple images. Simply make a note of the last image ID output by the commit before each new FROM command.
The tag or digest values are optional. If you omit either of them, the builder assumes a latest by default. The builder returns an error if it cannot match the tag value.

--------------
MAINTAINER

Usage:
MAINTAINER <name>
The MAINTAINER instruction allows you to set the Author field of the generated images.

--------------
RUN

Usage:
RUN <command> (shell form, the command is run in a shell, which by default is /bin/sh -c on Linux or cmd /S /C on Windows)
RUN ["<executable>", "<param1>", "<param2>"] (exec form)
Information:

The exec form makes it possible to avoid shell string munging, and to RUN commands using a base image that does not contain the specified shell executable.
The default shell for the shell form can be changed using the SHELL command.
Normal shell processing does not occur when using the exec form. For example, RUN ["echo", "$HOME"] will not do variable substitution on $HOME.

--------------
CMD

Usage:
CMD ["<executable>","<param1>","<param2>"] (exec form, this is the preferred form)
CMD ["<param1>","<param2>"] (as default parameters to ENTRYPOINT)
CMD <command> <param1> <param2> (shell form)
Information:

The main purpose of a CMD is to provide defaults for an executing container. These defaults can include an executable, or they can omit the executable, in which case you must specify an ENTRYPOINT instruction as well.
There can only be one CMD instruction in a Dockerfile. If you list more than one CMD then only the last CMD will take effect.
If CMD is used to provide default arguments for the ENTRYPOINT instruction, both the CMD and ENTRYPOINT instructions should be specified with the JSON array format.
If the user specifies arguments to docker run then they will override the default specified in CMD.
Normal shell processing does not occur when using the exec form. For example, CMD ["echo", "$HOME"] will not do variable substitution on $HOME.

--------------
LABEL

Usage:
LABEL <key>=<value> [<key>=<value> ...]
Information:

The LABEL instruction adds metadata to an image.
To include spaces within a LABEL value, use quotes and backslashes as you would in command-line parsing.
Labels are additive including LABELs in FROM images.
If Docker encounters a label/key that already exists, the new value overrides any previous labels with identical keys.
To view an image's labels, use the docker inspect command. They will be under the "Labels" JSON attribute.

--------------
EXPOSE

Usage:
EXPOSE <port> [<port> ...]
Information:

Informs Docker that the container listens on the specified network port(s) at runtime.
EXPOSE does not make the ports of the container accessible to the host.

--------------
ENV

Usage:
ENV <key> <value>
ENV <key>=<value> [<key>=<value> ...]
Information:

The ENV instruction sets the environment variable <key> to the value <value>.
The value will be in the environment of all “descendant” Dockerfile commands and can be replaced inline as well.
The environment variables set using ENV will persist when a container is run from the resulting image.
The first form will set a single variable to a value with the entire string after the first space being treated as the <value> - including characters such as spaces and quotes.

--------------
ADD

Usage:
ADD <src> [<src> ...] <dest>
ADD ["<src>", ... "<dest>"] (this form is required for paths containing whitespace)
Information:

Copies new files, directories, or remote file URLs from <src> and adds them to the filesystem of the image at the path <dest>.
<src> may contain wildcards and matching will be done using Go’s filepath.Match rules.
If <src> is a file or directory, then they must be relative to the source directory that is being built (the context of the build).
<dest> is an absolute path, or a path relative to WORKDIR.
If <dest> doesn’t exist, it is created along with all missing directories in its path.

--------------
COPY

Usage:
COPY <src> [<src> ...] <dest>
COPY ["<src>", ... "<dest>"] (this form is required for paths containing whitespace)
Information:

Copies new files or directories from <src> and adds them to the filesystem of the image at the path <dest>.
<src> may contain wildcards and matching will be done using Go's filepath.Match rules.
<src> must be relative to the source directory that is being built (the context of the build).
<dest> is an absolute path, or a path relative to WORKDIR.
If <dest> doesn't exist, it is created along with all missing directories in its path.

--------------
ENTRYPOINT

Usage:
ENTRYPOINT ["<executable>", "<param1>", "<param2>"] (exec form, preferred)
ENTRYPOINT <command> <param1> <param2> (shell form)
Information:

Allows you to configure a container that will run as an executable.
Command line arguments to docker run <image> will be appended after all elements in an exec form ENTRYPOINT and will override all elements specified using CMD.
The shell form prevents any CMD or run command line arguments from being used, but the ENTRYPOINT will start via the shell. This means the executable will not be PID 1 nor will it receive UNIX signals. Prepend exec to get around this drawback.
Only the last ENTRYPOINT instruction in the Dockerfile will have an effect.

--------------
VOLUME

Usage:
VOLUME ["<path>", ...]
VOLUME <path> [<path> ...]
Creates a mount point with the specified name and marks it as holding externally mounted volumes from native host or other containers.

--------------
USER
Usage:

USER <username | UID>
The USER instruction sets the user name or UID to use when running the image and for any RUN, CMD and ENTRYPOINT instructions that follow it in the Dockerfile.

--------------
WORKDIR

Usage:
WORKDIR </path/to/workdir>
Information:

Sets the working directory for any RUN, CMD, ENTRYPOINT, COPY, and ADD instructions that follow it.
It can be used multiple times in the one Dockerfile. If a relative path is provided, it will be relative to the path of the previous WORKDIR instruction.

--------------
ARG

Usage:
ARG <name>[=<default value>]
Information:
Defines a variable that users can pass at build-time to the builder with the docker build command using the --build-arg <varname>=<value> flag.
Multiple variables may be defined by specifying ARG multiple times.
It is not recommended to use build-time variables for passing secrets like github keys, user credentials, etc. Build-time variable values are visible to any user of the image with the docker history command.
Environment variables defined using the ENV instruction always override an ARG instruction of the same name.
Docker has a set of predefined ARG variables that you can use without a corresponding ARG instruction in the Dockerfile.
HTTP_PROXY and http_proxy
HTTPS_PROXY and https_proxy
FTP_PROXY and ftp_proxy
NO_PROXY and no_proxy

--------------
ONBUILD

Usage:

ONBUILD <Dockerfile INSTRUCTION>
Information:

Adds to the image a trigger instruction to be executed at a later time, when the image is used as the base for another build. The trigger will be executed in the context of the downstream build, as if it had been inserted immediately after the FROM instruction in the downstream Dockerfile.
Any build instruction can be registered as a trigger.
Triggers are inherited by the "child" build only. In other words, they are not inherited by "grand-children" builds.
The ONBUILD instruction may not trigger FROM, MAINTAINER, or ONBUILD instructions.

--------------
STOPSIGNAL

Usage:

STOPSIGNAL <signal>
The STOPSIGNAL instruction sets the system call signal that will be sent to the container to exit. This signal can be a valid unsigned number that matches a position in the kernel’s syscall table, for instance 9, or a signal name in the format SIGNAME, for instance SIGKILL.

--------------
HEALTHCHECK

Usage:

HEALTHCHECK [<options>] CMD <command> (check container health by running a command inside the container)
HEALTHCHECK NONE (disable any healthcheck inherited from the base image)
Information:

Tells Docker how to test a container to check that it is still working
Whenever a health check passes, it becomes healthy. After a certain number of consecutive failures, it becomes unhealthy.
The <options> that can appear are...
--interval=<duration> (default: 30s)
--timeout=<duration> (default: 30s)
--retries=<number> (default: 3)
The health check will first run interval seconds after the container is started, and then again interval seconds after each previous check completes. If a single run of the check takes longer than timeout seconds then the check is considered to have failed. It takes retries consecutive failures of the health check for the container to be considered unhealthy.
There can only be one HEALTHCHECK instruction in a Dockerfile. If you list more than one then only the last HEALTHCHECK will take effect.
<command> can be either a shell command or an exec JSON array.
The command's exit status indicates the health status of the container.
0: success - the container is healthy and ready for use
1: unhealthy - the container is not working correctly
2: reserved - do not use this exit code
The first 4096 bytes of stdout and stderr from the <command> are stored and can be queried with docker inspect.
When the health status of a container changes, a health_status event is generated with the new status.

--------------
SHELL

Usage:
SHELL ["<executable>", "<param1>", "<param2>"]
Information:
Allows the default shell used for the shell form of commands to be overridden.
Each SHELL instruction overrides all previous SHELL instructions, and affects all subsequent instructions.
Allows an alternate shell be used such as zsh, csh, tcsh, powershell, and others.

--------------


"""




#--------------------------------------
#add a layer to image
#--------------------------------------
#first create a container
#do changes on container 
#assemble this new layer to image layers as last layer

#>>docker container commit <container-name> <image-name>:<tag-name>         create a new image from a containers change
#or
#>>docker commit -a "amirbig" -m "add a.txt" <container-name> <image-name>:<tag-name> 
#>>docker diff <container-name>                                             inspect changes on a container's file system



#example:
#step-1             run image and create container
#docker run -itd --name py python

#docker exec -it py bash
#>ls
#>touch one.txt
#>echo how are you > one.txt
#>cat one.txt
#>ls
#>exit





#--------------------------------------
#volume
#--------------------------------------
#when we work with containers we have two type of data : 1-non persistence data 2-persistence data
#non persistence    ---->   We don't care if they stay or not
#persistence        ---->   We need them to be saved in any case and not be deleted (like databases)

#we must save data like db to other place after containers
    #to not be deleted when we remove that container

#volumes are preferred mechanism for persisting data generated and used in containers
#you can connect a volume to multiple containers
#what we do on one side we can see result in other side
#This communication is two-way 

#     container                Volume              other-container
#   -------------
#   |   /bin    |
#   |   /code <-|-------------> (DV) <-----------------> []
#   |   /dev    |   
#   -------------

#>>docker volume create <volume-name>       create a new volume 
# in linux   will save at:     /var/lib/docker/volumes/<volume-name>/_data
# in windows will save at:     c:/program data/docker/volumes/<volume-name>  

#>>docker volume ls                         list of created volumes
#>>docker volume rm <volume-name>
#>>docker volume prune                      will delete all volumes which are not connected to containers 
#>>docker -v <volume-host-address>:<volume-container-address>       map pre-created volume in host to container   
#example:
#>>docker run --name mysql-db -v mysql-data:/var/lib/mysql
#or
#>>docker run -it -v python_data:/container_temp_data python bash

# to connect directory of container to volume:
#>>docker run -tid --name <container-name> -v <volume-name>:<target-directory> <image-name>   
  
# example:
#>>docker run -tid --name alp -v v1:/home alpine

# connect to old volume with new contrain
#>>docker run -itd --name alp2 -v v1:/home alpine

#if you stop and remove a contrain - its volue will stand there



#--------------------------------------
#volume share
#--------------------------------------
#we say to a container to use the volume of another container

#to run a new container to use the volume of container-1:
#>>docker run -tid --name <container-name-2> --volumes-from <container-name-1> <image-name> 

#for example:
#>>docker run -tid --name ap2 --volumes-from ap alpine              rw=true / read and write
#or
#>>docker run -tid --name ap2 --volumes-from ap:ro alpine           rw=false/ read only
#>>docker ps -a
#>>docker inspect ap2       ----> mounts: name:v1

#--------------------------------------
#Grep
#--------------------------------------
#grep == Global Regular Expression Print
#use to search and find specific string 
#for search in content
#example:
#docker --help | grep vol               find "vol" in list of docker help



#--------------------------------------
#port forwarding
#--------------------------------------
#A way to free up a port and use it to connect to a container from the outside
#[container 1] <--------(containerport-11)<--->(systemport-1)-------> [SYSTEM PC] <--------(systemport-2)<--->(containerport-22)-------> [container 2]   


#       ----------> (systemport-1) <-----------> (containerport-11) <-----------> [container 1]
#       |
# [SYSTEM PC]
#       |
#       ----------> (systemport-2) <-----------> (containerport-22) <-----------> [container 2]


#docker run -d --name <container-name> -p <system-port>:<container-port> <image-name>

#example:
#docker run -d --name rd -p 3030:6379 redis             6379 is default port of redis


#example:
#we want to connect to a container from system pc

#step-1                     run a new container with port forwarding
#>>docker run -d --name rd -p 3030:6379 redis             create a container from an image with port forwarding
#                                                       3030 ---> 6379
#>>docker ps -a                 to check container status

#step-2                     create a python code to communicate with container
#in mycode.py
#   import redis
#   r = redis.Redis(host='localhost', port=3030, db=0)
#   r.set('name', 'amir')

#step-3                     go inside of container and check communication
#>>docker exec -it rd bash
#>redis cli
#$get name      ---> "amir"



#--------------------------------------
#network
#--------------------------------------
#networking use to connect multiple contrains to each other
#
#   container-1                     container-2
#    10.0.0.3                         10.0.0.4
#       |                                |
#       |                                |
#       |                                |
#   172.31.1.5                      192.168.1.25
#       |                                |              
#       ------------(network)-------------
#

#>>docker network create <network-name>
#>>docker network inspect <network-name>                            can see which containers are connected
#>>docker network ls                                                display list of networks
#>>docker network rm <network-name>
#>>docker create --name <container-name> --network <network-name>
#>>docker network connect <network-name> <container-name>
#>>docker network disconnect <network-name> <container-name>

#example:
#first craete a network
#>>docker network create my_net_1

#second create two container from different image
#>>docker run -itd --name py python
#>>docker run -itd --name ubn ubuntu

#connect to each other of containers
#>>docker network connect abc py
#>>docker network connect abs ubn

#run command from one to the other
#>>docker exec -it py bash 
#>ping ubn



#--------------------------------------
#port vs expose
#--------------------------------------

#expose in docker environment can connect
#port can connect from outside of docker also

#
#
#  container-1              container-2
#      |                        |
#      |                        |
#      |                        |
#      --------------------------
#                 |
#                 |
#             DATA-BASE 
#              [expose]
#               [port] <---------------------------------------- outside of docker
#
#
#

#--------------------------------------
#copy
#--------------------------------------
#copy a file from container to host
#>>docker cp <container-id>:<container-address> <host-address>
#example:
#>>docker cp 3544Be4b3eb:/app/requirements.text .

#copy a file from host to container
#>>docker cp <host-address> <container-id>:<container-address>
#example:
#>>docker cp slm.txt 3544Be4b3eb:/app


#for example:
#   One specific file can be copied TO the container like:
#>> docker cp foo.txt container_id:/foo.txt

#   One specific file can be copied FROM the container like:
#>> docker cp container_id:/foo.txt foo.txt



#example 2:
#If you want to copy files from your host system to the container, you should use docker cp command like this:
#>> docker cp host_source_path container:destination_path

#If you want to copy files from the container to the host system, use this command:
#>> docker cp container:source_path host_destination_path


#example 3:
# (1) From a container to the host
#>> docker cp container_id:./bar/foo.txt .

# (2) From the host to a container
#>> docker exec -i container_id sh -c 'cat > ./bar/foo.txt' < ./foo.txt

# (3) Second approach to copy from host to container:
#>> docker cp foo.txt mycontainer:/foo.txt

# (4) From a container to a container mixes 1 and 2
#>> docker cp container_id1:./bar/foo.txt .
#>> docker exec -i container_id2 sh -c 'cat > ./bar/foo.txt' < ./foo.txt




#--------------------------------------
#logging
#--------------------------------------
#>>docker logs <container-id>                   logs of this container until now (past -> now)   
#>>docker logs -f <container-id>                logs of container and following logs (past -> now -> future)
#>>docker-compose logs

#--------------------------------------
#compose
#--------------------------------------
#docker compose is a tool to run multiple containers by one command



#step-0         install docker compose

#in linux:

#in windows:



#step-1         check the version of compose
#>>docker compose -v                                            after 1.27 is okey


#step-2         create a yaml file
#>>touch docker-compose.yaml                                    name must be this


#step-3         configuration the docker-compose file
#>>nano docker-compose

#and write this code:
"""
services:
    <container-name-1>:
        build:
            context: <Dockerfile-address>       # from this address
        build: .                                # from here
        build:                                  # build from custom Dockerfile
            context: ./dir
            dockerfile: Dockerfile.dev

        image: <image-name-1>
        image: ubuntu
        image: ubuntu:14.04
        image: tutum/influxdb
        image: example-registry:4000/postgresql
        image: a4bc65fd

        user: root                              # specifying user
        user: 0:0                               # specifying both user and group with ids

        labels:
            com.example.description: "Accounting web a
        
        healthcheck:                                  # declare service healthy when `test` command succeed
            test: ["CMD", "curl", "-f", "http://localhost"]
            interval: 1m30s
            timeout: 10s
            retries: 3
            start_period: 40s
        
        args:                                   # Add build arguments
            APP_HOME: app    
            
        depends_on:
            - <container-name>
        depends_on:                             # make sure `db` is alive before starting
            - db
        
        depends_on:
            db:                                  # make sure `db` is healty before starting
                condition: service_healthy       # and db-init completed without failure
            db-init:
                condition: service_completed_successfully    

        links:                                  # makes the `db` service available as the hostname `database`
            - db:database                       # (implies depends_on)
            - redis
        
        external_links:
            - redis_1
            - project_db_1:mysql  
          
        ports: 
            - <host-port>:<container-port>
        ports:
            - "3000"
            - "8000:80"                         # host:container    
        expose:
            - "8000" 
        expose: ["3000"]                        # expose ports to linked services (not to host)
      
        dns: 8.8.8.8                            # DNS servers
        dns:
            - 8.8.8.8
            - 8.8.4.4    
            
        networks:
            - <network-name>    
        
        networks:                               # join a pre-existing network (External network)
            default:
                external:
                    name: frontend
        
        extra_hosts:
            - "somehost:192.168.1.100"
        
        devices:
            - "/dev/ttyUSB0:/dev/ttyUSB0"
        
        environment:                            # environmental variables
            - POSTGRES_DB=postgres
        environment:
            RACK_ENV: development
        environment:
            - RACK_ENV=development
        env_file: .env                          # environment vars from file
        env_file: [.env, .development.env]
       
        volumes:
            - /var/lib/mysql
            - ./_data:/var/lib/mysql
        volumes:
            - "/var/run/postgres/postgres.sock:/var/run/postgres/postgres.sock"
            - "dbdata:/var/lib/postgresql/data"
     
        command: bundle exec thin -p 3000       # command to execute
        command: [bundle, exec, thin, -p, 3000]
        command: "celery -A A worker -l INFO"
        
        restart: always  
        # automatically restart container
        restart: unless-stopped
        # always, on-failure, no (default)
         
        extends:                                # make this service extend another
            file: common.yml  # optional
            service: webapp
        
        entrypoint: /app/start.sh               # override the entrypoint
        entrypoint: [php, -d, vendor/bin/phpunit]

        
    <container-name-2>:
        image: <image-name-2>  


volumes:

networks:
    <network-name-1>:
        driver: <network-type>                          for example 'bridge'
"""

#for example:
"""
services:
    py:
        image: python
    rd:
        image: redis    

""" 



#step-4             run docker-compose file
#>>docker-compose up                            will find docker-compose.yaml file and run it
#>>docker-compose up -d                         will run in detach mode (run in background)
#docker ps -a                                   to check activition of containers

#step-5             stop running docker-compose file and remove all containers of that
#>>docker-compose down


#---------------------------------
#docker compose commands cheat:
#---------------------------------
#>>docker compose version 
#>>docker compose config    
#>>docker compose start
#>>docker compose stop
#>>docker compose restart
#>>docker compose run    
#>>docker compose create  
#>>docker compose attach      
#>>docker compose pause
#>>docker compose unpause
#>>docker compose wait   
#>>docker compose up
#>>docker compose down
#>>docker compose ps
#>>docker compose top 
#>>docker compose events   
#>>docker compose logs
#>>docker compose images
#>>docker compose build      
#>>docker compose push  
#>>docker compose cp       
#>>docker compose exec  


#--------------------------------------
#django dockerize
#--------------------------------------
#>>touch Dockerfile
#>>touch docker-compose.yaml


#https://virgool.io/DockerMe/dockerfile-vsxkrrrcnd34
#Dockerfile refrence:
"""
ADD	        Add local or remote files and directories.
ARG	        Use build-time variables. The only directive that can precede FROM is ARG
CMD	        Specify default commands.
COPY	    Copy files and directories.
ENTRYPOINT	Specify default executable.
ENV	        Set environment variables.
EXPOSE	    Describe which ports your application is listening on.
FROM	    Create a new build stage from a base image.
HEALTHCHECK	Check a container's health on startup.
LABEL	    Add metadata to an image.
MAINTAINER	Specify the author of an image.
ONBUILD	    Specify instructions for when the image is used in a build.
RUN	        Execute build commands.
SHELL	    Set the default shell of an image.
STOPSIGNAL	Specify the system call signal for exiting a container.
USER	    Set user and group ID.
VOLUME	    Create volume mounts.
WORKDIR	    Change working directory.


ARG  CODE_VERSION=latest
FROM ruby:2.2.2                                     # Inheritance (base image)


ENV APP_HOME /myapp
RUN mkdir $APP_HOME
ARG APP_HOME=""
RUN mkdir $APP_HOME


Run commands in strict shell
ENV my_var
SHELL ["/bin/bash", "-euo", "pipefail", "-c"]

# With strict mode:
RUN false                                           # fails build like using &&
RUN echo "$myvar"                                   # will throw error due to typo
RUN true | false                                    # will bail out of pipe
Using shell will turn on strict mode for shell commands.

ENTRYPOINT ["executable", "param1", "param2"]
ENTRYPOINT command param1 param2
Configures a container that will run as an executable.

ENTRYPOINT exec top -b
This will use shell processing to substitute shell variables, and will ignore any CMD or docker run command line arguments.

RUN bundle install
WORKDIR /myapp
VOLUME ["/data"]
# Specification for mount point
ADD file.xyz /file.xyz
COPY --chown=user:group host_file.xyz /path/con

ONBUILD RUN bundle install
# when used with another file


Metadata
LABEL version="1.0"
LABEL "com.example.vendor"="ACME Incorporated"
LABEL com.example.label-with-value="foo"
LABEL description="This text illustrates \
that label-values can span multiple lines."

"""


#in Dockerfile:
"""
FROM python:latest                                  base image

WORKDIR /code                                       work directory (dir of dockerization)

COPY requirements.txt /code/                        copy this file to work directory

RUN pip install -U pip
RUN pip install -r requirements.txt

COPY . /code/                                       copy every thing is in this place to work directory

EXPOSE 8000                                         reserve this port for me (for use of nginx)

CMD ["gunicorn", "A.wsgi", ":8000"]
"""


#in docker-compose.yaml:
"""
services:
    rabbitmq:
        container_name: rabbitmq
        image: rabbitmq:latest
        networks:
            - main
        ports:
            - "5672:5672"
        restart: always

    postgres:
        container_name: postgres
        image: postgres:latest
        environment:                            # environmental variables
            - POSTGRES_DB=postgres
            - POSTGRES_USER=postgres
            - POSTGRES_PASSWORD=postgres
        networks:
            - main
        ports:
            - "5432:5432"                         # port forwarding
        restart: always
        volumes:
            - postgres_data:/var/lib/postgresql/data

    celery_worker:                              # celery has not image
        container_name: celery_worker
        command: "celery -A A worker -l INFO"   # command to run celery
                                                # -A <projectname> -l <level>
        depends_on:
            - app               # container name
            - rabbitmq
            - postgres
        build: .
        environment:
            - C_FORCE_ROOT="true"
        networks:
            - main
        restart: always

    app:
        build: .
        command: sh -c "python manage.py migrate && gunicorn A.wsgi -b 0.0.0.0:8000"       # you can connect to 8000 from all ports  
        container_name: app
        volumes:
            - .:/code/
        depends_on:
            - postgres          # container name
            - rabbitmq
        expose:
            - "8000"
        networks:
            - main
        restart: always            
            
    nginx:
        container_name: nginx
        command: nginx -g 'daemon off;'
        depends_on:
            - app
        image: nginx:latest
        networks: 
            - main
        ports:
            - "80:80"  
        restart: always
        volumes:
            - ./nginx.conf:etc/nginx/nginx.conf             replace default nginx conf file with my nginx.conf file

networks:
    main:

volumes:
    postgres_data:

"""

#>>docker-compose up -d
#>>docker ps -a
#check 127.0.0.1:80  to see nginx running
#>>docker logs nginx                            container name 


#--------------------------------------
#Dockerignore
#--------------------------------------
What is a .dockerignore file?
A .dockerignore is a configuration file that describes files and directories that you want to exclude when building a Docker image.

Usually, you put the Dockerfile in the root directory of your project, but there may be many files in the root directory that are not related to the Docker image or that you do not want to include. .dockerignore is used to specify such unwanted files and not include them in the Docker image.



Benefits of using a .dockerignore file
The .dockerignore file is helpful to avoid inadvertently sending files or directories that are large or contain sensitive files to the daemon or avoid adding them to the image using the ADD or COPY commands.

#   -Cache invalidation
#   -Reduces the image size
#   -Security Issues



#What if we don't use .dockerignore?
#In this case, you send all the things you don't need to Docker Daemon and they will be copied to the Image file system.



#.dockerignore syntax:

#   -Comments
# This is just a comment.

#   -Using wildcards
*/target
**/target
target?

#   -Specifying exceptions
*.md
!README.md                                  the ! exception character


#.dockignore refrence:
"""
passphrase.txt
logs/
.git
*.md
.cache

# Ignore all files and directories that start with "tmp
tmp*

# Include the file "config.ini" in the build context
!config.ini

# Exclude the directory "logs" and its contents
logs/

# Exclude all files and directories in the "docs" directory, but include the directory itself
/docs/**

# Exclude all files and directories that end with ".log"
*.log

"""


#.dockignore example:
"""
__pycache__
*.pyc
*.pyo
*.pyd
.Python
env
pip-log.txt
pip-delete-this-directory.txt
.tox
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.log
.git
.mypy_cache
.pytest_cache
.hypothesis
"""






#--------------------------------------
#cloud container
#--------------------------------------
#Cloud containers are actually containers that are hosted in an online environment; 
#In this way, users can access them from anywhere in the world; 
#However, application processes or microservices within cloud containers are separate from the cloud infrastructure.

#In the world of information technology, the concept of cloud has replaced traditional computing and storage technologies.
#Cloud refers to a set of Internet-based services that allow users to access computing resources, storage and
#applications without the need for physical hardware and complex software. 
#   One of the technologies that has gained high popularity in the cloud internet platform and has a lot of 
#   use is the cloud container.


#A cloud container is designed to virtualize and isolate an application in the cloud.

#In other words, 
#   by getting the cloud container service, 
#       you can use a Docker server to carry out your work. 
#       Using this service will advance the work process of companies that need to use containers. 
#       Note that the cloud container service must be provided on the cloud system; 
#       That means the shared files must be on the cloud service.

#Container cloud services can be shared in private and public cloud spaces. 
#These services can be one of the best options for using the Docker platform in a collection.

#The main difference between cloud container and virtual machines is:
# that this service is more optimized.
# Another advantage of the cloud container is its portability. 
# You can store a Docker image or container on a server, and access it from any other device.

#Containerization technology in the cloud environment is:
#   a method to run and manage programs and services in the cloud environment. 
#   This technology uses the concept of containers, which is a way of organizing software. 
#   In this method, each program and all its dependencies are executed in an independent container.


#The use of containers in the cloud environment facilitates the management and transfer of applications and 
#services between different cloud environments. Also, by using container management tools such as Docker and 
#Kubernetes, facilities such as scalability, fault tolerance, optimal resource management and optimal use of 
#cloud infrastructure are provided.



#Advantages of using cloud containers:
#   - Independent and portable environment
#   - Flexibility and scalability
#   - Speed and efficiency
#   - Easy to manage and configure
#   - Integrated environment


#   https://hamravesh.com/
#   https://www.arvancloud.ir/fa



#--------------------------------------
#proxy
#--------------------------------------
#   you <--------> proxy <--------> internet

#two comman type of proxy:
#   - forward proxy
#   - reverse proxy

#forward proxy:
#
#
# -----------------------------------------
# |  user1 -------                        |                      
# |              |                        |                         ----------> webserver 1    
# |              v                        |                         |    
# |  user2 -------------> forward proxy -------> internet ----------> 
# |              ^                        |                         |           
# |              |                        |                         ----------> webserver 2           
# |  user3 -------                        |                
# -----------------------------------------
#

#some of features:
# - protects the clients online identity
# - bypasses browsing restrictions
# - blocks access to certain content

#reverse proxy:
#   (like nginx)
#
#
#                                        -----------------------------------------------
#   user1 -------                        |                                             |         
#               |                        |                         ------> webserver 1 |   
#               v                        |                         |                   |         
#   user2 -------------> internet -----------> reverse proxy ------>                   |         
#               ^                        |                         |                   | 
#               |                        |                         ------> webserver 2 |           
#   user3 -------                        |                                             | 
#                                        -----------------------------------------------
#

#some of features:
# - protects a website
# - load balancing
# - Scaling servers in terms of number
# - caching 
# - handles ssl encryption

# ingress service:
# someones called ingress service to reverse proxy 
# ingress service [edge servers: [api gateway] & [load balncer] ]

##########################################################################################################
#KUBERNETES
##########################################################################################################
#kubernetes is a greeck word which is meaning helmsman (nakhoda) in ship
#some people use "K8s" in place of kubernetes
#created by google in 2014:
#a tool for group containers in logical units:
# 1-pods
# 2-nodes (master node(control plane) + worker nodes(minions))  
# 3-namespace

#master nodes are Responsible for management worker nodes and pods in a cluster
#master node must be redundant (one active & one standby)

#this tool provide { scalability - flexibility - portability } 
#it manages creating and running of containers

#If we had few containers we can handle them with docker compose
#else we must use kubernetes

#utilities of kubernetes:
    # manage load balancing of input traffic to containers
    # orchestration of data storage
    # control number of active containers and their sizes
    # control usage of sources like cpu/memory for each of containers
    # control security data like auth token / ssh key 

#kubernetes duties:
    # a scheduler for running containers continual      scheduler
    # a manager for running applications                controller (kube controller manager)
    # an orchestrator for microservice applications     
        
#admin user ---> master node ---> kubectl ---> api server 
#                                               |
#                                               |
#                                          master node
#                                               |
#                                               |
#                                               ----------> etcd (kubeconfig)
#                                               |         
#                                               ----------> controller
#                                               |
#                                               ----------> scheduler
#                                               |
#                                               |
#                                          worker node
#                                               |
#                                               |
#                                               ----------> kubelet
#                                               |
#                                               ----------> kube-proxy  <---------- internet <---- end user                      


 
##########################################################################################################
#GIT
##########################################################################################################
#https://www.javatpoint.com/git
#https://www.javatpoint.com/git-modules-in-python



##############
#Git Commands:
##############

#>>git --version                            check the current version of git


# HEAD is the last commit

#>>git annotate <filename>

#-------------
#Git Add
#-------------
#>>git add .
#>>git add <filename>
#>>git add -A
#>>git add "*.html"

#-------------
#Git Archive
#-------------

#-------------
#Git Branch
#-------------
#>>git branch <newbranchname>               	        Create a new branch
#>>git branch
#>>git branch <branchname>                              Create a new branch with the specified name
#>>git branch - <branchname>
#>>git branch -a                                        List all branches (local and remote)
#>>git branch -av                                       List all branches (Local and Remote)
#>>git push origin --delete [branch name]	            Delete a remote branch
#>>git branch -c                                        Copy a Git branch.
#>>git branch -d <branchname>
#>>git branch -m <branch-name> <new-branch-name>        Rename a Git branch.
#>>git branch -M <branchname>                           Create main branch instead of master branch
#>>git branch -r                                        Display a list of the remote branches in your Git repository.
#>>git push <remote> --delete <remote-branch-name>      Delete a remote Git branch.
#>>git branch -d <branchname>                           Delete a branch

#-------------
#Git Bisect 
#-------------
#[used for debug]
#>>git bisect start 
#>>git bisect bad
#>>git bisect good <commit-id>
#>>git bisect reset

#-------------
#Git Blame
#-------------
#>>git blame <filename> -L 8             Viewing who wrote from the mentioned line to the end of the file
#>>git blame <filename> -L 8,10
#>>git blame -L 1,10 <filename>

#-------------
#Git Clone
#-------------
#>>git clone git@gitlab.com:<projectownername>/<projectname>.git
#>>git clone <repository-url> --origin <remotename>     Clone a repository and name the remote (<name>). If you do not wish to name the remote, Git will provide the default name origin.
#>>git clone <repository-url> --no-tags                 Clone a repository without copying the repo’s tags.
#>>git clone <repository-url> --depth <depth>           Clone a repository with a specified number of commits (<depth>). 

#-------------
#Git Clean
#-------------
#>>git clean                                            remove the untracked files from the working directory

#-------------
#Git Commit
#-------------
#>>git commit -m "Title"
#>>git commit -m "<message>"
#>>git commit -m "Title" -m "Description"
#>>git commit -am "<message>"                           Commit changes of the file that Git already recognized, without the need to add             
#>>git commit -s <tagname> -m "<message>"
#>>git commit -a                                        Add all modified and deleted files in your working directory to the current commit.
#>>git commit --amend                                   Amend a Git commit. Edit a Git commit message by adding a message in quotation marks after the command.

#-------------
#Git Config
#-------------
#>>git config --global user.name "<username>"
#>>git config --global user.email "<email>"
#>>git config --global color.ui auto                    set automatic command line coloring for Git for easy reviewing
#>>git config --global --list	                        Get global config
#>>git config --list                                    View all of your Git config settings including the local, global, and system levels.
#>>git config --global user.signingkey sec

#-------------
#Git Checkout
#-------------
#[Use to move the HEAD pointer to a specific commit or switch between branches]
#>>git checkout master
#>>git checkout <branchname>
#>>git checkout -b <newbranchname>                          Create a new branch and switch to it
#>>git checkout -b [branch name] origin/[branch name]	    Clone a remote branch and switch to it
#>>git checkout <commit-id>
#>>git checkout <tagname>
#>>git checkout -- page3.html                               restore to last commit (to before any changes) 
#>>git checkout -- <filename>.<fileformat>
#>>git checkout -- [file-name.txt]	                        Discard changes to a file
#>>git checkout <reflogcode>
#>>git checkout tags/<tagname>
#>>git branch -m [old branch name] [new branch name]	    Rename a local branch
#>>git checkout -	                                        Switch to the branch last checked out
#>>git checkout HEAD fileName

#-------------
#Git Cherry Pick
#-------------
#>>git cherry-pick <commit-id>                              bring one commit to pointed place by HEAD in current branch 

#-------------
#Git Ci Tool
#-------------
#>>git citool                                               you can review all the modified files In graphical interface 

#-------------
#Git Diff
#-------------
#>>git diff HEAD                                    Different of "current state" vs "state of the last commit"
#>>git diff --staged                                Different of "current state" vs "stage state"
#>>git diff --cached                                Display the changes of the files that entered the stage
#>>git diff <branchName>                            Different of "current state" vs "branch last commit(HEAD)"
#>>git diff <first-branch> <second-branch>  
#>>git diff <commit1> <commit2>                     Different of two commits 

#-------------
#Git Fetch
#-------------
#>>git fetch

#-------------
#Git Garbage Collection
#-------------
#>>git gc                                               cleanup unnecessary files Also it will optimize your local repository

#-------------
#Git GUI
#-------------
#>>git gui                      is a user interface

#-------------
#Git Help
#-------------
#>>git help                     To start with git help
#>>git help -a                  a list of all git commands
#>>git help <command name>
#>>git help blame

#-------------
#Git Initialize
#-------------
#>>git init
#>>git init [your directory]

#-------------
#Git Log
#-------------
#>>git log
#>>git log --follow <filename>
#>>git log branchB..branchA                 show the commits on branchA that are not on branchB
#>>git log --stat -M                        show all commit logs with indication of any paths that moved
#>>git log --summary	                    View changes (detailed)
#>>git log --oneline	                    View changes (briefly)
#>>git log --oneline -N
#>>git log -p                               view all difference of changes of each commit
#>>git log --since='3 days ago'
#>>git shortlog                             summarise the git log command output
#>>git log --decorator                      Display history of all changes along with tag information

#-------------
#Git Merge
#-------------
#>>git merge <branchname>                       Merge a branch into the active branch
#>>git merge [source branch] [target branch]	Merge a branch into a target branch
#>>git merge --abort                            Aborts the merge process and restores the project’s state to before the merge was attempted. This works as a failsafe when a conflict occurs.
#>>git merge --continue                         Attempt to complete a merge that was stopped due to file conflicts after resolving the merge conflict.
#>>git merge --squash                           Combine all changes from the branch being merged into a single commit rather than preserving them as individual commits.
#>>git merge --no-ff                            Creates a merge commit instead of attempting a fast-forward.

#-------------
#Git Move
#-------------
#>>git mv [existing-path] [new-path]            change an existing file path and stage the move
#>>git mv <old-file-name> <new-file-name>       is a rename command
#>>git mv <OldFileName.py> <NewFileName.py>     Change file name (need commit after this command)

#-------------
#Git Notes
#-------------
#>>git notes add -m '<note>' <commit-id>        add annotations with information that was not available at the time a commit was written.

#-------------
#Git Push
#-------------
#>>git push -u origin --all
#>>git push -u origin --tags
#>>git push
#>>git push --set-upstream origin <newbranchname>
#>>git push --tags
#>>git push --delete origin <tagname>                       Remove the tag on the repository
#>>git push origin master                                   Sends the master branch to origin
#>>git push origin <tagname>
#>>git push origin --tags
#>>git push <remote> --all                                  Push all local branches to a specified remote.

#-------------
#Git Pull
#-------------
#>>git pull
#>>git pull origin master           receives the master branch from origin    
#>>git pull --no-tags               Do not fetch tags.

#-------------
#Git Remote
#-------------
#>>git remote rename origin older-origin
#>>git remote add origin git@gitlab.com:<username>/<projectname>.git
#>>git remote
#>>git remote -v
#>>git remote add pb https://github.com/<projectownername>/<projectname>
#>>git remote add origin https://....                                               Add remote with specified address and origin name
#>>git remote set-url origin ssh://git@github.com/[username]/[repository-name].git	Set a repository's origin branch to SSH
#>>git remote remove <remotename>                                                   remove a remote
#>>git remote rename oldName newName                                                rename a remote

#-------------
#Git Reset
#-------------
#>>git reset <filename>                     Remove the file from the stage mode (and send to working directory - before stage) 
#>>git reset --soft HEAD~3
#>>git reset <commit>                       commit, while the changes are unstagedvert to the indicated commit, while the changes are unstaged 
#>>git reset --hard <commit-hash>  
         
#-------------
#Git Revert
#-------------
#>>git revert <commit-hash>                  Revert commit changes

#-------------
#Git Remove
#-------------
#>>git rm <filename>                        Delete the file from git and from the file system
#>>git rm --cached <filename>
#>>git rm -r [file-name.txt]	            Remove a file (or folder)

#-------------
#Git Rebase
#-------------
#>>git rebase <branchname>

#-------------
#Git Restore
#-------------
#>>git restore --staged <file name>

#-------------
#Git Reflog
#-------------
#>>git reflog

#-------------
#Git Switch
#-------------
#>>git switch <branch-name>             Navigate between the branches
#>>git switch -c <newbranchname>        Create a new branch

#-------------
#Git Stash
#-------------
#>>git stash save "<title>"
#>>git stash list               list stack-order of stashed file changes
#>>git stash show               View the content of your most recent stash. 
#>>git stash
#>>git stash apply
#>>git stash@{1}
#>>git stash pop            write working from top of stash stack
#>>git stash drop           discard the changes from top of stash stack
#>>git stash clear	        Remove all stashed entries

#-------------
#Git Status
#-------------
#>>git status
#>>git status -u            get a list of individual files in untracked directories

#-------------
#Git Show
#-------------
#>>git show <commit-id>
#>>git show head            will show you commit information, diffstat, and patch of the tip of the current branch
#>>git show-branch          View all branches and their commit
#>>git show <tagname>       show details of tag

#-------------
#Git Tag
#-------------
#>>git tag                                      show all tags
#>>git tag -n                                   list of all tags with their description 
#>>git tag <tagname>
#>>git tag -d <tagname>
#>>git tag -l "v*"
#>>git tag add -a <tagname> -m "<message>"
#>>git tag add -a <tagname> <commit-id>
#>>git tag -a tagName -m "description"          Adding a tag with the specified name and description
#>>git tag -s <tagname> -m "<message>"

#-------------
#Git Whatchanged
#-------------
#>>git whatchanged     to see commit logs with diff

#-------------
#Git Work Tree
#-------------
#>>git worktree add





#   WD    = Working Directory
#   STG   = Staging (index)
#   L-REP = Local Repository
#   R-REP = Remote Repository

#--------------------------------------------------------
# WD             STG             L-REP             R-REP
#--------------------------------------------------------   
# O ----add-----> O 
# O <---reset---- O
#                 O ----commit---> O 
# O --------commit-am------------> O
#                                  O -----push-----> O
#                                  O <----pull------ O
# O <---------pull---------------- O
#                                  O <----fetch----- O





################
#Git Operations:
################

#-------------
#check installing of git:
#-------------
#>> git                                      check installing
#>> git --version                            check the current version of git


#-------------
#to start a new project:
#-------------
#create .gitignore file in project root
#>> git init
#>> git status

#add a file to git (from 'working directory' to 'stage')
#>> git add requirements.txt                        add only a file
#>> git add .                                       add all files in current directory
#or
#>> git add -A                                      add all files to 'stage'
#>> git commit -m "init project"                    commit all stage files (from 'stage' to 'repository')

#>> git coomit -m "adding requirements.txt"         commit after staging just one file with message about that



#>>git log            to check what we done
#>>ctrl + z           to exit from git log page


#-------------
#find different of 
#-------------
#>>git diff HEAD                                    Different of "current state" vs "state of the last commit"
#>>git diff --staged                                Different of "current state" vs "stage state"

#>>git diff <branchName>                            Different of "current state" vs "branch last commit(HEAD)"
#>>git diff <first-branch> <second-branch>  
#>>git diff <commit1> <commit2>                     Different of two commits 

#-------------
#turn back
#-------------
#from 'staging' to 'working directory'
#>>git reset <file-name>                              Remove the file from the stage mode (and send to working directory - before stage)     

#cancel change and 
#>>git checkout -- <file-name>                      restore to last commit (to before any changes)



#-------------
#author identity config
#-------------
#>>git config --global user.email "you@example.com"
#>>git config --global user.name "Your Name"
#>>git config --list


#-------------
#create a new branch
#-------------
#>> git branch                              show me list of branches
#>> git branch fixpages                     create a new branch with name fixpages
#>> git branch <new-branch-name>            create a new branch
#>> git branch      
#      *master      (you are on this branch)
#       fixpages    
#>> git checkout <branch-name>              change your branch
#>> git checkout fixpages                   go to fixpages branch and do some changes

#>> git branch 
#       master
#       *fixpages
#>> git checkout master                     go to master branch
#>> git merge fixpages                      merge fixpages branch to this branch


#we should delete our branches which are finished after merging
#>>git branch -d <branchname>                           Delete a branch



#-------------
#key
#-------------
#>>gpg --list-keys
#>>gpg --gen-key        
#will ask your real name and email and password for gpg generator
git config --global user.signinkey      list of your signin keys
gpg --list-secret-keys --keyid-format LONG
/home/mehrdad/.gnupg/pubring.kbx
--------------------------------
sec   rsa3072/DA21D164657A8ADA 2024-08-10 [SC] [expires: 2026-08-10]
      C9DB9AF7FDB6A78345E21B7DDA21D164657A8ADA
uid                 [ultimate] mehrdad abdi <mehrdadabdi97@gmail.com>
ssb   rsa3072/D635967BB3B73D89 2024-08-10 [E] [expires: 2026-08-10]

git config --global user.signinkey DA21D164657A8ADA


#>>ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/home/mehrdad/.ssh/id_rsa): mykey
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in mykey
Your public key has been saved in mykey.pub
The key fingerprint is:
SHA256:6CWQni2LTJDFE+Mnk0Nel+OMgoHuTsFfLwYpKKvOUgQ mehrdad@mehrdad-VMware-Virtual-Platform
The key's randomart image is:
+---[RSA 3072]----+
|..=.. ..         |
|E*o+ oo          |
|*+B.=+ .         |
|+*oO.=o.         |
|oo=.* = S        |
|.=.o * +         |
|+.o o o          |
|+.               |
|oo               |
+----[SHA256]-----+


#>>ssh
usage: ssh [-46AaCfGgKkMNnqsTtVvXxYy] [-B bind_interface]
           [-b bind_address] [-c cipher_spec] [-D [bind_address:]port]
           [-E log_file] [-e escape_char] [-F configfile] [-I pkcs11]
           [-i identity_file] [-J [user@]host[:port]] [-L address]
           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]
           [-Q query_option] [-R address] [-S ctl_path] [-W host:port]
           [-w local_tun[:remote_tun]] destination [command [argument ...]]




#-------------
#work with remotes like gitlab/github/gitkraken
#start to work on an exisiing project on github:
#-------------

#first get all project to your system
#>>git clone <clone-address-from-github>            will create a directory for cloned project

#do what you want...

#try to send your maked changes to remote repository
#>>git push origin master                           push my changes to origin (in github) from master (in local) 
# in this step will give username and password of your github account


#maybe other persons doing some chanegs on remote repository...

#you must be update your repository in local from remote repository
#>>git pull origin master                           get last changes from origin (in github) to master (in local) 
# to get last version of project from github



#-------------
#work with remotes like gitlab/github/gitkraken
#create a new repository on github from linux terminal:
#-------------
#first you need to install github cli on your linux
#>>sudo apt update
#>>sudo apt install gh

#then login to github with github cli
#>>gh auth login

#then create a remote repository
#>>gh repo create my-newrepo --public --source=. --remote=upstream --push



#-------------
#work with remotes like gitlab/github/gitkraken
#push exist project on an empty created repository in github from linux terminal:
#-------------
#first you must set ssh-key (generate from linux terminal and copy to github settings)

#>>git remote                               list of remotes
#empty

#>>git remote add origin git@github.com:mehrdadabdi1012/Django-Trello.git 
          
#>>git remote
#       origin
#>>git remote -v
#       more details...


#(alternative)
#   first change your branch to main
#   create a new branch with name of main for last status of projects before upload
#   >>git branch main
#   >>git checkout main
# or 
#   you can change default branch of repository in github
#   description is under this section


#>>git push origin main                   push my main on origin in remote (which i add)



#-------------
#change default branch of repository in github
#-------------
#select your repository and go to setting tab for repository and change default branch and update
#and you can delete any branch in github which is not default branch




#>>git tag                                                     list of created tags
#>>git tag -l "v*"                                             list of created tags which is start with v..  (filter on versions)
#>>git tag -a v2.0 -m 'sadsadsadsa fdfsfsdfsd dsfdsfdsf'       create a new tag (for current commit)
#>>git tag -a v1.8 <commit-id> -m 'sdassad'                    create a tag for old commit that i find from git log
#>>git push origin --tags                                             push tags on origin in github 




#-------------
#change level from Working Directory to Staging
#-------------



##############
#ohmyzsh for terminal
##############
#first install zsh:
#>>sudo apt install zsh
#>>zsh --version

#second install ohmyzsh
#>>sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"


##############
#how to read git diff
##############
#   diff --git a/README.md b/README.md
#   index f808522..f08e544 100644
#   --- a/README.md
#   +++ b/README.md
#   @@ -1 +1,2 @@                                                   (line 1 in old changed to line 1,2 in new)
#   +We have just added this line to our file.                      (to describe what happend in new file)

# a is old file and shown with '-' minus
# b is new file and shown with '+' plus



##############
#Download all repositorries of a user:
##############
#this can just download public repositorries
#>> pip install gitpython

import requests
from git import Repo


def get_user_repositories(username):
    url = f"https://api.github.com/users/{username}/repos"
    response = requests.get(url)
    if response.status_code == 200:
        repositories = response.json()
        return [repo["html_url"] for repo in repositories]
    else:
        return []


def clone_user_repositories(username):
    url = f"https://github.com/{username}/"
    repositories = get_user_repositories(username)
    for repo_name in repositories:
        try:
            folder_name = repo_name.split("/")
            folder_name = folder_name[len(folder_name) - 1]
            Repo.clone_from(repo_name, folder_name)
            print(f"Repository cloned: {repo_name}")
        except Exception as e:
            print(f"Failed to clone repository {repo_name}: {e}")


username = "amirshnll"
clone_user_repositories(username)



##########################################################################################################
#SOLID
##########################################################################################################
#Five general principle (rule):
#   S - Single Responsibility Principle  (SRP)
#   O - Open/Closed Principle            (OCP)
#   L - Liskov Substitution Principle    (LSP)
#   I - Interface Sergregation Principle (ISP)
#   D - Dependency Inversion Principle   (DIP)

#If you comply, your program will be Scalable

#------------------------------------------------
#principle 1)
#Single Responsibility Principle
#each class (or function) must be responsible for just one task

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def show(self):
        return f"{self.name} is {self.age} years old"    

    def db_save(self):
        pass

p1 = Person("amir", 28)    

#this class has two task(attribute management - save objects in database)
#you must chage this class to comply the first principle



class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def show(self):
        return f"{self.name} is {self.age} years old"    

class DB:
    def db_save(self):
        pass

p1 = Person("amir", 28)    
#now each of classes are responsible for just one task and each of they will be Independent from another one
#when you want to make some changes in each other will not effect on the other


#------------------------------------------------
#principle 2)
#Open/Close Principle
#Software entities should be open for extension but close for modification

class Animal:
    def __init__(self, type):
        self.type = type

    def sound(self):
        if self.type == 'cat':
            print("Meow...")
        elif self.type == 'dog':
            print("Woof...")

mark = Animal("snake")
mark.sound()    #--->  empty

#to do this we can change sound method...

class Animal:
    def __init__(self, type):
        self.type = type

    def sound(self):
        if self.type == 'cat':
            print("Meow...")
        elif self.type == 'dog':
            print("Woof...")
        elif self.type == 'snake':
            print("Hiss...")

mark = Animal("snake")
mark.sound()    #--->  empty

#but we must not change the method of class .. we just can extend new methods to class if they are needed
#its better to have another classes for each of animal types

class Animal:
    def __init__(self, name):
        self.name = name

    def sound(self):
        pass

class Cat(Animal):
    def sound(self):
        print("Meow...")        

class Dog(Animal):
    def sound(self):
        print("Woof...") 

class Snake(Animal):
    def sound(self):
        print("Hiss...") 

s1 = Snake("mark")
s1.sound()

#now if we want we can add another type of animals without chage anything before we writed..
#and these classes are independed from each other






#------------------------------------------------
#principle 3)
#Liskov Substitution Principle
#Objects in a program should be replaceable with instances of their base types
#without altering the correctness of that program. 
#Barbara Liskov
#if your change the place of objects from a class, your program should work correctly
#should not cause to any problem in your program

class Bird:
    def __init__(self, name):
        self.name = name

    def fly(self):
        print(f"{self.name} is flying...")

b1 = Bird("eagle")
b2 = Bird("penguin")

b2.fly()    #--->  penguin is flying...

#this is a bahavioral problem
#we should design class in which type that focus on behaviors not just work with attribute

class Bird:
    def __init__(self, name):
        self.name = name

class FlyingBird(Bird):
    def fly(self):
        print(f"{self.naem} is flying...")

b1 = Bird("penguin")
b2 = Flyingbird("eagle")
b2.fly()        







#------------------------------------------------
#principle 4)
#Interface Sergregation Principle
#many client-specific interfaces are better than one general-pupose interface
#many class to do few things is better than one class do many things

from abc import ABC

class Shape(ABC):
    def circle(self):
        pass

    def square(self):
        pass

    def rectangle(self):
        pass

class Circle(Shape):
    def circle(self):
        pass

    def square(self):
        pass

    def rectangle(self):
        pass

class Square(Shape):
    def circle(self):
        pass

    def square(self):
        pass

    def rectangle(self):
        pass


#this is  wrong way to implementation abstract class
#            
from abc import ABC

class shape(ABC):
    def draw(self):
        pass

class Circle(Shape):
    def draw(self):
        pass

class Square(Shape):
    def draw(self):
        pass






#------------------------------------------------
#principle 5)
#Dependency Inversion Principle
#High-level modules should not depend on low-level modules. 
#Both of them (top and bottom level modules) must depend on Abstractions    
#Top-level classes should not depend on lower-level classes; Both must depend on abstraction
#Abstractions should not depend on details. Details must depend on abstractions.
#Abstracts should not depend on details, but details should depend on abstractions

#Low-level classes : These are called classes that are responsible for basic and basic tasks in the software. Such as a class that communicates with a database or a class that is used to send an email.
#High-level classes: There are classes that perform more complex and specific operations and use low-level classes for this. For example, the reporting class needs the database class to record and read the report, and the Users class needs the email class to notify the users.
#Abstract classes (Abstraction): There are classes that cannot be implemented by themselves and are just a blueprint that other classes use.

class MySQL:
    def insert(self):
        pass
    def update(self):
        pass
    def delete(self):
        pass

class Log:
    def __init__(self):
        self.database = MySQL()        
    


#Now suppose we want to change the name of the MySQL class, in this case we must also change the name of 
#the class in the Log class in the new MySQL section. So the fifth principle of SOLID is violated here.
#Because the lower-level class is dependent on the upper-level class, and any change in the upper-level class results in a change in the lower-level class.

#Also, if we want to use another database like MongoDB instead of MySQL database for the high-level Log class,
#then we have to change the Log class again or write a separate class for each database. 
#Because the upper-level class is dependent on the lower-level class


#To solve this problem, we use the following example:

from abc import ABC, abstractmethod
#an interface is a abstract which al of methodes must be abstract
class Database(ABC):
    @abstractmethod
    def insert(self):
        pass
    @abstractmethod
    def update(self):
        pass
    @abstractmethod
    def delete(self):
        pass

class MySQL(Database):
    def insert(self):
        pass
    def update(self):
        pass
    def delete(self):
        pass

class FileSystem(Database):
    def insert(self):
        pass
    def update(self):
        pass
    def delete(self):
        pass
  
class MongoDB(Database):
    def insert(self):
        pass
    def update(self):
        pass
    def delete(self):
        pass
  
class Log:
    def __init__(self):
        pass
    def setDatabase(self, database):
        self.database = database
    def update(self):
        self.database.update()


logger = Log()
logger.setDatabase( MongoDB() )
logger.setDatabase( FileSystem() )
logger.setDatabase( MySQL() )
logger.update()



#example-2
# High-level Module
class PaymentProcessor:
    def __init__(self, payment_gateway):
        self.payment_gateway = payment_gateway

    def process_payment(self, amount):
        self.payment_gateway.pay(amount)

# Low-level Modules
class PayPalGateway:
    def pay(self, amount):
        print(f"Processing payment of ${amount} via PayPal.")

class StripeGateway:
    def pay(self, amount):
        print(f"Processing payment of ${amount} via Stripe.")

# Abstraction/Interface
class PaymentGateway(ABC):
    @abstractmethod
    def pay(self, amount):
        pass

# Dependency Injection
paypal_gateway = PayPalGateway()
payment_processor = PaymentProcessor(paypal_gateway)
payment_processor.process_payment(100)

stripe_gateway = StripeGateway()
payment_processor = PaymentProcessor(stripe_gateway)
payment_processor.process_payment(200)








##########################################################################################################
#DESIGN_PATTERN
##########################################################################################################









###################
#Singleton
###################
#simplest design pattern
#is from creational patterns
#let you to have only one instance no more
#constructor must be hide from other users
#users cant make an object directly
#logging is a common example of this design pattern

import collections as c1
import collections as c2

print(id(c1))   #--->  14000822
print(id(c2))   #--->  14000822

#eventhough we had to object but in real they are just one with the same id numbers
#pyhton dont let us to import one object in multiple times

#for implemention:
# 1- declaring all constructors of the class to be "private"
# 2- providing a static method to manage the instance

#------------------
#way-1

#in file "mymodule.py"
class A:
    pass

a_instance = A()

#in file "mycode.py"
from mymodule import a_instance 
second_instance = A()   #but user can make an other object for himself from here

#------------------
#way-2 
class A:
    _instance = None
    
    def __init__(self):
        raise RuntimeError("Call get_instance() instead")

    @classmethod
    def get_instance(cls):
        if cls._instance is None:
            cls._instance = cls.__new__(cls)
        return cls._instance


one = A()   #--->  RuntimeError
one = A.get_instance()
two = A.get_instance()

print(id(one))   #--->  139748305927 
print(id(two))   #--->  139748305927 
    
#we do something that you can make just one object from a class not more than it
    
#------------------
#way-3

class Singleton(type):
    _instance = None
    
    def __call__(self, *args, **kwargs):
        if self._instance is None:
            self._instance = super().__call__()
        return self._instance
    
class A(metaclass=Singleton):
    pass

one = A()
two = A()

print(id(one))   #--->  140038948289        
print(id(two))   #--->  140038948289        






###################
#Factory
###################
#is from creational patterns
#objects made from superclasses
#but allows subclasses to alter the type of objects
#3 components:  1.creator   define that which type of object must be created 
#               2.product   part of code that doing the main work
#               3.client    part of code that end-user work with it

from abc import ABC, abstractmethod

class File(ABC): # creator
    def __init__(self, file):
        self.file = file

    @abstractmethod
    def make(self):
        pass
        
    def call_edit(self):
        product = self.make()
        result = product.edit(self.file)    
        return result

class JsonFile(File): # creator
    def make(self):
        return Json()

class XmlFile(File): # creator 
    def make(self):
        return Xml()

class Json: # product
    def edit(self, file):
        return f"Working on {file} Json ..."            

class Xml: # product 
    def edit(self, file):
        return f"Working on {file} Xml ..."

def client(file, format): # client
    formats = {
        'json' : JsonFile,
        'xml'  : XmlFile
    }

    result = formats[format](file)
    #        xxxxxxxxxxxxxx|yyyyyy
    #        XmlFile       | myfile
    #                        ---> sent to init of XmlFile   
    #                             but XmlFile have not initializer so sent to superclass initializer
    #                        ---> __init__ of File
    # result is an object of XmlFile
    return result.call_edit()
    # XmlFile have not call_edit method
    # so will go to call_edit method in superclass
    #   inside of call_edit is self.make() but superclass dont have make() method
    #   so come to subclass make() method
    #   then it will call  Xml class
    # now in self.make() we have Xml class
    # then product var has Xml class
    # then it call edit method of product in real call edit method of Xml class
    # it will return a string to result inside of call_edit method in superclass
    # and it returned to client function
    # and this function return it to who call him in last line of this code


print(client("myfile","xml"))





###################
#Abstract Factory
###################
#is from creational patterns
#creating related/dependent objects without need to specify their actual class
#for example:
"""
car => bmw, benz => suv, coupe 
       benz suv  => gla
       bmw suv   => x1
       benz coupe=> cls
       bmw coupe => m2 
"""


from abc import ABC, abstractmethod

class Car(ABC): # Abstract Factory
    @abstractmethod
    def call_suv(self):
        pass
    
    @abstractmethod
    def call_coupe(self):
        pass
    
    
class Benz(Car): # Concrete Factory 1 
    def call_suv(self):
        return Gla()
    
    def call_coupe(self):
        return Cls()
    
class Bmw(Car): # Concrete Factory 2
    def call_suv(self):
        return X1()
    
    def call_coupe(self):
        return M2()       


class Suv(ABC): # Abstract Product A
    @abstractmethod
    def create_suv(self):
        pass
    
class Coupe(ABC): # Abstract Product B
    @abstractmethod
    def create_coupe(self):
        pass
    
    
class Gla(Suv): # Concrete Product A1
    def create_suv(self):
        print("This is your suv benz gla ...")        
    
class X1(Suv): # Concrete Product A2
    def create_suv(self):
        print("This is your suv Bmw X1 ...")        
      
class Cls(Coupe): # Concrete Product B1
    def create_coupe(self):
        print("This is your coupe Benz Cls ...")        
    
class M2(Coupe): # Concrete Product B2
    def create_coupe(self):
        print("This is your coupe Bmw M2 ...")        
                    
    
def client_suv(order): # Client
    brands = {
        'benz' : Benz,
        'bmw'  : Bmw
    }    
    suv = brands[order]().call_suv()
    suv.create_suv()
    
def client_coupe(order): # Client
    brands = {
        'benz' : Benz,
        'bmw'  : Bmw
    }    
    coupe = brands[order]().call_coupe()
    coupe.create_coupe()  
    
client_coupe('benz')    
    
    
    
    
    

###################
#Prototype
###################
#is from creational patterns
#let you copy existing objects withoud making your code dependent on their classes

import copy
class Prototype:
    def __init__(self):
        self._objects = {}
        
    def register(self, name, obj):
        self._objects[name] = obj
        
    def unregister(self, name):
        del self._objects[name]
        
    def clone(self, name, **kwargs):
        cloned_obj = copy.deepcopy(self._objects.get(name)) 
        cloned_obj.__dict__.update(kwargs)
        return cloned_obj           


def client_prototype(name, obj, **kwargs):
    prototype = Prototype()
    prototype.register(name, obj)
    return prototype.clone(name, **kwargs)

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
        
p = Person("amir", 34)
p_clone = client_prototype('p1', p)       
print(p_clone.__dict__)   #--->  {'name': 'amir', 'age': 34}
p_clone = client_prototype('p1', p, age=33)     
print(p_clone.__dict__)   #--->  {'name': 'amir', 'age': 33}

print(id(p.name))         #--->  140169762132080
print(id(p_clone.name))   #--->  140169762132080

p_clone2 = client_prototype('p1', p, age=19)
print(p_clone2.__dict__)  #--->  {'name': 'amir', 'age': 19}

p_clone2 = client_prototype('p2', p_clone, age=17)
print(p_clone2.__dict__)  #--->  {'name': 'amir', 'age': 17}






###################
#Builder
###################
#is from creational patterns
#lets you construct complex objects step by step
#allows you to produce different types and representations of an object using the same construction code 
import abc
class Car:  # product
    def __init__(self):
        self._wheel = None
        self._engine = None
        self._body = None
        
    def set_wheel(self, wheel):
        self._wheel = wheel
        
    def set_body(self, body):
        self._body = body
        
    def set_engine(self, engine):
        self._engine = engine
        
    def detail(self):
        print(f"Body: {self._body.shape}")                
        print(f"Engine: {self._engine.hp}")                
        print(f"Wheel: {self._wheel.size}")                


class AbstractBuilder(abc.ABC):
    
    @abc.abstractmethod
    def get_engine(self): pass
     
    @abc.abstractmethod
    def get_engine(self): pass
    
    @abc.abstractmethod
    def get_engine(self): pass 

class Benz(AbstractBuilder): # Concrete Builder 1
    def get_body(self):
        body = Body()
        body.shape = 'Suv'
        return body
    def get_engine(self):
        engine = Engine()
        engine.hp = 500
        return engine
    def get_wheel(self):
        wheel = Wheel()
        wheel.size = 22
        return wheel

class Bmw(AbstractBuilder):
    def get_body(self):
        body = Body()
        body.shape = 'Sedan'
        return body
    def get_engine(self):
        engine = Engine()
        engine.hp = 340
        return engine
    def get_wheel(self):
        wheel = Wheel()
        wheel.size = 20
        return wheel

class Wheel: size = None
class Body: shape = None
class Engine: hp = None

class Director:
    _builder = None
    
    def set_builder(self, builder):
        self._builder = builder
        
    def construct(self):
        car = Car()
        
        body = self._builder.get_body()
        car.set_body(body)

        wheel = self._builder.get_wheel()
        car.set_wheel(wheel)
        
        engine = self._builder.get_engine()
        car.set_engine(engine)
        
        return car
    
def client_builder(builder):
    builders = {
        'bmw': Bmw,
        'benz': Benz
    }    
    
    car = builders[builder]()
    director = Director()
    director.set_builder(car)
    result = director.construct()
    return result.detail()

client_builder("benz")
    





###################
#Adapter
###################
#is from structural patterns
#allows objects with incompatible interfaces to collaborate
#assume there is a 'data.xml' file in project directory
import xmltodict
class Application:
    def send_request(self):
        return "data.xml"
    
class Analytic:
    def receive_request(self, json):
        return json
    
class Adapter:
    def convert_xml_json(self, file):
        with open(file, 'r') as myfile:
            obj = xmltodict.parse(myfile.read())        
            return obj
        
def client_adapter():
    sender = Application().send_request()
    converted_data = Adapter().convert_xml_json(sender)
    receiver = Analytic().receive_request(converted_data)
    print(receiver)

client_adapter()


###################
#Decorator
###################
#is from structural patterns
#allows adding new behaviors to objects dynamically by placing them inside special wrapper objects 
#,called decorators 


class Page(abc.ABC): # Abstract Component
    
    @abc.abstractmethod
    def show(self):
        pass


class AuthPage(Page): # Concrete Component 1
    def show(self):
        print("Welcome to authenticated page")

class AnonPage(Page): # Concrete Component 2
    def show(self):
        print("Welcome to anonymous page")


class PageDecorator(Page, abc.ABC): # Abstract Decorator
    def __init__(self, component):
        self._component = component
    
    @abc.abstractmethod
    def show(self):
        pass    

class PageAuthDecorator(PageDecorator): # Concerete Decorator
    def show(self):
        username = input("Enter your username... ")
        password = input("Enter your password... ")
        if username == "admin" and password == "secret":
            self._component.show()
        else:
            print("you are not authenticated")            

def client_decorator(): 
    page = AuthPage()
    authenticated = PageAuthDecorator(page)
    authenticated.show()

client_decorator()




 
 
    
###################
#Facade
###################
#is from structural patterns
#provides a simplified interface to a library, a framework, 
#or any other complex set of classes

class CPU: # Subsystem 1
    def execute(self):
        print("Executing... ")
        
class Memory: # Subsystem 2
    def load(self):
        print("Loading Data... ")        

class SSD: # Subsystem 3
    def read(self):
        print("Some data from ssd... ")

class Computer: # Facade
    def __init__(self):
        self.cpu = CPU()
        self.memory = Memory()
        self.ssd = SSD()
        
    def start(self):
        self.memory.load()
        self.ssd.read()
        self.cpu.execute()
        
def client_facade():
    computer_facade = Computer()
    computer_facade.start()
    
client_facade()                
    
    
    
#example2
class Computer: # Facade
    def __init__(self, sub1, sub2, sub3):
        self.subsystem1 = sub1()
        self.subsystem2 = sub2()
        self.subsystem3 = sub3()
        self.firstOp = sub1
        self.secondOp = sub2
        self.thirdOp = sub3
        
    def start(self):
        operats = {
            "CPU":    execute,
            "SSD":    read,
            "Memory": load
        }
        
        self.subsystem1.operats[self.firstOp]()
        self.subsystem2.operats[self.secondOp]()
        self.subsystem3.operats[self.thirdOp]()
        self.subsystem3.operats[sub1]()
        self.subsystem3.operats[self.sub1]()
        
        
def client_facade():
    computer_facade = Computer(CPU, Memory, SSD)
    computer_facade.start()
    
client_facade()        
  
  
    
    
    
    
###################
#Proxy
###################
#is from structural patterns
#lets you provide a substitute or placeholder for another object
#a proxy, controls access to the original object, allowing you to perform
#something either before or after the request gets through to the original object

import abc
import time
import datetime

class AbstractServer(abc.ABC):  # Abstract Service
    
    @abc.abstractmethod
    def receive(self):
        pass
    
class Server(AbstractServer):   # Concrete Service
    def receive(self):
        print("Processing your request...")    
        time.sleep(1)
        print("Done... ")

class LogProxy(AbstractServer):     # Proxy     
    def __init__(self, server):
        self._server = server
        
    def receive(self):
        self.logging()
        # ...
        self._server.receive()
        
    def logging(self):
        with open('log.log', 'a') as log:        
            log.write(f"Request {datetime.datetime.now()} \n")

def client_server(server, proxy):   # Interface
    s = server()
    p = proxy(s)
    p.receive()
    
client_server(Server, LogProxy)         
    
    
    
    

###################
#Composite
###################
#is from structural patterns
#let you compose objects into tree structures and then
#work with these structures as if they were individual objects

import abc

class Being(abc.ABC): # Abstact Component
    def add(self, child):
        pass
    def remove(self, child):
        pass
    def is_composite(self):
        return False
    
    @abc.abstractmethod
    def execute(self):
        pass

class Animal(Being): # Leaf
    def __init__(self, name):
        self.name = name
    def execute(self):
        print(f"Animal {self.name}")

class Human(Being): # Concrete Composite
    def __init__(self):
        self._children = []
        
    def add(self, child):
        self._children.append(child)
        
    def remove(self, child):
        self._children.remove(child)
        
    def is_composite(self):
        return True
    
    def execute(self):
        print("Human Composite")
        
        for child in self._children:
            child.execute()            

class Male(Human): # Leaf
     def __init__(self, name):
        self.name = name
        
    def is_composite(self):
        return False
    
    def execute(self):
        print(f"\tMale {self.name}") 

class Female(Human): # Leaf
    def __init__(self, name):
        self.name = name
        
    def is_composite(self):
        return False
    
    def execute(self):
        print(f"\tFemale {self.name}")    

def client_composite():
    f1 = Female("jane")
    f2 = Female("katty")
    m1 = Male("brad")

    h1 = Human()
    h1.add(f1)
    h1.add(f2)
    h1.add(m1)
    
    h1.execute()
    
client_composite()    





###################
#Bridge
###################
#is from structural patterns
#let you split a large class into two seperate hierarchies
#abstraction and implementation
#which can be developed independently of each other
    
import abc
class Shape(abc.ABC):   # Abstraction 
    def __init__(self, color):
        self.color = color
    
    def show(self):
        pass
    
class Circle(shape): # Refine Abstraction
    def show(self):
        self.color.paint(self.__class__.__name__)
        
class Square(shape): # Refine Abstraction
    def show(self):
        self.color.paint('square')            


class Color(abc.ABC): # Implementation
    def paint(self, name):
        pass
    
class Blue(Color):  # Concrete Implementation
    def paint(self, name):
        print(f"this is a blue {name}")    

class Red(Color):   # Concrete Implementation
    def paint(self, name):
        print(f"this is a red {name}") 
  
red = Red()
circle = Circle(red)
circle.show()  
  
  
    
    
    


###################
#Chain of Responsiblility
###################
#is from behavioral patterns
#lets you pass requests along a chain of handlers
#upon receiving a request, each handler decides either to process the request or to pass
#it to the next handler in the chain

import abc

class AbstractHandler(abc.ABC): # Abstract Handler   
    @abc.abstractmethod
    def set_next(self, handler):
        pass
    
    @abc.abstractmethod
    def handle(self, request):
        pass

class BaseHandler(AbstractHandler): # Base Handler
    _next_handler = None
    
    def set_next(self, handler):
        self._next_handler = handler
        return handler
    
    @abc.abstractemethod
    def handle(self, request):
        if self._next_handler:
            return self._next_handler.handle(request)
        return None
        
class HandlerOne(BaseHandler):  # Concrete Handler 1
    def handle(self, request):
        if 0 < request <= 10:
            print(f"HandlerOne is processing this request {request}")
        else:
            return super().handle(request) 

class HandlerTwo(BaseHandler):  # Concrete Handler 2
    def handle(self, request):
        if 10 < request <= 20:
            print(f"HandlerTwo is processing this request {request}")
        else:
            return super().handle(request)   
        
class DefaultHandler(BaseHandler):  # Concrete Handler Default
    def handle(self, request):
        print(f"DefaultHandler is processing this request {request}")             

def client(handler, request):
    for num in request:
        handler.handle(num)
        
nums = [3, 14, 31, 9]

h_one = HandlerOne()
h_two = HandlerTwo()
h_default = DefaultHandler()

h_one.set_next(h_two).set_next(h_default)   

client(h_one, nums)     
client(h_two, nums)     
    
    
    
    



###################
#Command
###################
#is from behavioral patterns
#turns a request into a stand-alone object that
#contains all information about the request. this transformation lets you pass requests 
#as a method arguments, delay or queue a requests execution, and support undoable operations
import abc

class Command(abc.ABC):
    
    @abc.abstractmethod
    def execute(self):
        pass

class SimpleCommand(Command):
    def __init__(self, payload):
        self._payload = payload
    
    def execute(self):
        print(f"SimpleCommand: I can do simple things like printing ({self._payload})")    

class ComplexCommand(Command):
    def __init__(self, receiver, a, b):
        self._receiver = receiver
        self._a = a
        self._b = b
        
    def execute(self):
        print("ComplexCommand: Complex stuff should be done a receiver object", end = ' ' ) 
        self._receiver.do_something(self._a)
        self._receiver.do_something_else(self._b)

class Receiver:
    def do_something(self, a):
        print(f"\nReceiver: working on ({a}.)", end = '')
    
    def do_something_else(self, b):
        print(f"\nReceiver: working on ({b}.)", end = '')    

class Invoker:
    _on_start = None
    _on_finish = None
    
    def set_on_start(self, command):
        self._on_start = command
    
    def set_on_finish(self, command):
        self._on_finish = command  
        
    def operation(self):
        self._on_start.execute()
        self._on_finish.execute()      
        
        
        

invoker = Invoker()
invoker.set_on_start(SimpleCommand("Say Hi!"))

receiver = Receiver()
invoker.set_on_finish(ComplexCommand(receiver, 'Send email', 'Save report'))


###################
#Observer
###################
#is from behavioral patterns
#lets you define a subscription mechanism to notify multiple objects about any
#events that happen to the object they're observing    


import abc
from random import randrange

class Publisher(abc.ABC):
    
    @abc.abstractmethod
    def subscribe(self, observer):
        pass
    
    @abc.abstractmethod
    def unsubscribe(self, observer):
        pass
    
    @abc.abstractmethod
    def notify(self):
        pass
    

class ConcretePublisher(Publisher):
    _observers = []
    _state = None
    
    def subscribe(self, observer):
        self._observers.append(observer)
    
    def unsubscribe(self, observer):
        self._observers.remove(observer)
    
    def notify(self):
        print("Notifying observers... ")
        
        for observer in self._observers:
            observer.update(self)
            
    def operation(self):
        self._state = randrange(0,10)
        print(f"state changed to {self._state}")
        self.notify() 

class Observer(abc.ABC):
    
    @abc.abstractmethod
    def update(self, publisher):
        pass
    
class ObserverA(Observer):
    def update(self, publisher):
        if publisher._state <= 5:
            print("ObserverA reacted to ehe event")    
    
class ObserverB(Observer):
    def update(self, publisher):
        if publisher._state > 5:
            print("ObserverB reacted to ehe event")   

publisher = ConcretePublisher()
observer_a = ObserverA()
observer_b = ObserverB()    
    
publisher.subscribe(observer_a) 
publisher.subscribe(observer_b)  

publisher.operation()





###################
#Mediator
###################
#is from behavioral patterns
#lets you reduce chaotic dependencies between objects
#The pattern restricts direct communications between the objects and forces them to collaborate
#only via a mediator object 


import abc


class AbstractMediator(abc.ABC):
    
    @abc.abstractmethod
    def notify(self, sender, event):
        pass

class ConcreteMediator(AbstractMediator):
    def __init__(self, comp_a, comp_b):
        self.comp_a = comp_a
        self.comp_a.set_mediator(self)
        self.comp_b = comp_b
        self.comp_b.set_mediator(self)
        
    def notify(self, sender, event):
        self.comp_b.receive(sender, event)
        
class AbstractComponent(abc.ABC):
    def __init__(self, mediator = None):
        self.mediator = mediator            

    def set_mediator(self, mediator):
        self._mediator = mediator
    
    @abc.abstractmethod    
    def receive(self, sender, event):
        pass    

    @abc.abstractmethod    
    def notify(self, event):
        pass     

class Component1(AbstractComponent):    # Component 1 
    def receive(self, sender, event):
        print(f"Component 1 received event ({event}) from: {sender.__class__.__name__}")
        
    def notify(self, event):
        self._mediator.notify(self, event)
        
    def do_a(self):
        print("Component 1 does A.")
        self.notify('A')        

class Component2(AbstractComponent):
    def receive(self, event):
        print(f"Component 2 received event ({event}) from: {sender.__class__.__name__}")
        
    def notify(self, event):
        self._mediator.notify(self, event)
        
    def do_b(self):
        print("Component 2 does B.")
        self.notify('B')       


class Component3(AbstractComponent):
    def receive(self, event):
        print(f"Component 3 received event ({event}) from: {sender.__class__.__name__}")
        
    def notify(self, event):
        self._mediator.notify(self, event)
        
    def do_c(self):
        print("Component 3 does C.")
        self.notify('C')       


com1 = Component1()
com2 = Component2()
com3 = Component3()

mediator = ConcreteMediator(com3, com1) # com3 sender , com1 receiver
com3.do_c() #--->  Component 3 does C
            #      Component 1 received event (c) from: Component3




###################
#Template Method
###################
#is from behavioral patterns
#defines the skeleton of an algorithm in the superclass
#but lets subclasses override specific steps of the algorithm without changing its structure    
    
import abc

class Top(abc.ABC): # Super Class
    def template_method(self):  
        self.first_common()
        self.second_common()
        self.third_require()
        self.fourth_require()
        
    
    def first_common(self):
        print("This is first common...")         
    
    def second_common(self):
        print("This is second common...")
        
    @abc.abstractmethod
    def third_require(self):
        pass
    
    @abc.abstractmethod
    def fourth_require(self):
        pass
    
class One(Top):
    def third_require(self):
        print("This is third require from class: One")
        
    def fourth_require(self):
        print("This is fourth require from class: One")    
            
class Two(Top):
    def third_require(self):
        print("This is third require from class: Two")
        
    def fourth_require(self):
        print("This is fourth require from class: Two")    
        
def client(klass):
    klass.template_method()   
    
client(Two())   #--->  This is first common...
                #      This is second common...
                #      This is third require from class: Two
                #      This is fourth require from class: Two                  
    
    
    
    
    
###################
#Strategy
###################
#is from behavioral patterns
#lets you define a family of algorithms, put each of them into a separate class
#and make their objects interchangeable
 
import abc

class Read: # Context
    def __init__(self, sentence):
        self.sentence = sentence
        self._direction = None  # Strategy instance
        
    def set_direction(self, direction): # set_strategy
        self._direction = direction
        
    def read(self):
        return self._direction.direct(self.sentence)
    
class Direction(abc.ABC):   #   Abstract Strategy
    
    @abc.abstractmethod
    def direct(self, data):
        pass
    
class Right(Direction): # Concrete Strategy
    def direct(self, data):
        print(data[::-1])
    
class Left(Direction): # Concrete Strategy
    def direct(self, data):
        print(data[::1])                      


c = Read("Hello world")

c.set_direction(Right())
c.read() #--->  dlrow olleH

c.set_direction(Left())
c.read() #--->  Hello World







###################
#State
###################
#is from behavioral patterns
#lets an object alter its beahavior when its internal state changes.
#it appears as if the object changed its class

import abc

class Elevator: # Context
    _state = None
    
    def __init__(self, state):
        self.set_state(state)
        
    def set_state(self, state):
        self._state = state
        self._state.set_elevator(self)   
        
    def show_state(self):
        print(f"Elevator is in {self._state.__class__.__name__}") 
        
    def go_up(self):
        self._state.push_up_btn()
        
    def go_down(self):
        self._state.push_down_btn()             

class Floor(abc.ABC):   # Abstract State
    _elevator = None
    
    def set_elevator(self, elevator):
        self._elevator = elevator
        
    @abc.abstractmethod
    def push_down_btn(self):
        pass
    
    @abc.abstractmethod
    def push_up_btn(self):
        pass
        
class FirstFloor(Floor):    # Concrete State
    def push_down_btn(self):
        print("Already in the bottom floor")
        
    def push_up_btn(self):
        print("Elevator moving upward one floor") 
        self._elevator.set_state(SecondFloor())
           
class SecondFloor(Floor):   # Concrete State
    def push_down_btn(self):
        print("Elevator moving down a floor")      
        self._elevator.set_state(FirstFloor())      

    def push_up_btn(self):
        print("Already in the top floor")


e = Elevator(FirstFloor())

e.show_state()  #--->  Elevator is in FirstFloor
e.go_up()       #--->  Elevator moving upward one floor
e.show_state()  #--->  Elevator is in SecondFloor
e.go_up()       #--->  Already in the top floor
e.go_down()     #--->  Elevator moving down a floor
e.show_state()  #--->  Elevator is in FirstFloor
e.go_down()     #--->  Already in the bottom floor







###################
#Memento
###################
#is from behavioral patterns
#lets you save and restore the previous state of an object

import abc
from datetime import datetime
from random import sample
from string import ascii_letters

class Originator:
    _state = None
    
    def __init__(self, state):
        self._state = state
        print(f"Originator: My initial state is: {self._state}")

    def do_something(self):
        print(f"Originator: I am doing something important...")
        self._state = self._generate_random_string(30)
        print(f"Originator: My state has changed to: {self._state}")
        
    def _generate_random_string(self, length):
        return ''.join(sample(ascii_letters, length))
    
    def save(self):
        return ConcreteMemento(self._state)
    
    def restore(self, memento):
        self._state = memento.get_state()
        print(f"Originator: state has changed to: {self._state}")
         

class Memento(abc.ABC):
    @abc.abstractmethod
    def get_name(self):
        pass
    
    @abc.abstractmethod
    def get_date(self):
        pass
    
class ConcreteMemento(Memento):
    def __init__(self, state):
        self._state = state
        self._date  = str(datetime.now())
        
    def get_state(self):
        return self._state
    
    def get_name(self):
        return f"{self._date} / {self._state}"    
    
    def get_date(self):
        return self._date
    
class Caretaker:
    def __init__(self, originator):
        self._originator
        self._mementos = []
        
    def backup(self):
        print("\nCareTaker: saving originator state...")
        self._mementos.append(self._originator.save())             

    def undo(self):
        if not(self._mementos):
            return Non 

        memento = self._mementos.pop()
        print(f"CareTaker: Restoring state to: {memento.get_name()}")
        try:
            self._originator.restore(memento)
        except Exception:
            self.undo()    

    def show_history(self):
        print("CareTaker: here is the list of mementos: ")
        for memento in self._mementos:
            print(memento.get_name())    

originator = Originator("first-state")
caretaker = Caretaker(originator)
caretaker.backup()
originator.do_something()
caretaker.backup()
originator.do_something()
caretaker.backup()
originator.do_something()
print()
caretaker.show_history()
caretaker.undo()
caretaker.undo()
caretaker.undo()

caretaker.undo()





###################
#Visitor
###################
#is from behavioral patterns
#allows adding new behaviors to existing class hierarchy without altering any existing code



#ordering -> visitor

import abc

class PublicVehicle(abc.ABC):   # Abstract Element
    
    def __init__(self, dest):
        self.dest = dest
    
    
    @abc.abstractmethod
    def order_ticket(self, ordering):
        pass
    
class Train(PublicVehicle):     # Concrete Element 1
    def order_ticket(self, ordering):   # Accept Method
        ordering.train_ticket(self) #send element to visitor   

class Bus(PublicVehicle):     # Concrete Element 2
    def order_ticket(self, ordering):   # Accept Method
        ordering.bus_ticket(self) #send element to visitor 

class Plane(PublicVehicle):     # Concrete Element 2
    def order_ticket(self, ordering):   # Accept Method
        ordering.plane_ticket(self) #send element to visitor 

class Ticket(abc.ABC):  # Abstract Visitor
    
    @abc.abstractmethod
    def train_ticket(self, train):
        pass
    
    @abc.abstractmethod
    def bus_ticket(self, bus):
        pass
    
    @abc.abstractmethod
    def plane_ticket(self, plane):
        pass
    
class Order(Ticket):    # Concrete Visitor
    
    def train_ticket(self, train):
        print(f"This is a train ticket to {train.dest}")

    def bus_ticket(self, bus):
        print(f"This is a bus ticket to {bus.dest}")

    def plane_ticket(self, plane):
        print(f"This is a plane ticket to {plane.dest}")

o = Order()
Bus('Tehran').order_ticket(o)
    
    
    
    
    
###################
#Iterator
###################
#is from behavioral patterns    
#lets us to iterate in an object items   
    
class MyNumbers:
    def __iter__(self):
        self.a = 1
        return self

    def __next__(self):
        if self.a <= 20:
            x = self.a
            self.a += 1
            return x
        else:
            raise StopIteration
    
myclass = MyNumbers()
myiter = iter(myclass)

print(next(myiter)) #--->  ???
print(next(myiter)) #--->  ???
print(next(myiter)) #--->  ???
print(next(myiter)) #--->  ???
print(next(myiter)) #--->  ???

for x in myiter:
    print(x)  #--->  ???    
    
    
#way-2
class Friends:
    def __init__(self):
        self.names = ["alexa", "roberto", "eliza", "marko", "vladmir"]

    def __iter__(self):
        self.names_copy = self.names

    def __next__(self):
        if self.names_copy:
            return self.names_copy.pop()
        else:
            raise StopIteration        



f = Friends()
x = iter(f)
print(next(x))  #--->  vladmir
print(next(x))  #--->  marko
print(next(x))  #--->  eliza
print(next(x))
print(next(x))
print(next(x))    
    
    
    
    
    
    
    

###################
#Flyweight
###################
#is from structural patterns    
#used commonly in game developement to decrese memory usage


import abc

class Flyweight(abc.ABC):   # Abstract Flyweight
    
    @abc.abstractmethod
    def operation(self):
        pass
    
class sadasd(Flyweight):  # Concrete Shared Flyweight
    pass    
    
class sadasd(Flyweight):  # Concrete Unshared Flyweight
    pass   

class sadasd(Flyweight):   # Flyweight Factory      
    pass





###################
#Object pool
###################
#is from creational patterns   
#Offer a significant performance boost; it is most effective in situations where the cost of initializing a class instance is high, the
#rate of instantiation of a class is high, and the number of instantiations in use at any one time is low.


class ReusablePool:
    """
    Manage Reusable objects for use by Client objects.
    """

    def __init__(self, size):
        self._reusables = [Reusable() for _ in range(size)]

    def acquire(self):
        return self._reusables.pop()

    def release(self, reusable):
        self._reusables.append(reusable)


class Reusable:
    """
    Collaborate with other objects for a limited amount of time, then
    they are no longer needed for that collaboration.
    """

    pass


def main():
    reusable_pool = ReusablePool(10)
    reusable = reusable_pool.acquire()
    reusable_pool.release(reusable)



 
 
class Pool:
    '''Manage pool objects'''
    
    def __init__(self, size):
        self._objects = [PoolObject() for i in range(size)]
        
    
    def get_object(self):
        return self._objects.pop()
        
    def release_object(self, obj):
        self._objects.append(obj)
        
class PoolObject:
    pass

if __name__ == "__main__":
    pool = Pool(10)
    obj1 = pool.get_object()
    pool.release_object(obj1)    
    
    

#Disadvantages of design patterns:
#   It targets the wrong problem
#   No official foundations
#   It leads to ineffective solutions
#   It is not significantly different from other separations


#---------------------------------
#Creative design patterns
#---------------------------------
#These design patterns are more about instantiating classes. You can further divide these patterns into class creation patterns and object creation patterns. While class creation patterns effectively use inheritance in the instantiation process, object creation patterns effectively use delegation to do the work.

#Abstract Factory template          Creates an instance of several families of classes.
#Template Builder                   They separate the construction of the object from its presentation.
#Factory template                   They create an instance of several derived classes.
#Object Pool template               By recovering objects that are no longer in use, it prevents freeing up resources and costly access.
#Prototype template                 A complete prototype to be copied or cloned.
#Singleton pattern                  A class that can only have one instance of it.

#---------------------------------
#Structural design patterns
#---------------------------------
#These design patterns include a combination of class and object. Structural design patterns use inheritance to create interfaces. Structural patterns of objects define ways to combine them and obtain new functionality.

#Adapter template                   Matches interfaces of different classes.
#Bridge pattern                     An interface separates an object from its implementer.
#Composit pattern                   It is a tree structure of simple and compound objects.
#Decorator pattern                  Adds responsibilities dynamically to objects.
#Facade pattern                     A single class representing a complete subsystem.
#Flyweight pattern                  An example with small details is useful for sharing.
#Private Class Data template        Restrict accessor/mutator access.
#Proxy template                     An object that represents another object.

#---------------------------------
#Behavioral design patterns      
#---------------------------------  
#These design patterns examine the relationships between class objects. Behavioral patterns are those patterns that are specifically related to the relationship between objects.
#Chain of responsibility pattern    It is a way to send requests between chains of objects.
#Command template                   Encapsulate the command request as an object.
#Interpreter template               A way to include language elements in a program.
#Iterator pattern                   Sequential access to the elements of an array.
#Mediator template                  Define simple relationships between classes
#Memento template                   Get and retrieve the internal state of an object
#The Null Object pattern            Designed to act as the default value of an object.
#Observer pattern                   A way to notify a change to a number of classes
#State template                     When an object changes, its behavior changes
#Strategy template                  Encapsulating the algorithm inside an encapsulating class
#Template template                  Deferring the exact steps of an algorithm to a subclass
#Visitor template                   Defining a new operation for an unchanged class




##########################################################################################################
#DEVOPS
##########################################################################################################
#https://www.javatpoint.com/devops
#???

##########################################################################################################
#STANDARD_CODE
##########################################################################################################
#1-Module Doc String
"""
in standard python ypu must have a doc like this to describe about file (what is this file?)
for example this code is to learn python
you must have this String in first line (line 1)
"""

#2-Blank Line Before Func
''''
you should have at least 2 blank line before describe function, for example:

asdasdsadsd aasdsadsadsadsad


def myFunc() :
    sadasdsad
    dsasasad
    sadsadsad
    
'''

#3-Doc String inside of Functions

def myFunc() :
    '''
    you should have a doc string for each of your funcs to say that what this func do
    '''
    print("hello")
    print("world")

#4-white space around operators
if a == 0 :     #is better
    print("ok")
if a==0:
    print("ok")     

#5-white space before & after '('
myFunc()        #is better
myFunc ()
print(myFunc()) #is better
print( myFunc())


#6-funcs name -> snake case
#   myfunc()    
#   myFunc()    --->  is better
#   MyFunc()
#   MYFUNC()


#7-Doc String inside of Module
"The docstring of mymodule"
def sum(x,y):
   return x+y

#8-Doc string for class
class heyvoon() :
    '''
    a class to definite animals with some methods
    '''
    def __init__(self) :
        self.legs = 4
        self.sound = "Meow"
        self.breath = True
        
    def talk(self):
        return self.sound






















    











